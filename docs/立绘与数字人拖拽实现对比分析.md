# 立绘与数字人拖拽实现对比分析

## 一、立绘拖拽实现完整流程

### 1.1 模板部分（Template）

```vue
<!-- 伙伴立绘图片显示 -->
<div 
  v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar"
  class="illustration-container"
  :class="{ dragging: isDraggingPartner }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartner($event)"
>
  <img 
    :src="partnerIllustrationImageUrl" 
    :alt="currentPartnerRoleName || '伙伴立绘'"
    class="illustration-image"
  />
</div>
```

**关键点：**
1. **直接在模板中定义容器**：使用 `v-if` 条件渲染，容器直接存在于模板中
2. **直接绑定事件**：`@mousedown="startDragPartner($event)"` 直接在模板中绑定
3. **使用计算属性样式**：`:style="partnerAvatarPositionStyle"` 动态计算位置和大小
4. **拖拽状态类**：`:class="{ dragging: isDraggingPartner }"` 用于拖拽时的样式

### 1.2 全局鼠标事件监听（onMounted）

**位置**：`onMounted` 钩子中

**实现逻辑：**

```javascript
onMounted(() => {
  // 标志：是否正在处理立绘拖动
  let isHandlingIllustrationDrag = false
  
  // 添加全局mousedown监听，检测鼠标位置
  const globalMouseDown = (event: MouseEvent) => {
    // 1. 如果正在处理立绘拖动，跳过
    if (isHandlingIllustrationDrag) {
      return
    }
    
    // 2. 如果事件目标已经是立绘容器或其子元素，说明事件已经到达立绘，不处理
    const target = event.target as HTMLElement
    if (target && (target.classList.contains('illustration-container') || target.closest('.illustration-container'))) {
      return
    }
    
    const x = event.clientX
    const y = event.clientY
    
    // 3. 检测是否在面板区域（优先级高过立绘）
    const panelWrapper = document.querySelector('.history-panel-wrapper') as HTMLElement
    if (panelWrapper && panelWrapper.style.display !== 'none') {
      const panelRect = panelWrapper.getBoundingClientRect()
      if (x >= panelRect.left && x <= panelRect.right && y >= panelRect.top && y <= panelRect.bottom) {
        return // 在面板区域，正常处理，不拦截
      }
    }
    
    // 4. 检测是否在立绘区域
    const illustrationContainers = document.querySelectorAll('.illustration-container') as NodeListOf<HTMLElement>
    let clickedIllustration: HTMLElement | null = null
    
    for (const container of illustrationContainers) {
      const rect = container.getBoundingClientRect()
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        clickedIllustration = container
        break
      }
    }
    
    // 5. 如果点击在立绘区域
    if (clickedIllustration) {
      // 设置标志：正在处理立绘拖动
      isHandlingIllustrationDrag = true
      
      // 隐藏面板（如果显示）
      const panelVisible = panelWrapper && panelWrapper.style.display !== 'none'
      if (panelVisible) {
        panelWrapper.style.display = 'none'
        historyPanelVisibleBeforeDrag.value = true
      } else {
        historyPanelVisibleBeforeDrag.value = false
      }
      
      // 将鼠标事件目标指向立绘容器，触发立绘容器的@mousedown事件
      const syntheticEvent = new MouseEvent('mousedown', {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        button: event.button,
        buttons: event.buttons,
        view: window
      })
      
      // 在立绘容器上触发事件，让Vue的事件系统处理
      clickedIllustration.dispatchEvent(syntheticEvent)
      
      event.preventDefault()
      event.stopPropagation()
    }
  }
  document.addEventListener('mousedown', globalMouseDown, true) // 使用捕获阶段，优先处理
  
  // 添加全局mouseup监听，清除标志
  const globalMouseUp = () => {
    isHandlingIllustrationDrag = false
  }
  document.addEventListener('mouseup', globalMouseUp, true)
})
```

**关键点：**
1. **使用捕获阶段**：`addEventListener('mousedown', globalMouseDown, true)` 在捕获阶段处理，优先于其他事件
2. **检测立绘容器**：使用 `document.querySelectorAll('.illustration-container')` 查找所有立绘容器
3. **手动触发事件**：使用 `dispatchEvent` 在立绘容器上触发 `mousedown` 事件，让Vue的事件系统处理
4. **标志管理**：使用 `isHandlingIllustrationDrag` 标志防止重复处理

### 1.3 拖拽开始函数（startDragPartner）

```javascript
function startDragPartner(event: MouseEvent) {
  if (!currentPartnerRole.value || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events，避免拦截拖动事件
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingPartner.value = true
  dragType.value = 'partner'
  dragStartX.value = event.clientX
  dragStartY.value = event.clientY
  dragStartPositionX.value = currentPartnerRole.value.positionX !== undefined ? currentPartnerRole.value.positionX : 50
  dragStartPositionY.value = currentPartnerRole.value.positionY !== undefined ? currentPartnerRole.value.positionY : 50
  draggingPartnerPositionX.value = dragStartPositionX.value
  draggingPartnerPositionY.value = dragStartPositionY.value
  
  // 立即提升立绘的z-index（通过内联样式）
  const illustrationContainer = event.currentTarget as HTMLElement
  if (illustrationContainer) {
    illustrationContainer.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDrag, { passive: false })
  document.addEventListener('mouseup', endDragPartner)
}
```

**关键点：**
1. **直接使用 event.currentTarget**：`event.currentTarget` 就是立绘容器元素
2. **禁用其他元素的pointer-events**：防止拖拽时被其他元素拦截
3. **提升z-index**：通过内联样式直接设置 `zIndex = '1000'`
4. **添加全局事件监听**：在 `document` 上添加 `mousemove` 和 `mouseup` 监听

### 1.4 拖拽处理函数（handleDrag）

```javascript
function handleDrag(event: MouseEvent) {
  if (!dragType.value) return
  
  const deltaX = event.clientX - dragStartX.value
  const deltaY = event.clientY - dragStartY.value
  
  // 计算新位置（百分比）
  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight
  const newPositionX = Math.max(0, Math.min(100, dragStartPositionX.value + (deltaX / containerWidth) * 100))
  const newPositionY = Math.max(0, Math.min(100, dragStartPositionY.value + (deltaY / containerHeight) * 100))
  
  if (dragType.value === 'partner') {
    draggingPartnerPositionX.value = newPositionX
    draggingPartnerPositionY.value = newPositionY
  }
  // ... 其他类型
}
```

**关键点：**
1. **计算位置变化**：使用 `deltaX` 和 `deltaY` 计算位置变化
2. **转换为百分比**：将像素变化转换为百分比
3. **更新临时位置**：更新 `draggingPartnerPositionX` 和 `draggingPartnerPositionY`，这些值会被 `partnerAvatarPositionStyle` 计算属性使用

### 1.5 拖拽结束函数（endDragPartner）

```javascript
async function endDragPartner(_event: MouseEvent) {
  if (!isDraggingPartner.value || !currentPartnerRole.value || !appState.llm.apiKey) {
    cleanupDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', endDragPartner)
  
  const finalPositionX = draggingPartnerPositionX.value ?? dragStartPositionX.value
  const finalPositionY = draggingPartnerPositionY.value ?? dragStartPositionY.value
  
  // 更新角色配置
  try {
    await updateRole(
      currentPartnerRole.value.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 重新加载角色信息
    await loadCurrentPartnerRole()
  } catch (error) {
    console.error('更新伙伴角色位置失败:', error)
  }
  
  cleanupDrag()
}
```

**关键点：**
1. **移除事件监听**：移除 `mousemove` 和 `mouseup` 监听
2. **保存位置**：调用 `updateRole` API 保存位置
3. **重新加载角色**：调用 `loadCurrentPartnerRole()` 重新加载角色信息
4. **清理状态**：调用 `cleanupDrag()` 清理所有拖拽相关状态

### 1.6 清理函数（cleanupDrag）

```javascript
function cleanupDrag() {
  isDraggingPartner.value = false
  isDraggingUser.value = false
  isDraggingPartnerDigitalHuman.value = false
  isDraggingUserDigitalHuman.value = false
  dragType.value = null
  draggingPartnerPositionX.value = null
  draggingPartnerPositionY.value = null
  draggingUserPositionX.value = null
  draggingUserPositionY.value = null
  
  // 恢复config-panel和chat-tab的pointer-events
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = ''
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = ''
  }
  
  // 恢复面板显示（如果拖动前是显示的）
  if (historyPanelVisibleBeforeDrag.value) {
    const panelWrapper = document.querySelector('.history-panel-wrapper') as HTMLElement
    if (panelWrapper) {
      panelWrapper.style.display = ''
    }
    historyPanelVisibleBeforeDrag.value = false
  }
  
  // 恢复z-index（移除内联样式）
  const illustrationContainers = document.querySelectorAll('.illustration-container')
  illustrationContainers.forEach(container => {
    (container as HTMLElement).style.zIndex = ''
  })
  
  // 恢复数字人容器的z-index
  const digitalHumanContainers = document.querySelectorAll('.sdk-container')
  digitalHumanContainers.forEach(container => {
    (container as HTMLElement).style.zIndex = ''
  })
}
```

**关键点：**
1. **重置所有状态**：重置所有拖拽相关的 ref 状态
2. **恢复pointer-events**：恢复其他元素的 `pointer-events`
3. **恢复面板显示**：如果拖动前面板是显示的，恢复显示
4. **恢复z-index**：移除内联样式，恢复默认z-index

### 1.7 位置样式计算属性（partnerAvatarPositionStyle）

```javascript
const partnerAvatarPositionStyle = computed(() => {
  // 如果正在拖动，使用拖动时的临时位置
  const isDragging = isDraggingPartner.value || isDraggingPartnerDigitalHuman.value
  const positionX = isDragging && draggingPartnerPositionX.value !== null 
    ? draggingPartnerPositionX.value 
    : (currentPartnerRole.value?.positionX !== undefined ? currentPartnerRole.value.positionX : 50)
  const positionY = isDragging && draggingPartnerPositionY.value !== null 
    ? draggingPartnerPositionY.value 
    : (currentPartnerRole.value?.positionY !== undefined ? currentPartnerRole.value.positionY : 50)
  const scale = currentPartnerRole.value?.scale !== undefined ? currentPartnerRole.value.scale : 1.0
  
  const baseWidth = 600
  const baseHeight = 800
  const width = baseWidth * scale
  const height = baseHeight * scale
  
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})
```

**关键点：**
1. **拖拽时使用临时位置**：如果正在拖动，使用 `draggingPartnerPositionX` 和 `draggingPartnerPositionY`
2. **非拖拽时使用角色位置**：使用 `currentPartnerRole.value.positionX` 和 `positionY`
3. **动态计算大小**：根据 `scale` 计算实际宽度和高度
4. **使用百分比定位**：`left` 和 `top` 使用百分比，`transform: translate(-50%, -50%)` 居中

## 二、数字人当前实现（错误示例）

### 2.1 模板部分

**当前状态**：数字人容器不在模板中，而是通过渲染器动态创建

```vue
<!-- 数字人渲染器容器（由渲染器管理器管理） -->
<!-- 伙伴数字人和用户数字人通过渲染器管理器动态创建和管理 -->
```

**问题**：
1. ❌ 容器不在模板中，无法直接绑定 `@mousedown` 事件
2. ❌ 无法使用 Vue 的响应式样式绑定
3. ❌ 无法使用 Vue 的 class 绑定

### 2.2 拖拽事件绑定

**当前实现**：在 `DigitalHumanRenderer.setupDragEvents()` 中手动绑定

```typescript
private setupDragEvents(): void {
  const element = document.getElementById(this.containerId)
  if (!element) return

  if (this.dragCallbacks.onStart) {
    element.addEventListener('mousedown', (event) => {
      if (this.dragEnabled && this.dragCallbacks.onStart) {
        this.dragCallbacks.onStart(event as MouseEvent)
      }
    })
  }
}
```

**问题**：
1. ❌ 使用原生 `addEventListener`，不是 Vue 的事件系统
2. ❌ 事件绑定时机不确定（在 `nextTick` 中）
3. ❌ 没有处理全局鼠标事件监听

### 2.3 全局鼠标事件监听

**当前状态**：全局鼠标事件监听只检查 `.illustration-container`，没有检查数字人容器

```javascript
// 检测是否在立绘区域
const illustrationContainers = document.querySelectorAll('.illustration-container')
// ... 只处理立绘容器
```

**问题**：
1. ❌ 全局鼠标事件监听中没有检查数字人容器（`.sdk-container`）
2. ❌ 数字人无法通过全局鼠标事件触发拖拽

## 三、数字人应该如何实现（照抄立绘）

### 3.1 模板部分 - 必须照抄

**应该改为：**

```vue
<!-- 数字人 SDK 渲染容器（伙伴角色） -->
<div 
  v-if="currentPartnerRoleType === 'digital_human' && appState.avatar.showPartnerDigitalHuman"
  :id="partnerDigitalHumanContainerId"
  class="sdk-container"
  :class="{ dragging: isDraggingPartnerDigitalHuman }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartnerDigitalHuman($event)"
/>

<!-- 用户数字人 SDK 渲染容器 -->
<div 
  v-if="currentUserRoleType === 'digital_human' && appState.avatar.showUserDigitalHuman"
  :id="userDigitalHumanContainerId"
  class="sdk-container user-digital-human"
  :class="{ dragging: isDraggingUserDigitalHuman }"
  :style="userAvatarPositionStyle"
  @mousedown="startDragUserDigitalHuman($event)"
/>
```

**关键点：**
1. ✅ **容器直接在模板中定义**：和立绘一样，使用 `v-if` 条件渲染
2. ✅ **直接绑定事件**：`@mousedown="startDragPartnerDigitalHuman($event)"` 直接在模板中绑定
3. ✅ **使用相同的计算属性样式**：`:style="partnerAvatarPositionStyle"` 和立绘使用同一个计算属性
4. ✅ **拖拽状态类**：`:class="{ dragging: isDraggingPartnerDigitalHuman }"` 和立绘一样

### 3.2 全局鼠标事件监听 - 必须照抄

**应该改为：**

```javascript
// 在 globalMouseDown 函数中，添加数字人容器的检测
const digitalHumanContainers = document.querySelectorAll('.sdk-container') as NodeListOf<HTMLElement>
let clickedDigitalHuman: HTMLElement | null = null

for (const container of digitalHumanContainers) {
  const rect = container.getBoundingClientRect()
  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    clickedDigitalHuman = container
    break
  }
}

if (clickedDigitalHuman) {
  // 设置标志：正在处理数字人拖动
  isHandlingIllustrationDrag = true // 可以复用同一个标志，或者创建新标志
  
  // 隐藏面板（如果显示）
  // ... 和立绘一样的逻辑
  
  // 手动触发事件
  const syntheticEvent = new MouseEvent('mousedown', {
    bubbles: true,
    cancelable: true,
    clientX: x,
    clientY: y,
    button: event.button,
    buttons: event.buttons,
    view: window
  })
  
  clickedDigitalHuman.dispatchEvent(syntheticEvent)
  
  event.preventDefault()
  event.stopPropagation()
}
```

**关键点：**
1. ✅ **检测数字人容器**：使用 `document.querySelectorAll('.sdk-container')` 查找所有数字人容器
2. ✅ **手动触发事件**：使用 `dispatchEvent` 在数字人容器上触发 `mousedown` 事件
3. ✅ **和立绘使用相同的逻辑**：完全照抄立绘的处理方式

### 3.3 拖拽开始函数 - 必须照抄

**应该改为：**

```javascript
function startDragPartnerDigitalHuman(event: MouseEvent) {
  if (!currentPartnerRole.value || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events，避免拦截拖动事件
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingPartnerDigitalHuman.value = true
  dragType.value = 'partnerDigitalHuman'
  dragStartX.value = event.clientX
  dragStartY.value = event.clientY
  dragStartPositionX.value = currentPartnerRole.value.positionX !== undefined ? currentPartnerRole.value.positionX : 50
  dragStartPositionY.value = currentPartnerRole.value.positionY !== undefined ? currentPartnerRole.value.positionY : 50
  draggingPartnerPositionX.value = dragStartPositionX.value
  draggingPartnerPositionY.value = dragStartPositionY.value
  
  // 隐藏面板（如果显示）
  const panelWrapper = document.querySelector('.history-panel-wrapper') as HTMLElement
  if (panelWrapper && panelWrapper.style.display !== 'none') {
    panelWrapper.style.display = 'none'
    historyPanelVisibleBeforeDrag.value = true
  } else {
    historyPanelVisibleBeforeDrag.value = false
  }
  
  // 立即提升容器的z-index（通过内联样式）
  const container = event.currentTarget as HTMLElement
  if (container) {
    container.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDrag, { passive: false })
  document.addEventListener('mouseup', endDragPartnerDigitalHuman)
}
```

**关键点：**
1. ✅ **完全照抄立绘的逻辑**：除了 `dragType` 和状态变量名不同，其他完全一样
2. ✅ **使用 event.currentTarget**：直接获取容器元素
3. ✅ **使用相同的 handleDrag 函数**：`handleDrag` 函数已经支持 `partnerDigitalHuman` 类型

### 3.4 拖拽处理函数 - 已经照抄

**当前实现已经正确：**

```javascript
function handleDrag(event: MouseEvent) {
  // ...
  } else if (dragType.value === 'partnerDigitalHuman') {
    draggingPartnerPositionX.value = newPositionX
    draggingPartnerPositionY.value = newPositionY
  } else if (dragType.value === 'userDigitalHuman') {
    draggingUserPositionX.value = newPositionX
    draggingUserPositionY.value = newPositionY
  }
}
```

✅ **已经正确**：使用相同的 `handleDrag` 函数，只是 `dragType` 不同

### 3.5 拖拽结束函数 - 必须照抄

**应该改为：**

```javascript
async function endDragPartnerDigitalHuman(_event: MouseEvent) {
  if (!isDraggingPartnerDigitalHuman.value || !currentPartnerRole.value || !appState.llm.apiKey) {
    cleanupDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', endDragPartnerDigitalHuman)
  
  const finalPositionX = draggingPartnerPositionX.value ?? dragStartPositionX.value
  const finalPositionY = draggingPartnerPositionY.value ?? dragStartPositionY.value
  
  // 更新角色配置（和立绘完全一样）
  try {
    await updateRole(
      currentPartnerRole.value.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 重新加载角色信息
    await loadCurrentPartnerRole()
  } catch (error) {
    console.error('更新伙伴数字人位置失败:', error)
  }
  
  cleanupDrag()
}
```

**关键点：**
1. ✅ **完全照抄立绘的逻辑**：除了函数名，其他完全一样
2. ✅ **不需要通过渲染器更新**：直接更新数据库，然后重新加载角色

### 3.6 位置样式计算属性 - 已经照抄

**当前实现已经正确：**

```javascript
const partnerAvatarPositionStyle = computed(() => {
  const isDragging = isDraggingPartner.value || isDraggingPartnerDigitalHuman.value
  // ... 已经支持数字人
})
```

✅ **已经正确**：计算属性已经支持数字人拖拽状态

## 四、不能照抄的地方及原因

### 4.1 容器ID生成方式

**立绘**：不需要容器ID，直接在模板中定义

**数字人**：需要使用MD5哈希生成容器ID，因为：
- SDK需要容器ID来初始化
- 容器ID可能包含特殊字符（`:`、中文等），需要转换为有效的CSS选择器

**解决方案**：
- 在模板中使用计算属性生成容器ID：`:id="partnerDigitalHumanContainerId"`
- 计算属性中使用MD5哈希：`const partnerDigitalHumanContainerId = computed(() => 'digital-human-' + toMd5(\`partner:${currentPartnerRole.value?.user}\`))`

### 4.2 SDK初始化

**立绘**：不需要初始化，直接显示图片

**数字人**：需要调用SDK的 `connect()` 方法初始化

**解决方案**：
- 在 `watch` 中监听角色变化，当角色类型为 `digital_human` 时，调用SDK连接
- 连接成功后，SDK会自动在容器中渲染

### 4.3 显示/隐藏逻辑

**立绘**：通过 `v-if="showPartnerIllustration"` 控制显示/隐藏

**数字人**：需要同时控制：
1. 容器的显示/隐藏（通过 `v-if`）
2. SDK的连接状态（通过 `connect()` / `disconnect()`）

**解决方案**：
- 容器显示/隐藏：使用 `v-if="appState.avatar.showPartnerDigitalHuman"`
- SDK连接：在容器显示时连接，隐藏时不断开（保持连接状态，只隐藏容器）

## 五、修复方案总结

### 5.1 必须修改的地方

1. **模板部分**：
   - ✅ 在模板中直接定义数字人容器（照抄立绘）
   - ✅ 使用 `@mousedown` 直接绑定事件（照抄立绘）
   - ✅ 使用相同的计算属性样式（照抄立绘）
   - ✅ 使用相同的拖拽状态类（照抄立绘）

2. **全局鼠标事件监听**：
   - ✅ 添加数字人容器的检测（照抄立绘的检测逻辑）
   - ✅ 手动触发数字人容器的 `mousedown` 事件（照抄立绘）

3. **拖拽函数**：
   - ✅ `startDragPartnerDigitalHuman` 完全照抄 `startDragPartner`（除了变量名）
   - ✅ `endDragPartnerDigitalHuman` 完全照抄 `endDragPartner`（除了变量名）
   - ✅ `handleDrag` 已经支持，无需修改

4. **清理函数**：
   - ✅ `cleanupDrag` 已经支持数字人，无需修改

### 5.2 需要保留的特殊逻辑

1. **容器ID生成**：使用MD5哈希（因为SDK需要）
2. **SDK连接**：在角色变化时连接/断开SDK（数字人特有）
3. **容器创建时机**：SDK连接后，容器由SDK自动创建，但模板中需要预留容器元素

## 六、实施步骤

1. **修改模板**：在模板中添加数字人容器（照抄立绘的结构）
2. **修改全局鼠标事件**：添加数字人容器检测（照抄立绘的检测逻辑）
3. **修改拖拽函数**：完全照抄立绘的拖拽函数（除了变量名）
4. **移除渲染器中的拖拽逻辑**：因为拖拽完全由 `AvatarRender.vue` 处理
5. **保留SDK连接逻辑**：在渲染器中保留连接/断开逻辑，但移除拖拽相关代码

