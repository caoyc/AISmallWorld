# 角色切换时数字人和容器处理逻辑分析

## 一、当前处理流程

### 1.1 角色切换触发

**触发时机**：
1. API Key 登录后，加载当前角色
2. 用户切换当前角色（`handleSetCurrentRole` 或 `handleSetCurrentUserRole`）

**监听器**：
```typescript
// 监听伙伴角色变化
watch(currentPartnerRole, async (newRole) => {
  await setupPartnerDigitalHumanRenderer(newRole)
})

// 监听用户角色变化
watch(currentUserRole, async (newRole) => {
  await setupUserDigitalHumanRenderer(newRole)
})
```

### 1.2 销毁旧的渲染器

**代码位置**：`setupPartnerDigitalHumanRenderer` 和 `setupUserDigitalHumanRenderer`

```typescript
// 销毁旧的渲染器
if (partnerDigitalHumanRenderer.value) {
  const roleId = `partner:${currentPartnerRole.value?.user || ''}`
  rendererManager.destroyRenderer(roleId)
  partnerDigitalHumanRenderer.value = null
}
```

**处理步骤**：
1. 检查是否存在旧的渲染器实例
2. 调用 `rendererManager.destroyRenderer(roleId)`
3. 设置 `partnerDigitalHumanRenderer.value = null`

### 1.3 `destroyRenderer` 的处理

**代码位置**：`RendererManager.destroyRenderer()`

```typescript
destroyRenderer(roleId: string): void {
  const renderer = this.renderers.get(roleId)
  if (renderer) {
    renderer.destroy()
    this.renderers.delete(roleId)
  }
}
```

**处理步骤**：
1. 从 Map 中获取渲染器实例
2. 调用 `renderer.destroy()`
3. 从 Map 中删除

### 1.4 `DigitalHumanRenderer.destroy()` 的处理

**代码位置**：`DigitalHumanRenderer.destroy()`

```typescript
destroy(): void {
  // 断开连接
  if (this.instance) {
    this.disconnect()
  }

  // 容器由Vue管理，不需要手动移除

  this.container = null
  this.instance = null
  this.callbacks = null
}
```

**处理步骤**：
1. 如果已连接，调用 `disconnect()` 断开SDK连接
2. **容器不手动移除**（注释：容器由Vue管理，不需要手动移除）
3. 清空引用：`container = null`, `instance = null`, `callbacks = null`

### 1.5 容器的处理

**容器创建条件**（模板中）：
```vue
<div 
  v-show="currentPartnerRoleType === 'digital_human' && appState.avatar.showPartnerDigitalHuman && currentPartnerRole"
  :id="partnerDigitalHumanContainerId"
  class="sdk-container"
/>
```

**容器ID计算**：
```typescript
const partnerDigitalHumanContainerId = computed(() => {
  if (!currentPartnerRole.value) return ''
  const roleId = `partner:${currentPartnerRole.value.user}`
  return `digital-human-${toMd5(roleId)}`
})
```

**容器处理机制**：
1. **使用 `v-show`**：容器不会被销毁，只是通过 CSS `display: none` 隐藏
2. **容器ID动态变化**：当 `currentPartnerRole` 变化时，`partnerDigitalHumanContainerId` 也会变化
3. **自动隐藏**：当角色切换时，旧的容器会通过 `v-show` 条件自动隐藏（因为 `currentPartnerRole` 变了）

## 二、问题分析

### 2.1 容器残留问题

**场景1：从数字人角色A切换到数字人角色B**

**当前处理**：
1. 销毁角色A的渲染器（断开连接）
2. 创建角色B的渲染器
3. 容器A的DOM元素仍然存在（因为 `v-show` 只是隐藏，不销毁）
4. 容器B通过 `v-show` 显示（因为 `currentPartnerRole` 变了，容器ID也变了）

**问题**：
- ✅ 容器A会被隐藏（因为 `v-show` 条件不满足）
- ✅ 容器B会显示（因为 `v-show` 条件满足）
- ⚠️ 容器A的DOM元素仍然存在，占用内存

**影响**：
- 如果频繁切换角色，会有多个隐藏的容器DOM元素残留
- 虽然不影响功能，但会占用内存

### 2.2 连接状态残留问题

**场景2：从已连接的数字人角色切换到其他角色**

**当前处理**：
1. 销毁旧渲染器（断开连接）
2. `appState.avatar.connectedRoles` 中可能还保留着旧角色的连接状态
3. `appState.avatar.showPartnerDigitalHuman` 可能还是 `true`

**问题**：
- ⚠️ `appState.avatar.connectedRoles` 不会自动清理
- ⚠️ `appState.avatar.showPartnerDigitalHuman` 在非数字人角色时设置为 `false`，但在切换数字人角色时不会自动清理

**影响**：
- 连接状态可能不准确
- 可能导致UI显示错误

### 2.3 容器ID冲突问题

**场景3：从数字人角色A切换到数字人角色B，然后切换回角色A**

**当前处理**：
1. 切换回角色A时，容器ID会重新计算
2. 如果容器A的DOM元素还在，可能会找到旧的容器
3. 如果容器A的DOM元素已被清理，需要重新创建

**问题**：
- ✅ 容器ID通过MD5哈希生成，不会冲突
- ⚠️ 但旧的容器DOM元素可能还在，导致找到错误的容器

## 三、改进建议

### 3.1 清理连接状态

**在销毁渲染器时，同时清理连接状态**：

```typescript
// 销毁旧的渲染器
if (partnerDigitalHumanRenderer.value) {
  const roleId = `partner:${currentPartnerRole.value?.user || ''}`
  
  // 清理连接状态
  appState.avatar.connectedRoles.delete(roleId)
  appState.avatar.instances.delete(roleId)
  appState.avatar.showPartnerDigitalHuman = false
  
  // 销毁渲染器
  rendererManager.destroyRenderer(roleId)
  partnerDigitalHumanRenderer.value = null
}
```

### 3.2 清理旧的容器DOM元素

**在切换角色时，清理旧的容器DOM元素**：

```typescript
// 销毁旧的渲染器
if (partnerDigitalHumanRenderer.value) {
  const roleId = `partner:${currentPartnerRole.value?.user || ''}`
  const roleIdHash = toMd5(roleId)
  const oldContainerId = `digital-human-${roleIdHash}`
  
  // 清理旧的容器DOM元素
  const oldContainer = document.getElementById(oldContainerId)
  if (oldContainer) {
    oldContainer.remove()
  }
  
  // 清理连接状态
  appState.avatar.connectedRoles.delete(roleId)
  appState.avatar.instances.delete(roleId)
  appState.avatar.showPartnerDigitalHuman = false
  
  // 销毁渲染器
  rendererManager.destroyRenderer(roleId)
  partnerDigitalHumanRenderer.value = null
}
```

### 3.3 使用 `v-if` 替代 `v-show`（不推荐）

**如果使用 `v-if`**：
- ✅ 容器会在角色切换时自动销毁和重建
- ✅ 不会有DOM元素残留
- ❌ 但容器创建需要时间，连接时可能来不及

**结论**：不推荐，因为容器需要在连接时已存在。

## 四、当前实现的合理性

### 4.1 容器处理

**当前实现**：
- 使用 `v-show` 控制显示/隐藏
- 容器ID动态变化，旧的容器会自动隐藏
- 容器DOM元素不会自动清理

**合理性**：
- ✅ 功能正常：旧的容器会被隐藏，新的容器会显示
- ⚠️ 内存占用：旧的容器DOM元素会残留，但影响不大（因为 `v-show` 只是隐藏，不占用渲染资源）

### 4.2 渲染器处理

**当前实现**：
- 销毁旧渲染器时断开连接
- 清空渲染器引用

**合理性**：
- ✅ 功能正常：旧渲染器会被正确销毁
- ⚠️ 连接状态：`appState.avatar.connectedRoles` 不会自动清理

### 4.3 连接状态处理

**当前实现**：
- 连接时添加到 `appState.avatar.connectedRoles`
- 断开时从 `appState.avatar.connectedRoles` 删除
- 切换角色时不会自动清理

**合理性**：
- ⚠️ 可能存在问题：切换角色时，如果旧角色已连接，连接状态不会自动清理

## 五、总结

### 5.1 当前处理流程

1. **角色切换** → 触发 `watch` 监听器
2. **销毁旧渲染器** → 调用 `destroyRenderer()` → 断开连接 → 清空引用
3. **创建新渲染器** → 如果角色是数字人类型，创建新渲染器
4. **容器处理** → 通过 `v-show` 自动隐藏旧容器，显示新容器（如果已连接）

### 5.2 存在的问题

1. **连接状态残留**：切换角色时，`appState.avatar.connectedRoles` 不会自动清理
2. **容器DOM残留**：旧的容器DOM元素不会自动清理（但会被隐藏，影响不大）

### 5.3 建议的改进

1. **在销毁渲染器时，同时清理连接状态**
2. **可选：清理旧的容器DOM元素**（如果内存占用是问题）

