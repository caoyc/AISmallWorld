# 数字人拖拽实现方案分析

## 核心原则：数字人模块独立性

**重要原则**：数字人拖拽功能应该完全独立实现，不复用立绘的任何函数，以达到可插拔式的数字人模块的独立性。

**原因**：
1. **模块独立性**：数字人模块应该可以独立存在，不依赖立绘模块
2. **可维护性**：独立的实现更容易维护和调试
3. **可扩展性**：未来数字人可能有特殊的拖拽需求，独立实现更容易扩展
4. **代码清晰**：避免函数复用带来的逻辑混乱

**实现要求**：
- ❌ 不复用 `startDragPartner`、`startDragUser`、`handleDrag`、`endDragPartner`、`endDragUser`
- ❌ 不复用 `isDraggingPartner`、`isDraggingUser`、`dragType` 等状态变量
- ✅ 创建独立的数字人拖拽函数：`startDragPartnerDigitalHuman`、`startDragUserDigitalHuman`、`handleDigitalHumanDrag`、`endDragPartnerDigitalHuman`、`endDragUserDigitalHuman`
- ✅ 创建独立的数字人拖拽状态变量：`isDraggingPartnerDigitalHuman`、`isDraggingUserDigitalHuman`、`dragDigitalHumanType` 等

---

## 一、立绘拖拽实现方式总结（参考，不复用）

### 1.1 模板部分

```vue
<!-- 伙伴立绘图片显示 -->
<div 
  v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar"
  class="illustration-container"
  :class="{ dragging: isDraggingPartner }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartner($event)"
>
  <img :src="partnerIllustrationImageUrl" />
</div>
```

**关键点：**
1. ✅ 直接在模板中绑定 `@mousedown` 事件
2. ✅ 使用计算属性 `:style="partnerAvatarPositionStyle"` 动态计算位置
3. ✅ 使用拖拽状态类 `:class="{ dragging: isDraggingPartner }"`
4. ✅ 使用 `v-if` 控制容器创建/销毁

### 1.2 拖拽逻辑

**开始拖拽：**
- `startDragPartner(event)` - 设置拖拽状态，记录起始位置
- 添加全局 `mousemove` 和 `mouseup` 监听

**拖拽中：**
- `handleDrag(event)` - 计算新位置，更新 `draggingPartnerPositionX` 和 `draggingPartnerPositionY`
- `partnerAvatarPositionStyle` 计算属性自动响应，更新容器位置

**结束拖拽：**
- `endDragPartner(event)` - 保存位置到数据库，更新内存中的角色位置
- 清理拖拽状态

### 1.3 位置样式计算

```typescript
const partnerAvatarPositionStyle = computed(() => {
  // 如果正在拖动，使用拖动时的临时位置
  const positionX = isDraggingPartner.value && draggingPartnerPositionX.value !== null 
    ? draggingPartnerPositionX.value 
    : (appState.currentPartnerRole?.positionX !== undefined ? appState.currentPartnerRole.positionX : 90)
  const positionY = isDraggingPartner.value && draggingPartnerPositionY.value !== null 
    ? draggingPartnerPositionY.value 
    : (appState.currentPartnerRole?.positionY !== undefined ? appState.currentPartnerRole.positionY : 50)
  // ... 其他样式计算
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})
```

## 二、数字人容器当前状态

### 2.1 模板部分

```vue
<!-- 伙伴数字人容器 -->
<div
  v-show="appState.currentPartnerRole && appState.currentPartnerRole.showDigitalHuman && appState.currentPartnerRole.type === 'digital_human'"
  id="digital-human-partner"
  class="sdk-container"
  :style="partnerAvatarPositionStyle"
></div>
```

**当前状态：**
1. ✅ 使用 `v-show` 控制显示/隐藏（与立绘不同）
2. ✅ 已经有 `:style="partnerAvatarPositionStyle"` 计算属性（与立绘相同）
3. ❌ 没有 `@mousedown` 事件绑定
4. ❌ 没有拖拽状态类 `:class="{ dragging: ... }"`

### 2.2 位置样式计算

数字人容器已经使用了相同的 `partnerAvatarPositionStyle` 和 `userAvatarPositionStyle` 计算属性，这意味着：
- ✅ 位置计算逻辑已经统一
- ✅ 拖拽时的临时位置更新已经可以工作（如果添加拖拽逻辑）

## 三、数字人拖拽独立实现方案

### 3.1 设计原则

**核心原则**：
1. **完全照抄立绘的实现方式**：数字人拖拽应该完全照抄立绘的实现方式，包括全局鼠标事件监听
2. **独立实现，不复用函数**：虽然照抄实现方式，但要独立实现，不复用立绘的任何函数和状态变量
3. **全局鼠标事件监听是必需的**：因为其他容器（如面板）可能会遮罩数字人容器，导致直接绑定 `@mousedown` 无法触发，必须使用全局鼠标事件监听来解决遮罩问题
4. **数字人使用 v-show**：数字人容器使用 `v-show` 控制显示/隐藏（与立绘的 `v-if` 不同）
5. **拖拽只负责位置处理**：拖拽功能只负责更新位置，不涉及 SDK 连接/断开（连接/断开由其他逻辑处理）
6. **清理有连接断开处理**：数字人的清理逻辑需要断开 SDK 连接，但拖拽清理函数不负责这个（由其他清理逻辑处理）

**独立组件**：
1. **独立的拖拽函数**：
   - `startDragPartnerDigitalHuman(event: MouseEvent)`
   - `startDragUserDigitalHuman(event: MouseEvent)`
   - `handleDigitalHumanDrag(event: MouseEvent)`
   - `endDragPartnerDigitalHuman(event: MouseEvent)`
   - `endDragUserDigitalHuman(event: MouseEvent)`

2. **独立的状态变量**：
   - `isDraggingPartnerDigitalHuman: Ref<boolean>`
   - `isDraggingUserDigitalHuman: Ref<boolean>`
   - `dragDigitalHumanType: Ref<'partnerDigitalHuman' | 'userDigitalHuman' | null>`
   - `dragDigitalHumanStartX: Ref<number>`
   - `dragDigitalHumanStartY: Ref<number>`
   - `dragDigitalHumanStartPositionX: Ref<number>`
   - `dragDigitalHumanStartPositionY: Ref<number>`
   - `draggingPartnerDigitalHumanPositionX: Ref<number | null>`
   - `draggingPartnerDigitalHumanPositionY: Ref<number | null>`
   - `draggingUserDigitalHumanPositionX: Ref<number | null>`
   - `draggingUserDigitalHumanPositionY: Ref<number | null>`

3. **独立的位置样式计算**：
   - `partnerDigitalHumanPositionStyle: ComputedRef<Record<string, string>>`
   - `userDigitalHumanPositionStyle: ComputedRef<Record<string, string>>`

4. **独立的清理函数**：
   - `cleanupDigitalHumanDrag()`

### 3.2 模板实现

**重要**：数字人容器需要绑定 `@mousedown` 事件，但主要通过全局鼠标事件监听来触发（照抄立绘方式）。

```vue
<!-- 伙伴数字人容器 -->
<div
  v-show="appState.currentPartnerRole && appState.currentPartnerRole.showDigitalHuman && appState.currentPartnerRole.type === 'digital_human'"
  id="digital-human-partner"
  class="sdk-container"
  :class="{ dragging: isDraggingPartnerDigitalHuman }"
  :style="partnerDigitalHumanPositionStyle"
  @mousedown="startDragPartnerDigitalHuman($event)"
></div>

<!-- 用户数字人容器 -->
<div
  v-show="appState.currentUserRole && appState.currentUserRole.showDigitalHuman && appState.currentUserRole.type === 'digital_human'"
  id="digital-human-user"
  class="sdk-container user-digital-human"
  :class="{ dragging: isDraggingUserDigitalHuman }"
  :style="userDigitalHumanPositionStyle"
  @mousedown="startDragUserDigitalHuman($event)"
></div>
```

**注意**：
- ✅ **绑定 `@mousedown` 事件**：因为全局鼠标事件监听会手动触发 `mousedown` 事件，需要容器上有事件处理器
- ✅ **使用全局鼠标事件监听**：在 `globalMouseDown` 中检测点击位置，手动触发拖拽事件（解决遮罩问题）
- ✅ **照抄立绘方式**：立绘也是绑定 `@mousedown` 事件，通过全局监听手动触发

### 3.3 位置样式计算（独立实现）

```typescript
// 伙伴数字人位置和大小样式（独立计算属性）
const partnerDigitalHumanPositionStyle = computed(() => {
  // 如果正在拖动，使用拖动时的临时位置
  const positionX = isDraggingPartnerDigitalHuman.value && draggingPartnerDigitalHumanPositionX.value !== null 
    ? draggingPartnerDigitalHumanPositionX.value 
    : (appState.currentPartnerRole?.positionX !== undefined ? appState.currentPartnerRole.positionX : 90)
  const positionY = isDraggingPartnerDigitalHuman.value && draggingPartnerDigitalHumanPositionY.value !== null 
    ? draggingPartnerDigitalHumanPositionY.value 
    : (appState.currentPartnerRole?.positionY !== undefined ? appState.currentPartnerRole.positionY : 50)
  const scale = appState.currentPartnerRole?.scale !== undefined ? appState.currentPartnerRole.scale : 1.0
  
  const baseWidth = 512
  const baseHeight = 768
  const width = baseWidth * scale
  const height = baseHeight * scale
  
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})

// 用户数字人位置和大小样式（独立计算属性）
const userDigitalHumanPositionStyle = computed(() => {
  // 如果正在拖动，使用拖动时的临时位置
  const positionX = isDraggingUserDigitalHuman.value && draggingUserDigitalHumanPositionX.value !== null 
    ? draggingUserDigitalHumanPositionX.value 
    : (appState.currentUserRole?.positionX !== undefined ? appState.currentUserRole.positionX : 10)
  const positionY = isDraggingUserDigitalHuman.value && draggingUserDigitalHumanPositionY.value !== null 
    ? draggingUserDigitalHumanPositionY.value 
    : (appState.currentUserRole?.positionY !== undefined ? appState.currentUserRole.positionY : 50)
  const scale = appState.currentUserRole?.scale !== undefined ? appState.currentUserRole.scale : 1.0
  
  const baseWidth = 512
  const baseHeight = 768
  const width = baseWidth * scale
  const height = baseHeight * scale
  
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})
```

### 3.4 拖拽函数实现（独立实现）

```typescript
// 开始拖动伙伴数字人
function startDragPartnerDigitalHuman(event: MouseEvent) {
  if (!appState.currentPartnerRole || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events，避免拦截拖动事件
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingPartnerDigitalHuman.value = true
  dragDigitalHumanType.value = 'partnerDigitalHuman'
  dragDigitalHumanStartX.value = event.clientX
  dragDigitalHumanStartY.value = event.clientY
  dragDigitalHumanStartPositionX.value = appState.currentPartnerRole.positionX !== undefined ? appState.currentPartnerRole.positionX : 90
  dragDigitalHumanStartPositionY.value = appState.currentPartnerRole.positionY !== undefined ? appState.currentPartnerRole.positionY : 50
  draggingPartnerDigitalHumanPositionX.value = dragDigitalHumanStartPositionX.value
  draggingPartnerDigitalHumanPositionY.value = dragDigitalHumanStartPositionY.value
  
  // 立即提升数字人容器的z-index（通过内联样式）
  const digitalHumanContainer = event.currentTarget as HTMLElement
  if (digitalHumanContainer) {
    digitalHumanContainer.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDigitalHumanDrag, { passive: false })
  document.addEventListener('mouseup', endDragPartnerDigitalHuman)
}

// 开始拖动用户数字人
function startDragUserDigitalHuman(event: MouseEvent) {
  if (!appState.currentUserRole || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events，避免拦截拖动事件
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingUserDigitalHuman.value = true
  dragDigitalHumanType.value = 'userDigitalHuman'
  dragDigitalHumanStartX.value = event.clientX
  dragDigitalHumanStartY.value = event.clientY
  dragDigitalHumanStartPositionX.value = appState.currentUserRole.positionX !== undefined ? appState.currentUserRole.positionX : 10
  dragDigitalHumanStartPositionY.value = appState.currentUserRole.positionY !== undefined ? appState.currentUserRole.positionY : 50
  draggingUserDigitalHumanPositionX.value = dragDigitalHumanStartPositionX.value
  draggingUserDigitalHumanPositionY.value = dragDigitalHumanStartPositionY.value
  
  // 立即提升数字人容器的z-index（通过内联样式）
  const digitalHumanContainer = event.currentTarget as HTMLElement
  if (digitalHumanContainer) {
    digitalHumanContainer.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDigitalHumanDrag, { passive: false })
  document.addEventListener('mouseup', endDragUserDigitalHuman)
}

// 处理数字人拖动
function handleDigitalHumanDrag(event: MouseEvent) {
  if (!dragDigitalHumanType.value) return
  
  const deltaX = event.clientX - dragDigitalHumanStartX.value
  const deltaY = event.clientY - dragDigitalHumanStartY.value
  
  // 计算新位置（百分比）
  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight
  const newPositionX = Math.max(0, Math.min(100, dragDigitalHumanStartPositionX.value + (deltaX / containerWidth) * 100))
  const newPositionY = Math.max(0, Math.min(100, dragDigitalHumanStartPositionY.value + (deltaY / containerHeight) * 100))
  
  if (dragDigitalHumanType.value === 'partnerDigitalHuman') {
    draggingPartnerDigitalHumanPositionX.value = newPositionX
    draggingPartnerDigitalHumanPositionY.value = newPositionY
  } else if (dragDigitalHumanType.value === 'userDigitalHuman') {
    draggingUserDigitalHumanPositionX.value = newPositionX
    draggingUserDigitalHumanPositionY.value = newPositionY
  }
}

// 结束拖动伙伴数字人
async function endDragPartnerDigitalHuman(_event: MouseEvent) {
  if (!isDraggingPartnerDigitalHuman.value || !appState.currentPartnerRole || !appState.llm.apiKey) {
    cleanupDigitalHumanDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDigitalHumanDrag)
  document.removeEventListener('mouseup', endDragPartnerDigitalHuman)
  
  const finalPositionX = draggingPartnerDigitalHumanPositionX.value ?? dragDigitalHumanStartPositionX.value
  const finalPositionY = draggingPartnerDigitalHumanPositionY.value ?? dragDigitalHumanStartPositionY.value
  
  // 更新角色配置（只更新位置，不涉及连接/断开）
  try {
    await updateRole(
      appState.currentPartnerRole.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 直接更新内存中的角色位置，避免重新加载
    if (appState.currentPartnerRole) {
      appState.currentPartnerRole.positionX = finalPositionX
      appState.currentPartnerRole.positionY = finalPositionY
    }
  } catch (error) {
    console.error('更新伙伴数字人位置失败:', error)
  }
  
  cleanupDigitalHumanDrag()
  
  // 注意：拖拽结束只负责更新位置，不负责 SDK 连接/断开
  // 数字人容器使用 v-show，拖拽时容器始终存在，SDK 连接状态不受影响
}

// 结束拖动用户数字人
async function endDragUserDigitalHuman(_event: MouseEvent) {
  if (!isDraggingUserDigitalHuman.value || !appState.currentUserRole || !appState.llm.apiKey) {
    cleanupDigitalHumanDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDigitalHumanDrag)
  document.removeEventListener('mouseup', endDragUserDigitalHuman)
  
  const finalPositionX = draggingUserDigitalHumanPositionX.value ?? dragDigitalHumanStartPositionX.value
  const finalPositionY = draggingUserDigitalHumanPositionY.value ?? dragDigitalHumanStartPositionY.value
  
  // 更新用户角色配置（只更新位置，不涉及连接/断开）
  try {
    await updateUserRole(
      appState.currentUserRole.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 直接更新内存中的角色位置，避免重新加载
    if (appState.currentUserRole) {
      appState.currentUserRole.positionX = finalPositionX
      appState.currentUserRole.positionY = finalPositionY
    }
  } catch (error) {
    console.error('更新用户数字人位置失败:', error)
  }
  
  cleanupDigitalHumanDrag()
  
  // 注意：拖拽结束只负责更新位置，不负责 SDK 连接/断开
  // 数字人容器使用 v-show，拖拽时容器始终存在，SDK 连接状态不受影响
}

// 清理数字人拖动状态
function cleanupDigitalHumanDrag() {
  isDraggingPartnerDigitalHuman.value = false
  isDraggingUserDigitalHuman.value = false
  dragDigitalHumanType.value = null
  draggingPartnerDigitalHumanPositionX.value = null
  draggingPartnerDigitalHumanPositionY.value = null
  draggingUserDigitalHumanPositionX.value = null
  draggingUserDigitalHumanPositionY.value = null
  
  // 恢复config-panel和chat-tab的pointer-events
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = ''
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = ''
  }
  
  // 恢复数字人容器的z-index
  const digitalHumanContainers = document.querySelectorAll('.sdk-container')
  digitalHumanContainers.forEach(container => {
    (container as HTMLElement).style.zIndex = ''
  })
  
  // 注意：拖拽清理函数只负责清理拖拽状态，不负责 SDK 连接/断开
  // SDK 连接/断开由其他逻辑处理（如角色切换、连接/断开按钮等）
}
```

### 3.5 全局鼠标事件监听（必需，照抄立绘方式）

**重要**：全局鼠标事件监听是**必需的**，不是可选的。原因：
1. **解决遮罩问题**：其他容器（如面板）可能会遮罩数字人容器，导致直接绑定 `@mousedown` 无法触发
2. **照抄立绘方式**：立绘使用全局鼠标事件监听来解决同样的问题，数字人应该照抄

在 `globalMouseDown` 中添加数字人容器检测（独立实现，不依赖立绘逻辑）：

```typescript
onMounted(() => {
  // 标志：是否正在处理立绘拖动
  let isHandlingIllustrationDrag = false
  // 标志：是否正在处理数字人拖动（独立标志，不依赖立绘）
  let isHandlingDigitalHumanDrag = false
  
  // 添加全局mousedown监听，检测鼠标位置
  const globalMouseDown = (event: MouseEvent) => {
    // 如果正在处理立绘拖动，跳过
    if (isHandlingIllustrationDrag) {
      return
    }
    
    // 如果正在处理数字人拖动，跳过
    if (isHandlingDigitalHumanDrag) {
      return
    }
    
    // 如果事件目标已经是立绘容器或其子元素，说明事件已经到达立绘，不处理
    const target = event.target as HTMLElement
    if (target && (target.classList.contains('illustration-container') || target.closest('.illustration-container'))) {
      return
    }
    
    // 如果事件目标已经是数字人容器或其子元素，说明事件已经到达数字人，不处理
    if (target && (target.classList.contains('sdk-container') || target.closest('.sdk-container'))) {
      return
    }
    
    const x = event.clientX
    const y = event.clientY
    
    // 检测是否在面板区域（优先级高过立绘和数字人）
    const panelWrapper = document.querySelector('.history-panel-wrapper') as HTMLElement
    if (panelWrapper && panelWrapper.style.display !== 'none') {
      const panelRect = panelWrapper.getBoundingClientRect()
      if (x >= panelRect.left && x <= panelRect.right && y >= panelRect.top && y <= panelRect.bottom) {
        return // 在面板区域，正常处理，不拦截
      }
    }
    
    // 检测是否在立绘区域（优先级高于数字人）
    const illustrationContainers = document.querySelectorAll('.illustration-container') as NodeListOf<HTMLElement>
    let clickedIllustration: HTMLElement | null = null
    
    for (const container of illustrationContainers) {
      const rect = container.getBoundingClientRect()
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        clickedIllustration = container
        break
      }
    }
    
    // 如果点击在立绘区域，处理立绘拖拽（立绘逻辑，不修改）
    if (clickedIllustration) {
      // ... 立绘拖拽逻辑 ...
      return
    }
    
    // 检测是否在数字人区域（独立处理，不依赖立绘逻辑）
    const digitalHumanContainers = document.querySelectorAll('.sdk-container') as NodeListOf<HTMLElement>
    let clickedDigitalHuman: HTMLElement | null = null
    
    for (const container of digitalHumanContainers) {
      const rect = container.getBoundingClientRect()
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        clickedDigitalHuman = container
        break
      }
    }
    
    // 如果点击在数字人区域
    if (clickedDigitalHuman) {
      // 设置标志：正在处理数字人拖动
      isHandlingDigitalHumanDrag = true
      
      // 隐藏面板（如果显示）
      const panelVisible = panelWrapper && panelWrapper.style.display !== 'none'
      if (panelVisible) {
        panelWrapper.style.display = 'none'
        historyPanelVisibleBeforeDrag.value = true
      } else {
        historyPanelVisibleBeforeDrag.value = false
      }
      
      // 判断是伙伴还是用户数字人
      const isPartner = clickedDigitalHuman.id === 'digital-human-partner'
      const isUser = clickedDigitalHuman.id === 'digital-human-user'
      
      if (isPartner) {
        // 触发伙伴数字人拖拽（手动触发事件，让Vue的事件系统处理）
        const syntheticEvent = new MouseEvent('mousedown', {
          bubbles: true,
          cancelable: true,
          clientX: x,
          clientY: y,
          button: event.button,
          buttons: event.buttons,
          view: window
        })
        clickedDigitalHuman.dispatchEvent(syntheticEvent)
      } else if (isUser) {
        // 触发用户数字人拖拽（手动触发事件，让Vue的事件系统处理）
        const syntheticEvent = new MouseEvent('mousedown', {
          bubbles: true,
          cancelable: true,
          clientX: x,
          clientY: y,
          button: event.button,
          buttons: event.buttons,
          view: window
        })
        clickedDigitalHuman.dispatchEvent(syntheticEvent)
      }
      
      event.preventDefault()
      event.stopPropagation()
    }
  }
  document.addEventListener('mousedown', globalMouseDown, true) // 使用捕获阶段，优先处理
  
  // 添加全局mouseup监听，清除标志
  const globalMouseUp = () => {
    // 鼠标释放时清除标志
    isHandlingIllustrationDrag = false
    isHandlingDigitalHumanDrag = false // 独立标志，独立清除
  }
  document.addEventListener('mouseup', globalMouseUp, true)
})
```

**关键点**（照抄立绘方式）：
1. ✅ **使用捕获阶段**：`addEventListener('mousedown', globalMouseDown, true)` 在捕获阶段处理，优先于其他事件
2. ✅ **检测数字人容器**：使用 `document.querySelectorAll('.sdk-container')` 查找所有数字人容器
3. ✅ **手动触发事件**：使用 `dispatchEvent` 在数字人容器上触发 `mousedown` 事件，让Vue的事件系统处理
4. ✅ **标志管理**：使用 `isHandlingDigitalHumanDrag` 标志防止重复处理（独立标志，不依赖立绘）
5. ✅ **面板处理**：隐藏面板（如果显示），记录状态以便拖拽结束后恢复
6. ✅ **优先级处理**：面板 > 立绘 > 数字人（照抄立绘的优先级逻辑）

**注意**：
- 虽然照抄立绘的实现方式，但使用独立的标志和逻辑，不依赖立绘的代码
- 数字人容器需要绑定 `@mousedown` 事件（因为全局监听会手动触发事件）

## 四、潜在问题和解决方案

### 4.1 数字人拖拽的特殊性

**与立绘的区别**：
1. **容器渲染方式**：数字人使用 `v-show`，容器始终存在（即使隐藏）；立绘使用 `v-if`，容器会被销毁
2. **SDK 连接状态**：数字人有 SDK 连接状态，拖拽时不影响连接状态
3. **拖拽职责**：拖拽只负责位置处理，不涉及连接/断开

**注意事项**：
- ✅ 拖拽时，数字人容器始终存在（因为使用 `v-show`）
- ✅ 拖拽时，SDK 连接状态不受影响（拖拽只更新位置）
- ✅ 拖拽清理函数不负责 SDK 连接/断开（由其他逻辑处理）

### 4.2 SDK 事件拦截问题

**问题**：SDK 渲染的内容（WebGL）可能会拦截鼠标事件，导致容器的 `@mousedown` 无法触发。

**解决方案**：
1. **方案1（已采用）**：使用全局鼠标事件监听，检测点击位置并手动触发事件（照抄立绘方式）
2. **方案2**：在 SDK 容器上添加一个透明的覆盖层，用于接收鼠标事件
3. **方案3**：配置 SDK 不拦截鼠标事件（如果 SDK 支持）

### 4.3 拖拽时 SDK 交互冲突

**问题**：拖拽时，SDK 可能仍然响应鼠标事件（如旋转、缩放等）。

**解决方案**：
1. 在拖拽开始时，禁用 SDK 的交互（如果 SDK 支持）
2. 在拖拽时，设置容器的 `pointer-events: none` 给 SDK 内容，但保持容器本身可拖拽
3. 使用全局事件监听，在拖拽时阻止事件传播到 SDK

**注意**：拖拽只负责位置处理，不负责 SDK 交互的禁用/启用（如果需要，由其他逻辑处理）

### 4.4 容器 z-index 管理

**问题**：拖拽时需要提升容器的 z-index，但 SDK 内容可能有自己的 z-index 管理。

**解决方案**：
- 在 `startDragPartnerDigitalHuman` 和 `startDragUserDigitalHuman` 中，设置容器的 `zIndex = '1000'`
- 在 `cleanupDigitalHumanDrag` 中，恢复容器的 z-index

### 4.5 事件监听器清理

**问题**：需要在组件卸载时清理数字人拖拽的事件监听器。

**解决方案**：
在 `onUnmounted` 中添加清理逻辑：
```typescript
onUnmounted(() => {
  // ... 其他清理逻辑 ...
  
  // 清理数字人拖拽事件监听器
  document.removeEventListener('mousemove', handleDigitalHumanDrag)
  document.removeEventListener('mouseup', endDragPartnerDigitalHuman)
  document.removeEventListener('mouseup', endDragUserDigitalHuman)
  
  // 注意：数字人的 SDK 连接/断开由其他清理逻辑处理（如 rendererManager.destroyRenderer）
  // 拖拽清理函数不负责 SDK 连接/断开
})
```

### 4.6 数字人清理与拖拽清理的区别

**数字人清理（其他逻辑处理）**：
- 断开 SDK 连接
- 销毁渲染器实例
- 清理角色对象上的连接状态（`isConnected`、`digitalHumanInstance` 等）

**拖拽清理（`cleanupDigitalHumanDrag`）**：
- 只清理拖拽状态（`isDraggingPartnerDigitalHuman`、`draggingPartnerDigitalHumanPositionX` 等）
- 恢复容器的 z-index
- 恢复其他元素的 pointer-events
- **不负责** SDK 连接/断开

## 五、实现步骤

### 5.1 第一步：创建独立的状态变量

1. 创建所有数字人拖拽相关的状态变量（见 3.1 节）
2. 确保变量命名清晰，不与立绘的变量混淆

### 5.2 第二步：创建独立的位置样式计算属性

1. 创建 `partnerDigitalHumanPositionStyle` 和 `userDigitalHumanPositionStyle`
2. 确保逻辑与立绘的位置样式计算一致，但完全独立

### 5.3 第三步：实现独立的拖拽函数

1. 实现 `startDragPartnerDigitalHuman` 和 `startDragUserDigitalHuman`
2. 实现 `handleDigitalHumanDrag`
3. 实现 `endDragPartnerDigitalHuman` 和 `endDragUserDigitalHuman`
4. 实现 `cleanupDigitalHumanDrag`

### 5.4 第四步：更新模板

1. **不绑定 `@mousedown` 事件**（照抄立绘方式，使用全局监听）
2. 添加拖拽状态类 `:class="{ dragging: isDraggingPartnerDigitalHuman }"`
3. 更新 `:style` 绑定为独立的位置样式计算属性

### 5.5 第五步：实现全局鼠标事件监听（必需）

1. 在 `globalMouseDown` 中添加数字人容器检测逻辑（独立实现，不依赖立绘）
2. 添加数字人容器点击检测和事件转发逻辑
3. 添加独立的 `isHandlingDigitalHumanDrag` 标志管理
4. 添加全局 `mouseup` 监听，清除标志

### 5.6 第六步：完善清理逻辑

1. 在 `onUnmounted` 中添加事件监听器清理
2. 确保所有状态变量都被正确清理

## 六、结论

**✅ 数字人拖拽应该完全独立实现**，不复用立绘的任何函数和状态变量。

**实现要点**：
1. ✅ **完全照抄立绘的实现方式**：包括全局鼠标事件监听
2. ✅ **独立实现，不复用函数**：创建独立的拖拽函数和状态变量
3. ✅ **创建独立的位置样式计算属性**：`partnerDigitalHumanPositionStyle` 和 `userDigitalHumanPositionStyle`
4. ✅ **全局鼠标事件监听是必需的**：解决其他容器遮罩问题，不是可选的
5. ✅ **数字人使用 v-show**：容器始终存在，拖拽时不影响容器状态
6. ✅ **拖拽只负责位置处理**：不涉及 SDK 连接/断开，连接/断开由其他逻辑处理
7. ✅ **清理逻辑分离**：拖拽清理函数只清理拖拽状态，不负责 SDK 连接/断开
8. ✅ **确保数字人模块的完全独立性**：不依赖立绘模块

**优势**：
- ✅ **模块独立性**：数字人模块可以独立存在，不依赖立绘模块
- ✅ **可维护性**：独立的实现更容易维护和调试
- ✅ **可扩展性**：未来数字人可能有特殊的拖拽需求，独立实现更容易扩展
- ✅ **代码清晰**：避免函数复用带来的逻辑混乱

**实现顺序**：
1. 创建独立的状态变量和计算属性
2. 实现独立的拖拽函数
3. 更新模板，绑定事件和样式
4. 测试直接绑定事件是否工作
5. 如果 SDK 拦截事件，扩展全局鼠标事件监听
6. 完善清理逻辑

