# 数字人与立绘差异原因分析

## 一、模板定义方式

### 立绘的实现方式

```vue
<div 
  v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar"
  class="illustration-container"
  :class="{ dragging: isDraggingPartner }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartner($event)"
>
  <img :src="partnerIllustrationImageUrl" />
</div>
```

**特点：**
- 容器直接在模板中定义
- 使用 `v-if` 条件渲染
- 直接绑定 `@mousedown` 事件
- 使用计算属性 `partnerAvatarPositionStyle` 动态计算样式
- **不需要容器ID**（Vue自动管理，通过class选择器查找）

### 数字人当前实现方式

**当前状态：** 容器不在模板中，由渲染器动态创建

```typescript
// 在 DigitalHumanRenderer.render() 中
const digitalHumanContainer = document.createElement('div')
digitalHumanContainer.id = this.containerId
container.appendChild(digitalHumanContainer)
```

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**
1. **立绘的模板定义方式是最佳实践**：
   - Vue的响应式系统可以自动管理DOM
   - 事件绑定通过Vue的事件系统，更可靠
   - 样式绑定通过计算属性，自动响应状态变化
   - 拖拽状态类可以自动应用/移除
   - **不需要容器ID**：立绘不需要SDK初始化，不需要通过ID查找容器

2. **数字人当前方式的问题**：
   - 容器不在模板中，Vue无法管理
   - 事件绑定需要手动 `addEventListener`，容易出错
   - 样式更新需要手动操作DOM，不响应式
   - 拖拽状态类需要手动添加/移除

3. **为什么之前会不同？**
   - **错误理解**：认为SDK需要动态创建容器，所以不能在模板中定义
   - **实际情况**：SDK只需要一个容器ID，容器可以在模板中定义，SDK会自动找到并使用

**结论：数字人应该完全照抄立绘的模板定义方式，容器直接在模板中定义。**

---

## 二、容器ID生成方式

### 立绘的实现方式

**立绘不需要容器ID**：
- 立绘容器没有 `id` 属性
- 通过 `class="illustration-container"` 选择器查找
- Vue自动管理DOM，不需要手动查找
- **立绘不需要SDK初始化**，所以不需要通过ID查找容器

### 数字人当前实现方式

```typescript
// 在 DigitalHumanRenderer 构造函数中
const roleIdHash = toMd5(config.roleId)
this.containerId = `digital-human-${roleIdHash}`
```

**特点：**
- 必须使用MD5哈希生成容器ID
- 因为 `roleId` 可能包含 `:` 和中文字符（如 `partner:次庄雅`）
- 这些字符在CSS选择器中无效，会导致SDK初始化失败

### 为什么必须不同？

**答案：必须不同，这是SDK的技术限制导致的。**

**原因分析：**

1. **立绘为什么不需要容器ID**：
   - 立绘是静态图片，直接通过 `<img>` 标签显示
   - 不需要调用任何SDK或外部库
   - 不需要通过ID查找容器
   - Vue的响应式系统自动管理DOM，通过class选择器就足够了

2. **数字人为什么必须使用容器ID**：
   - **SDK的技术要求**：
     - SDK的构造函数接受 `containerId: '#容器ID'` 这样的字符串参数
     - SDK内部使用 `document.getElementById(容器ID)` 或 `document.querySelector('#容器ID')` 查找容器
     - SDK不支持传入DOM元素，只支持ID字符串
   - **CSS选择器对ID的严格限制**：
     - 不能包含 `:`（会被解析为伪类选择器，如 `:hover`）
     - 不能包含中文字符（某些浏览器不支持，且不符合CSS规范）
     - 不能包含空格
     - 必须以字母开头（或下划线、连字符）

3. **roleId的格式问题**：
   - 伙伴角色：`partner:次庄雅`（包含 `:` 和中文）
   - 用户角色：`user:3`（包含 `:`）
   - 这些格式在业务逻辑中是必需的（用于区分角色类型和标识）
   - 如果直接使用 `roleId` 作为容器ID，会导致：
     - `partner:次庄雅` → `#partner:次庄雅` → CSS选择器解析失败
     - `user:3` → `#user:3` → CSS选择器可能被解析为 `#user` 和伪类 `:3`（无效）

4. **为什么不能采用立绘的方案（不使用ID）**：
   - **SDK的限制**：SDK的构造函数只接受 `containerId: '#容器ID'` 字符串格式，不支持：
     - 传入DOM元素对象
     - 使用class选择器（如 `containerId: '.sdk-container'`）
     - 使用其他选择器格式
   - **SDK源码示例**（从使用方式推断）：
     ```javascript
     // SDK内部可能是这样实现的：
     const container = document.getElementById(containerId.replace('#', ''))
     // 或
     const container = document.querySelector(containerId)
     ```
   - 如果SDK支持传入DOM元素，代码应该是这样：
     ```javascript
     // 理想情况（但SDK不支持）：
     const avatar = new XmovAvatar({
       container: document.querySelector('.sdk-container'), // 直接传入DOM元素
       // ...
     })
     ```
   - 但实际SDK只支持：
     ```javascript
     // 实际情况（SDK只支持ID字符串）：
     const avatar = new XmovAvatar({
       containerId: '#digital-human-abc123', // 必须是ID字符串
       // ...
     })
     ```

5. **MD5哈希的必要性**：
   - 将 `partner:次庄雅` 转换为 `abc123def456...`（32位十六进制）
   - 十六进制字符串完全符合CSS选择器ID规范
   - 保持唯一性（MD5碰撞概率极低）
   - 确保SDK能够正确找到容器

**结论：**
- **立绘不需要容器ID**：因为立绘不需要SDK初始化，不需要通过ID查找容器
- **数字人必须使用MD5哈希生成容器ID**：这是SDK的技术限制导致的，SDK只支持ID字符串，不支持DOM元素或class选择器，且 `roleId` 包含特殊字符，必须转换为有效的CSS选择器ID

---

## 三、全局鼠标事件监听

### 立绘的实现方式

```javascript
// 在 globalMouseDown 中
const illustrationContainers = document.querySelectorAll('.illustration-container')
let clickedIllustration: HTMLElement | null = null

for (const container of illustrationContainers) {
  const rect = container.getBoundingClientRect()
  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    clickedIllustration = container
    break
  }
}

if (clickedIllustration) {
  // 手动触发 mousedown 事件
  clickedIllustration.dispatchEvent(syntheticEvent)
}
```

**特点：**
- 使用 `document.querySelectorAll('.illustration-container')` 查找所有立绘容器
- 通过 `getBoundingClientRect()` 检测点击位置
- 手动触发 `mousedown` 事件

### 数字人当前实现方式

**当前状态：** 全局鼠标事件监听中没有检查数字人容器

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘的全局鼠标事件监听是必需的**：
   - 当面板显示时，立绘容器在面板后面（z-index较低）
   - 直接点击立绘容器会被面板拦截
   - 全局鼠标事件在捕获阶段处理，可以检测点击位置
   - 如果点击在立绘区域，手动触发立绘容器的 `mousedown` 事件

2. **数字人面临同样的问题**：
   - 数字人容器也在面板后面（z-index较低）
   - 直接点击数字人容器也会被面板拦截
   - 需要同样的全局鼠标事件监听机制

3. **实现方式应该完全一样**：
   - 使用 `document.querySelectorAll('.sdk-container')` 查找所有数字人容器
   - 通过 `getBoundingClientRect()` 检测点击位置
   - 手动触发 `mousedown` 事件

**结论：数字人应该完全照抄立绘的全局鼠标事件监听逻辑，只是选择器从 `.illustration-container` 改为 `.sdk-container`。**

---

## 四、拖拽开始函数

### 立绘的实现方式

```javascript
function startDragPartner(event: MouseEvent) {
  if (!currentPartnerRole.value || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingPartner.value = true
  dragType.value = 'partner'
  dragStartX.value = event.clientX
  dragStartY.value = event.clientY
  dragStartPositionX.value = currentPartnerRole.value.positionX !== undefined ? currentPartnerRole.value.positionX : 50
  dragStartPositionY.value = currentPartnerRole.value.positionY !== undefined ? currentPartnerRole.value.positionY : 50
  draggingPartnerPositionX.value = dragStartPositionX.value
  draggingPartnerPositionY.value = dragStartPositionY.value
  
  // 立即提升立绘的z-index
  const illustrationContainer = event.currentTarget as HTMLElement
  if (illustrationContainer) {
    illustrationContainer.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDrag, { passive: false })
  document.addEventListener('mouseup', endDragPartner)
}
```

**特点：**
- 直接使用 `event.currentTarget` 获取容器元素
- 设置拖拽状态变量
- 禁用其他元素的 `pointer-events`
- 提升容器的 `z-index`
- 添加全局 `mousemove` 和 `mouseup` 监听

### 数字人当前实现方式

```javascript
function startDragPartnerDigitalHuman(event: MouseEvent) {
  // ... 类似的逻辑，但通过渲染器查找容器
  const roleId = `partner:${currentPartnerRole.value.user}`
  const roleIdHash = toMd5(roleId)
  const containerId = `digital-human-${roleIdHash}`
  const container = document.getElementById(containerId)
  // ...
}
```

**特点：**
- 通过 `getElementById` 查找容器（因为容器ID是MD5哈希）
- 其他逻辑类似

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘使用 `event.currentTarget` 的原因**：
   - `event.currentTarget` 是Vue事件系统提供的，指向绑定事件的元素
   - 这是Vue的标准做法，最可靠
   - 不需要手动查找元素

2. **数字人当前使用 `getElementById` 的原因**：
   - 因为容器不在模板中，需要通过ID查找
   - 这是**错误实现方式导致的**，不是必须的

3. **正确的实现方式**：
   - 如果容器在模板中定义，并且绑定了 `@mousedown` 事件
   - 那么 `event.currentTarget` 就是数字人容器
   - 完全不需要 `getElementById`

**结论：数字人应该完全照抄立绘的拖拽开始函数，直接使用 `event.currentTarget`，不需要 `getElementById`。**

---

## 五、拖拽处理函数

### 立绘的实现方式

```javascript
function handleDrag(event: MouseEvent) {
  if (!dragType.value) return
  
  const deltaX = event.clientX - dragStartX.value
  const deltaY = event.clientY - dragStartY.value
  
  const containerWidth = window.innerWidth
  const containerHeight = window.innerHeight
  const newPositionX = Math.max(0, Math.min(100, dragStartPositionX.value + (deltaX / containerWidth) * 100))
  const newPositionY = Math.max(0, Math.min(100, dragStartPositionY.value + (deltaY / containerHeight) * 100))
  
  if (dragType.value === 'partner') {
    draggingPartnerPositionX.value = newPositionX
    draggingPartnerPositionY.value = newPositionY
  }
  // ...
}
```

**特点：**
- 统一的拖拽处理函数
- 根据 `dragType` 判断是哪种类型的拖拽
- 更新对应的临时位置变量

### 数字人当前实现方式

**当前状态：** 已经使用相同的 `handleDrag` 函数，通过 `dragType === 'partnerDigitalHuman'` 判断

### 为什么必须不同？

**答案：不应该不同！已经正确！**

**原因分析：**

1. **立绘的 `handleDrag` 函数设计得很好**：
   - 统一的处理逻辑，避免代码重复
   - 通过 `dragType` 区分不同类型
   - 所有拖拽类型共享相同的计算逻辑

2. **数字人已经正确使用**：
   - 使用相同的 `handleDrag` 函数
   - 只是 `dragType` 不同（`partnerDigitalHuman` / `userDigitalHuman`）
   - 这是正确的实现方式

**结论：数字人已经正确使用相同的 `handleDrag` 函数，无需修改。**

---

## 六、拖拽结束函数

### 立绘的实现方式

```javascript
async function endDragPartner(_event: MouseEvent) {
  if (!isDraggingPartner.value || !currentPartnerRole.value || !appState.llm.apiKey) {
    cleanupDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', endDragPartner)
  
  const finalPositionX = draggingPartnerPositionX.value ?? dragStartPositionX.value
  const finalPositionY = draggingPartnerPositionY.value ?? dragStartPositionY.value
  
  // 更新角色配置
  try {
    await updateRole(
      currentPartnerRole.value.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 重新加载角色信息
    await loadCurrentPartnerRole()
  } catch (error) {
    console.error('更新伙伴角色位置失败:', error)
  }
  
  cleanupDrag()
}
```

**特点：**
- 移除事件监听
- 调用API更新数据库
- 重新加载角色信息
- 清理拖拽状态

### 数字人当前实现方式

```javascript
async function endDragPartnerDigitalHuman(_event: MouseEvent) {
  // ...
  // 通过渲染器更新位置
  if (partnerDigitalHumanRenderer.value) {
    try {
      await partnerDigitalHumanRenderer.value.updateConfig({
        positionX: finalPositionX,
        positionY: finalPositionY
      })
    } catch (error) {
      console.error('更新数字人渲染器配置失败:', error)
    }
  }
  
  // 更新角色配置
  await updateRole(...)
  await loadCurrentPartnerRole()
  // ...
}
```

**特点：**
- 先通过渲染器更新配置
- 再更新数据库
- 最后重新加载角色

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘的实现方式是正确的**：
   - 直接更新数据库
   - 重新加载角色信息
   - 不需要中间步骤

2. **数字人当前方式的问题**：
   - 通过渲染器更新配置是多余的
   - 因为重新加载角色后，渲染器会重新创建，配置会重新应用
   - 增加了不必要的复杂性

3. **正确的实现方式**：
   - 完全照抄立绘的逻辑
   - 直接更新数据库
   - 重新加载角色信息
   - 渲染器会在角色重新加载后自动更新（通过 `watch` 监听）

**结论：数字人应该完全照抄立绘的拖拽结束函数，不需要通过渲染器更新配置。**

---

## 七、位置样式计算属性

### 立绘的实现方式

```javascript
const partnerAvatarPositionStyle = computed(() => {
  const isDragging = isDraggingPartner.value || isDraggingPartnerDigitalHuman.value
  const positionX = isDragging && draggingPartnerPositionX.value !== null 
    ? draggingPartnerPositionX.value 
    : (currentPartnerRole.value?.positionX !== undefined ? currentPartnerRole.value.positionX : 50)
  const positionY = isDragging && draggingPartnerPositionY.value !== null 
    ? draggingPartnerPositionY.value 
    : (currentPartnerRole.value?.positionY !== undefined ? currentPartnerRole.value.positionY : 50)
  const scale = currentPartnerRole.value?.scale !== undefined ? currentPartnerRole.value.scale : 1.0
  
  const baseWidth = 600
  const baseHeight = 800
  const width = baseWidth * scale
  const height = baseHeight * scale
  
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})
```

**特点：**
- 已经支持数字人拖拽状态（`isDraggingPartnerDigitalHuman`）
- 拖拽时使用临时位置
- 非拖拽时使用角色位置
- 动态计算大小

### 数字人当前实现方式

**当前状态：** 数字人使用渲染器的 `updateContainerStyle()` 方法手动更新样式

```typescript
private updateContainerStyle(): void {
  const element = document.getElementById(this.containerId)
  if (!element) return

  const { positionX, positionY, scale } = this.config
  const baseWidth = 600
  const baseHeight = 800
  const width = baseWidth * scale
  const height = baseHeight * scale

  element.style.left = `${positionX}%`
  element.style.top = `${positionY}%`
  element.style.transform = 'translate(-50%, -50%)'
  element.style.width = `${width}px`
  element.style.height = `${height}px`
}
```

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘的计算属性方式是最佳实践**：
   - Vue的响应式系统自动管理
   - 拖拽时自动更新（因为 `draggingPartnerPositionX` 是响应式的）
   - 不需要手动操作DOM

2. **数字人当前方式的问题**：
   - 手动操作DOM，不响应式
   - 拖拽时不会自动更新（需要手动调用 `updateContainerStyle()`）
   - 增加了复杂性

3. **正确的实现方式**：
   - 如果容器在模板中定义，使用 `:style="partnerAvatarPositionStyle"`
   - Vue会自动响应状态变化
   - 完全不需要手动更新样式

**结论：数字人应该完全照抄立绘的位置样式计算属性，在模板中使用 `:style` 绑定，不需要手动更新样式。**

---

## 八、容器创建时机

### 立绘的实现方式

**立绘容器在模板中定义，Vue自动创建和管理**

### 数字人当前实现方式

**在 `DigitalHumanRenderer.render()` 中动态创建容器**

```typescript
async render(container: HTMLElement): Promise<void> {
  let digitalHumanContainer = document.getElementById(this.containerId)
  if (!digitalHumanContainer) {
    digitalHumanContainer = document.createElement('div')
    digitalHumanContainer.id = this.containerId
    container.appendChild(digitalHumanContainer)
  }
}
```

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘的容器创建方式**：
   - 容器在模板中定义
   - Vue在渲染时自动创建
   - 不需要手动创建

2. **数字人当前方式的问题**：
   - 手动创建容器，不在Vue的管理范围内
   - 导致无法使用Vue的响应式系统
   - 导致无法使用Vue的事件系统

3. **SDK的实际需求**：
   - SDK只需要一个容器ID
   - SDK使用 `document.getElementById(容器ID)` 查找容器
   - **SDK不关心容器是如何创建的**，只要容器存在且有正确的ID即可

4. **正确的实现方式**：
   - 容器在模板中定义（照抄立绘）
   - 使用计算属性生成容器ID（MD5哈希）
   - SDK连接时，容器已经存在，SDK可以直接使用

**结论：数字人应该完全照抄立绘的容器创建方式，容器在模板中定义，不需要在渲染器中创建。**

---

## 九、SDK连接逻辑

### 立绘的实现方式

**立绘不需要连接，直接显示图片**

### 数字人当前实现方式

**需要调用SDK的 `connect()` 方法连接**

```typescript
async connect(): Promise<void> {
  this.instance = await this.service.connect(
    { appId, appSecret },
    this.callbacks,
    this.containerId
  )
}
```

### 为什么必须不同？

**答案：必须不同，这是数字人特有的技术细节。**

**原因分析：**

1. **立绘不需要连接**：
   - 立绘是静态图片，直接显示即可
   - 不需要网络连接
   - 不需要初始化

2. **数字人必须连接**：
   - 数字人是实时渲染的3D模型
   - 需要连接SDK服务器获取数据
   - 需要初始化WebGL渲染引擎
   - 这是数字人特有的技术需求

3. **连接时机**：
   - 当角色类型为 `digital_human` 时
   - 当容器显示时（`appState.avatar.showPartnerDigitalHuman === true`）
   - 在 `watch` 中监听状态变化，自动连接/断开

**结论：数字人必须保留SDK连接逻辑，这是数字人特有的技术细节，无法避免。**

---

## 十、显示/隐藏逻辑

### 立绘的实现方式

```vue
<div v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar">
```

**特点：**
- 通过 `v-if` 控制显示/隐藏
- 条件：显示标志 + 角色类型 + 有头像

### 数字人当前实现方式

**通过渲染器的 `show()` / `hide()` 方法控制容器显示/隐藏**

```typescript
show(): void {
  this.state.visible = true
  this.onVisibilityChanged(true)
}

hide(): void {
  this.state.visible = false
  this.onVisibilityChanged(false)
}
```

### 为什么必须不同？

**答案：不应该不同！应该完全一样！**

**原因分析：**

1. **立绘的显示/隐藏方式**：
   - 通过 `v-if` 控制，Vue自动管理DOM
   - 简单、可靠、响应式

2. **数字人当前方式的问题**：
   - 使用渲染器的方法控制，需要手动管理
   - 容器始终存在，只是通过CSS控制显示/隐藏
   - 增加了复杂性

3. **正确的实现方式**：
   - 完全照抄立绘的方式
   - 使用 `v-if="appState.avatar.showPartnerDigitalHuman && currentPartnerRoleType === 'digital_human'"`
   - Vue自动管理DOM的创建和销毁

4. **SDK连接状态的处理**：
   - 容器显示时连接SDK（在 `watch` 中监听）
   - 容器隐藏时不断开SDK（保持连接状态，只隐藏容器）
   - 这是数字人特有的逻辑，但容器的显示/隐藏应该和立绘一样

**结论：数字人应该完全照抄立绘的显示/隐藏方式，使用 `v-if` 控制，SDK连接逻辑在 `watch` 中处理。**

---

## 十一、总结

### 必须不同的地方（技术限制）

1. **容器ID生成方式**：
   - **原因**：SDK使用CSS选择器查找容器，`roleId` 包含特殊字符（`:`、中文），必须使用MD5哈希转换为有效的CSS选择器ID
   - **实现**：使用计算属性 `partnerDigitalHumanContainerId = computed(() => 'digital-human-' + toMd5(roleId))`

2. **SDK连接逻辑**：
   - **原因**：数字人需要连接SDK服务器和初始化WebGL渲染引擎，这是数字人特有的技术需求
   - **实现**：在 `watch` 中监听角色变化和显示状态，自动连接/断开SDK

### 不应该不同的地方（应该照抄）

1. **模板定义方式**：容器应该在模板中定义，使用 `v-if` 条件渲染
2. **事件绑定方式**：使用 `@mousedown` 直接绑定，不要手动 `addEventListener`
3. **全局鼠标事件监听**：完全照抄立绘的逻辑，只是选择器改为 `.sdk-container`
4. **拖拽开始函数**：完全照抄，直接使用 `event.currentTarget`
5. **拖拽处理函数**：已经正确，使用相同的 `handleDrag` 函数
6. **拖拽结束函数**：完全照抄，直接更新数据库，不需要通过渲染器
7. **位置样式计算属性**：完全照抄，在模板中使用 `:style` 绑定
8. **容器创建时机**：容器在模板中定义，不需要在渲染器中创建
9. **显示/隐藏逻辑**：使用 `v-if` 控制，不需要渲染器的方法

### 核心原则

**除了容器ID生成（MD5哈希）和SDK连接逻辑（数字人特有）这两个技术细节外，其他所有实现都应该完全照抄立绘。**

