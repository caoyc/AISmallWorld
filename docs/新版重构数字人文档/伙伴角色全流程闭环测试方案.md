# 伙伴角色全流程闭环测试方案

## 一、测试目标

验证伙伴角色管理的完整业务流程，确保：
1. ✅ 数据库状态与内存状态一致
2. ✅ 角色属性（连接状态、显示状态、实例）正确维护
3. ✅ 界面显示与底层状态一致
4. ✅ 角色之间互不干扰
5. ✅ 状态恢复机制正常工作
6. ✅ 用户角色和伙伴角色互不干扰

## 二、测试环境准备

### 2.1 测试账号
- **API Key:** `cursor_for_testing`
- **Base URL:** `127.0.0.1:9000/v1`
- **模型名称:** `deepseek-chat`

### 2.2 测试数据
- **数字人角色1（晚晴）：**
  - User: `wanqing`
  - App ID: `e2eeb70a3baf467991139a50c3d67679`
  - App Secret: `6e2bae9ea9e74ac3b5851b56d9813ec5`
- **数字人角色2（小雅）：**
  - User: `xiaoya`
  - App ID: `e023696282e24e559f2c4061f1f3d668`
  - App Secret: `1638285d3f284a48b5459cc192902ec0`

### 2.3 测试前检查清单
- [ ] 清除浏览器缓存和本地存储
- [ ] 确保数据库中没有测试数据（或已知测试数据状态）
- [ ] 打开浏览器开发者工具（Console、Network）
- [ ] 准备记录测试结果的表格

## 三、测试流程

### 阶段一：登录与初始化

#### 测试步骤 1.1：打开应用并登录

**操作：**
1. 打开应用
2. 点击菜单中的"API Key 登录"
3. 输入 API Key: `cursor_for_testing`
4. 点击"登录"

**预期结果：**
- ✅ 显示"登录成功"提示
- ✅ 控制台显示"用户角色列表加载成功: X 个角色"
- ✅ 控制台显示"伙伴角色列表加载成功: 0 个角色"
- ✅ `globalApiKey.value` = `cursor_for_testing`
- ✅ `appState.llm.apiKey` = `cursor_for_testing`
- ✅ `roles.value` = `[]`（空数组）
- ✅ `appState.currentPartnerRole` = `null`
- ✅ `appState.llm.user` = `''`（空字符串）
- ✅ `rendererManager` 中没有伙伴角色渲染器

**验证方法：**
- 检查控制台日志
- 检查界面显示
- 检查 Vue DevTools 中的状态

---

#### 测试步骤 1.2：验证初始状态

**操作：**
1. 打开 Vue DevTools
2. 检查 `appState` 状态
3. 检查 `roles` 状态

**预期结果：**
- ✅ `appState.currentPartnerRole` = `null`
- ✅ `appState.llm.user` = `''`
- ✅ `roles.value.length` = `0`
- ✅ 没有数字人容器显示
- ✅ 没有连接状态显示

**验证方法：**
- Vue DevTools 检查
- 界面检查

---

### 阶段二：创建角色

#### 测试步骤 2.1：创建第一个数字人角色（自动设为当前）

**操作：**
1. 打开"伙伴角色管理"面板
2. 点击"新建角色"
3. 填写：
   - 角色名称：`晚晴`
   - User: `wanqing`
   - 角色类型：`数字人`
   - 应用 APP ID：`e2eeb70a3baf467991139a50c3d67679`
   - 应用 APP Secret：`6e2bae9ea9e74ac3b5851b56d9813ec5`
   - Base URL：`127.0.0.1:9000/v1`
   - 模型名称：`deepseek-chat`
4. 点击"保存"

**预期结果：**
- ✅ 显示"角色已创建"提示
- ✅ 角色出现在列表中
- ✅ 角色显示"当前"标签
- ✅ "设为当前"按钮被禁用
- ✅ 状态显示"○ 未连接"
- ✅ "连接"按钮可用
- ✅ `roles.value.length` = `1`
- ✅ `roles.value[0].user` = `wanqing`
- ✅ `roles.value[0].isConnecting` = `false`
- ✅ `roles.value[0].isConnected` = `false`
- ✅ `roles.value[0].showDigitalHuman` = `false`
- ✅ `roles.value[0].digitalHumanInstance` = `null`
- ✅ `appState.currentPartnerRole` = `roles.value[0]`（引用相同对象）
- ✅ `appState.llm.user` = `wanqing`
- ✅ `appState.llm.apiKey` = `cursor_for_testing`
- ✅ `appState.llm.baseURL` = `127.0.0.1:9000/v1`
- ✅ `appState.llm.model` = `deepseek-chat`
- ✅ **位置初始值：** `roles.value[0].positionX` = `90`（伙伴角色默认90%）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查
- 数据库查询（可选）

---

#### 测试步骤 2.2：创建第二个数字人角色（不自动设为当前）

**操作：**
1. 点击"新建角色"
2. 填写：
   - 角色名称：`小雅`
   - User: `xiaoya`
   - 角色类型：`数字人`
   - 应用 APP ID：`e023696282e24e559f2c4061f1f3d668`
   - 应用 APP Secret：`1638285d3f284a48b5459cc192902ec0`
   - Base URL：`127.0.0.1:9000/v1`
   - 模型名称：`deepseek-chat`
3. 点击"保存"

**预期结果：**
- ✅ 显示"角色已创建"提示
- ✅ 列表中有两个角色
- ✅ "晚晴"仍然是"当前"（显示"当前"标签）
- ✅ "小雅"不显示"当前"标签
- ✅ "小雅"的"设为当前"按钮可用
- ✅ "小雅"的"连接"按钮被禁用（非当前角色）
- ✅ `roles.value.length` = `2`
- ✅ `roles.value[1].user` = `xiaoya`
- ✅ `appState.currentPartnerRole` = `roles.value[0]`（仍然是"晚晴"）
- ✅ `appState.llm.user` = `wanqing`（仍然是"晚晴"的user）
- ✅ **位置初始值：** `roles.value[1].positionX` = `90`（伙伴角色默认90%）

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

#### 测试步骤 2.3：创建立绘角色

**操作：**
1. 点击"新建角色"
2. 填写：
   - 角色名称：`测试立绘`
   - User: `test_illustration`
   - 角色类型：`立绘`
   - Base URL：`127.0.0.1:9000/v1`
   - 模型名称：`deepseek-chat`
3. 点击"保存"

**预期结果：**
- ✅ 显示"角色已创建"提示
- ✅ 列表中有三个角色
- ✅ "测试立绘"不显示连接状态（立绘角色没有连接功能）
- ✅ "测试立绘"不显示"连接"/"断开"按钮
- ✅ `roles.value.length` = `3`
- ✅ `roles.value[2].type` = `illustration`
- ✅ `roles.value[2].user` = `test_illustration`
- ✅ **位置初始值：** `roles.value[2].positionX` = `90`（伙伴角色默认90%）

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

### 阶段三：连接与断开

#### 测试步骤 3.1：连接第一个数字人角色

**操作：**
1. 确保"晚晴"是当前角色
2. 点击"晚晴"的"连接"按钮
3. 等待连接完成（观察进度和状态变化）

**预期结果：**
- ✅ 按钮文本变为"连接中..."
- ✅ "连接"按钮被禁用
- ✅ 控制台显示 SDK 初始化进度
- ✅ 控制台显示"SDK连接成功"
- ✅ 显示"连接成功"提示
- ✅ 状态显示"● 已连接"（**关键：界面状态立即更新**）
- ✅ "断开"按钮可用
- ✅ `roles.value[0].isConnecting` = `false`（连接完成后）
- ✅ `roles.value[0].isConnected` = `true`
- ✅ `roles.value[0].showDigitalHuman` = `true`
- ✅ `roles.value[0].digitalHumanInstance` ≠ `null`
- ✅ `rendererManager.getRenderer('partner:wanqing')` 存在
- ✅ 数字人容器显示在页面上（位置在90%）
- ✅ 数字人开始渲染

**验证方法：**
- 界面检查（**重点：状态显示是否正确**）
- Vue DevTools 检查
- 控制台日志检查
- 检查数字人容器是否显示

---

#### 测试步骤 3.2：验证连接状态保持

**操作：**
1. 关闭伙伴角色管理面板
2. 等待 2 秒
3. 重新打开伙伴角色管理面板

**预期结果：**
- ✅ "晚晴"的状态仍然显示"● 已连接"
- ✅ "断开"按钮仍然可用
- ✅ `roles.value[0].isConnected` = `true`（**关键：状态保持**）
- ✅ `roles.value[0].showDigitalHuman` = `true`
- ✅ `roles.value[0].digitalHumanInstance` ≠ `null`
- ✅ `rendererManager.getRenderer('partner:wanqing')` 仍然存在
- ✅ 数字人容器仍然显示
- ✅ **不显示"连接成功"提示**（因为状态已保持，没有重新连接）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查（不应该有重新连接日志）

---

#### 测试步骤 3.3：断开连接

**操作：**
1. 点击"晚晴"的"断开"按钮

**预期结果：**
- ✅ 显示"已断开连接"提示
- ✅ 状态显示"○ 未连接"
- ✅ "连接"按钮可用
- ✅ "断开"按钮被禁用
- ✅ `roles.value[0].isConnected` = `false`
- ✅ `roles.value[0].showDigitalHuman` = `false`
- ✅ `roles.value[0].digitalHumanInstance` = `null`
- ✅ `rendererManager.getRenderer('partner:wanqing')` = `null`（或不存在）
- ✅ 数字人容器隐藏

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

### 阶段四：切换当前角色

#### 测试步骤 4.1：切换当前角色（从已连接角色切换到未连接角色）

**操作：**
1. 先连接"晚晴"（如果未连接）
2. 点击"小雅"的"设为当前"按钮

**预期结果：**
- ✅ 显示"已切换到伙伴角色"提示
- ✅ "晚晴"不再显示"当前"标签
- ✅ "晚晴"的"设为当前"按钮可用
- ✅ "晚晴"的"连接"按钮被禁用（非当前角色）
- ✅ "小雅"显示"当前"标签
- ✅ "小雅"的"设为当前"按钮被禁用
- ✅ "小雅"的"连接"按钮可用
- ✅ `roles.value[0].user` = `wanqing`（保持不变）
- ✅ `roles.value[1].user` = `xiaoya`（保持不变）
- ✅ `appState.currentPartnerRole` = `roles.value[1]`（"小雅"）
- ✅ `appState.llm.user` = `xiaoya`（**关键：更新为"小雅"的user**）
- ✅ `appState.llm.apiKey` = `cursor_for_testing`（保持不变）
- ✅ `appState.llm.baseURL` = `127.0.0.1:9000/v1`（保持不变）
- ✅ `appState.llm.model` = `deepseek-chat`（保持不变）
- ✅ **"晚晴"的连接状态保持不变**（`isConnected` = `true`，但 `showDigitalHuman` = `false`）
- ✅ 控制台显示 SDK 断开消息（如果"晚晴"之前已连接）
- ✅ "晚晴"的数字人容器隐藏
- ✅ `rendererManager.getRenderer('partner:wanqing')` 仍然存在（但容器隐藏）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 4.2：连接新当前角色

**操作：**
1. 点击"小雅"的"连接"按钮
2. 等待连接完成

**预期结果：**
- ✅ 连接成功
- ✅ "小雅"的状态显示"● 已连接"
- ✅ "小雅"的数字人容器显示（位置在90%）
- ✅ `roles.value[1].isConnected` = `true`
- ✅ `roles.value[1].showDigitalHuman` = `true`
- ✅ `roles.value[1].digitalHumanInstance` ≠ `null`
- ✅ `rendererManager.getRenderer('partner:xiaoya')` 存在
- ✅ **"晚晴"的状态不受影响**（仍然是 `isConnected` = `true`，但 `showDigitalHuman` = `false`）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 4.3：切换回第一个角色

**操作：**
1. 点击"晚晴"的"设为当前"按钮

**预期结果：**
- ✅ "晚晴"显示"当前"标签
- ✅ "小雅"不再显示"当前"标签
- ✅ "晚晴"的"连接"按钮可用（但显示"已连接"，因为之前已连接）
- ✅ "晚晴"的状态显示"● 已连接"（**关键：状态恢复**）
- ✅ "晚晴"的数字人容器显示（**关键：显示状态恢复**）
- ✅ `roles.value[0].isConnected` = `true`
- ✅ `roles.value[0].showDigitalHuman` = `true`
- ✅ `roles.value[0].digitalHumanInstance` ≠ `null`
- ✅ `appState.llm.user` = `wanqing`（**关键：更新为"晚晴"的user**）
- ✅ **"小雅"的状态不受影响**（仍然是 `isConnected` = `true`，但 `showDigitalHuman` = `false`）

**验证方法：**
- 界面检查（**重点：状态是否正确恢复**）
- Vue DevTools 检查
- 控制台日志检查

---

### 阶段五：编辑角色

#### 测试步骤 5.1：编辑数字人角色（不改变类型）

**操作：**
1. 确保"晚晴"是当前角色且已连接
2. 点击"晚晴"的"编辑"按钮
3. 修改角色名称：`晚晴（已编辑）`
4. 点击"保存"

**预期结果：**
- ✅ 显示"角色已更新"提示
- ✅ 列表中角色名称更新为"晚晴（已编辑）"
- ✅ **连接状态保持不变**（仍然是"● 已连接"）
- ✅ `roles.value[0].name` = `晚晴（已编辑）`
- ✅ `roles.value[0].isConnected` = `true`（**关键：状态保持**）
- ✅ `roles.value[0].showDigitalHuman` = `true`
- ✅ `roles.value[0].digitalHumanInstance` ≠ `null`
- ✅ 数字人容器仍然显示
- ✅ **不重新加载角色列表**（直接更新属性）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查（不应该有重新连接日志）

---

#### 测试步骤 5.2：编辑数字人角色（改变类型为立绘）

**操作：**
1. 确保"小雅"是当前角色且已连接
2. 点击"小雅"的"编辑"按钮
3. 修改角色类型：`立绘`
4. 点击"保存"

**预期结果：**
- ✅ 显示"角色已更新"提示
- ✅ 列表中角色类型更新为"立绘"
- ✅ **连接状态被清理**（不再显示"● 已连接"）
- ✅ **不再显示"连接"/"断开"按钮**
- ✅ `roles.value[1].type` = `illustration`
- ✅ `roles.value[1].isConnected` = `false`（**关键：状态被清理**）
- ✅ `roles.value[1].showDigitalHuman` = `false`
- ✅ `roles.value[1].digitalHumanInstance` = `null`
- ✅ `rendererManager.getRenderer('partner:xiaoya')` = `null`（渲染器被销毁）
- ✅ 数字人容器隐藏
- ✅ **不重新加载角色列表**（直接更新属性）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查（应该有断开连接日志）

---

#### 测试步骤 5.3：编辑立绘角色（改变类型为数字人）

**操作：**
1. 点击"测试立绘"的"编辑"按钮
2. 修改角色类型：`数字人`
3. 填写数字人配置：
   - 应用 APP ID：`e2eeb70a3baf467991139a50c3d67679`
   - 应用 APP Secret：`6e2bae9ea9e74ac3b5851b56d9813ec5`
4. 点击"保存"

**预期结果：**
- ✅ 显示"角色已更新"提示
- ✅ 列表中角色类型更新为"数字人"
- ✅ 显示"连接"/"断开"按钮
- ✅ 状态显示"○ 未连接"
- ✅ `roles.value[2].type` = `digital_human`
- ✅ `roles.value[2].isConnected` = `false`
- ✅ `roles.value[2].showDigitalHuman` = `false`
- ✅ `roles.value[2].digitalHumanInstance` = `null`

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

### 阶段六：删除角色

#### 测试步骤 6.1：删除非当前角色

**操作：**
1. 确保"小雅"不是当前角色
2. 点击"小雅"的"删除"按钮
3. 确认删除

**预期结果：**
- ✅ 显示"角色已删除"提示
- ✅ "小雅"从列表中消失
- ✅ `roles.value.length` = `2`（减少1个）
- ✅ 列表中不再包含"小雅"
- ✅ **其他角色不受影响**
- ✅ **如果"小雅"之前已连接，渲染器被销毁**

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 6.2：删除当前角色（已连接）

**操作：**
1. 确保"晚晴"是当前角色且已连接
2. 点击"晚晴"的"删除"按钮
3. 确认删除

**预期结果：**
- ✅ 显示"角色已删除"提示
- ✅ "晚晴"从列表中消失
- ✅ `roles.value.length` = `1`（减少1个）
- ✅ `appState.currentPartnerRole` = `null`（**关键：当前角色被清空**）
- ✅ `appState.llm.user` = `''`（**关键：user被清空**）
- ✅ `appState.llm.apiKey` = `cursor_for_testing`（保持不变）
- ✅ `appState.llm.baseURL` = `127.0.0.1:9000/v1`（保持不变）
- ✅ `appState.llm.model` = `deepseek-chat`（保持不变）
- ✅ **连接状态被清理**（数字人容器隐藏）
- ✅ `rendererManager.getRenderer('partner:wanqing')` = `null`（渲染器被销毁）
- ✅ 控制台显示断开连接日志

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 6.3：删除最后一个角色

**操作：**
1. 删除剩余的角色（"测试立绘"）

**预期结果：**
- ✅ 显示"角色已删除"提示
- ✅ 列表为空
- ✅ `roles.value.length` = `0`
- ✅ `appState.currentPartnerRole` = `null`
- ✅ `appState.llm.user` = `''`
- ✅ 显示"暂无角色"提示

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

### 阶段七：退出登录

#### 测试步骤 7.1：退出登录

**操作：**
1. 先创建并连接一个数字人角色（用于测试退出时的清理）
2. 点击"退出登录"

**预期结果：**
- ✅ 显示"已退出登录"提示
- ✅ `globalApiKey.value` = `''`（清空）
- ✅ `appState.llm.apiKey` = `''`（清空）
- ✅ `appState.llm.user` = `''`（清空）
- ✅ `roles.value` = `[]`（清空）
- ✅ `appState.currentPartnerRole` = `null`
- ✅ **所有数字人渲染器被销毁**
- ✅ `rendererManager` 中没有伙伴角色渲染器
- ✅ 数字人容器隐藏
- ✅ 界面回到登录前状态

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 7.2：重新登录并验证状态恢复

**操作：**
1. 重新登录（使用相同的 API Key）
2. 检查之前创建的角色是否恢复

**预期结果：**
- ✅ 显示"登录成功"提示
- ✅ 控制台显示"伙伴角色列表加载成功: X 个角色"（X > 0）
- ✅ 之前创建的角色出现在列表中
- ✅ **连接状态不恢复**（所有角色显示"○ 未连接"）
- ✅ `roles.value` 包含之前创建的角色
- ✅ 如果之前有当前角色，`appState.currentPartnerRole` 指向该角色
- ✅ 如果之前有当前角色，`appState.llm.user` = 该角色的 `user`
- ✅ `roles.value[].isConnected` = `false`（所有角色）
- ✅ `roles.value[].showDigitalHuman` = `false`（所有角色）
- ✅ `roles.value[].digitalHumanInstance` = `null`（所有角色）
- ✅ `rendererManager` 中没有伙伴角色渲染器（**关键：不恢复连接状态**）

**验证方法：**
- 界面检查
- Vue DevTools 检查
- 控制台日志检查

---

### 阶段八：用户角色与伙伴角色独立性验证

#### 测试步骤 8.1：同时连接用户角色和伙伴角色

**操作：**
1. 确保已登录
2. 创建并连接一个用户角色数字人（位置在10%）
3. 创建并连接一个伙伴角色数字人（位置在90%）

**预期结果：**
- ✅ 用户角色数字人显示在10%位置
- ✅ 伙伴角色数字人显示在90%位置
- ✅ 两个数字人同时显示，互不干扰
- ✅ 用户角色的连接状态独立（`appState.currentUserRole.isConnected` = `true`）
- ✅ 伙伴角色的连接状态独立（`appState.currentPartnerRole.isConnected` = `true`）
- ✅ `rendererManager.getRenderer('user:${userRoleId}')` 存在
- ✅ `rendererManager.getRenderer('partner:${partnerUser}')` 存在

**验证方法：**
- 界面检查（**重点：两个数字人是否同时显示且位置正确**）
- Vue DevTools 检查
- 控制台日志检查

---

#### 测试步骤 8.2：切换用户角色不影响伙伴角色

**操作：**
1. 确保用户角色和伙伴角色都已连接
2. 切换用户角色（从用户角色列表中选择另一个用户角色）

**预期结果：**
- ✅ 用户角色切换成功
- ✅ **伙伴角色的连接状态不受影响**（仍然是"● 已连接"）
- ✅ **伙伴角色的数字人容器仍然显示**
- ✅ `appState.currentPartnerRole.isConnected` = `true`（保持不变）
- ✅ `appState.currentPartnerRole.showDigitalHuman` = `true`（保持不变）

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

#### 测试步骤 8.3：切换伙伴角色不影响用户角色

**操作：**
1. 确保用户角色和伙伴角色都已连接
2. 切换伙伴角色（从伙伴角色列表中选择另一个伙伴角色）

**预期结果：**
- ✅ 伙伴角色切换成功
- ✅ **用户角色的连接状态不受影响**（仍然是"● 已连接"）
- ✅ **用户角色的数字人容器仍然显示**
- ✅ `appState.currentUserRole.isConnected` = `true`（保持不变）
- ✅ `appState.currentUserRole.showDigitalHuman` = `true`（保持不变）

**验证方法：**
- 界面检查
- Vue DevTools 检查

---

## 四、测试检查点总结

### 4.1 状态一致性检查

每个步骤都需要检查：
- ✅ **数据库状态** ↔ **内存状态** 一致
- ✅ **内存状态** ↔ **界面显示** 一致
- ✅ **角色对象属性** ↔ **rendererManager** 一致

### 4.2 关键状态属性检查

每个步骤都需要检查以下属性：
- `role.user` - 角色的user字段（传给大模型）
- `role.isConnecting` - 是否正在连接
- `role.isConnected` - 是否已连接
- `role.showDigitalHuman` - 是否显示数字人容器
- `role.digitalHumanInstance` - 数字人SDK实例
- `role.positionX` - 水平位置（伙伴角色默认90%）
- `appState.currentPartnerRole` - 当前伙伴角色引用
- `appState.llm.user` - 当前传给大模型的user参数
- `rendererManager.getRenderer(roleId)` - 渲染器是否存在

### 4.3 独立性检查

每个步骤都需要检查：
- ✅ **伙伴角色之间互不干扰**
- ✅ **用户角色和伙伴角色互不干扰**
- ✅ **修改一个角色不影响其他角色**
- ✅ **切换角色时，旧角色的连接状态保持（但显示状态改变）**

### 4.4 精确更新检查

每个步骤都需要检查：
- ✅ **不重新加载整个角色列表**
- ✅ **只更新被修改的角色对象**
- ✅ **直接操作数组元素，而不是重新赋值整个数组**

### 4.5 位置检查

每个步骤都需要检查：
- ✅ **伙伴角色默认位置为90%**
- ✅ **用户角色默认位置为10%**
- ✅ **两个角色不会重叠**

---

## 五、测试记录表

### 5.1 测试执行记录

| 测试步骤 | 执行时间 | 执行人 | 结果 | 问题记录 |
|---------|---------|--------|------|---------|
| 1.1 登录 | | | ⬜ 通过 / ⬜ 失败 | |
| 1.2 验证初始状态 | | | ⬜ 通过 / ⬜ 失败 | |
| 2.1 创建第一个数字人角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 2.2 创建第二个数字人角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 2.3 创建立绘角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 3.1 连接第一个数字人角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 3.2 验证连接状态保持 | | | ⬜ 通过 / ⬜ 失败 | |
| 3.3 断开连接 | | | ⬜ 通过 / ⬜ 失败 | |
| 4.1 切换当前角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 4.2 连接新当前角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 4.3 切换回第一个角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 5.1 编辑数字人角色（不改变类型） | | | ⬜ 通过 / ⬜ 失败 | |
| 5.2 编辑数字人角色（改变类型为立绘） | | | ⬜ 通过 / ⬜ 失败 | |
| 5.3 编辑立绘角色（改变类型为数字人） | | | ⬜ 通过 / ⬜ 失败 | |
| 6.1 删除非当前角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 6.2 删除当前角色（已连接） | | | ⬜ 通过 / ⬜ 失败 | |
| 6.3 删除最后一个角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 7.1 退出登录 | | | ⬜ 通过 / ⬜ 失败 | |
| 7.2 重新登录并验证状态恢复 | | | ⬜ 通过 / ⬜ 失败 | |
| 8.1 同时连接用户角色和伙伴角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 8.2 切换用户角色不影响伙伴角色 | | | ⬜ 通过 / ⬜ 失败 | |
| 8.3 切换伙伴角色不影响用户角色 | | | ⬜ 通过 / ⬜ 失败 | |

### 5.2 问题记录表

| 问题编号 | 测试步骤 | 问题描述 | 严重程度 | 状态 |
|---------|---------|---------|---------|------|
| | | | ⬜ P0 / ⬜ P1 / ⬜ P2 | ⬜ 待修复 / ⬜ 已修复 |

---

## 六、测试通过标准

### 6.1 必须通过（P0）

- ✅ 所有创建、编辑、删除操作成功
- ✅ 连接/断开功能正常
- ✅ 切换当前角色功能正常
- ✅ 状态显示与底层状态一致
- ✅ 退出登录时正确清理所有状态
- ✅ 用户角色和伙伴角色互不干扰

### 6.2 应该通过（P1）

- ✅ 状态保持机制正常（关闭面板后重新打开）
- ✅ 状态恢复机制正常（切换角色后恢复连接状态）
- ✅ 角色之间互不干扰
- ✅ 位置默认值正确（用户10%，伙伴90%）

### 6.3 最好通过（P2）

- ✅ 界面状态更新无延迟
- ✅ 所有操作响应迅速
- ✅ 用户体验流畅

---

## 七、测试报告模板

### 7.1 测试总结

**测试日期：** _______________
**测试人员：** _______________
**测试环境：** _______________

**测试结果：**
- 总测试步骤：21
- 通过步骤：____
- 失败步骤：____
- 通过率：____%

### 7.2 问题汇总

**P0 问题：** ____ 个
**P1 问题：** ____ 个
**P2 问题：** ____ 个

### 7.3 测试结论

**整体评价：** ⬜ 通过 / ⬜ 不通过

**主要问题：**
1. 
2. 
3. 

**改进建议：**
1. 
2. 
3. 

---

## 八、注意事项

1. **测试顺序：** 必须按照测试步骤顺序执行，因为后续步骤依赖前面的结果
2. **状态检查：** 每个步骤都要检查所有相关状态，不能遗漏
3. **问题记录：** 发现问题立即记录，包括复现步骤和预期结果
4. **截图保存：** 关键步骤建议截图保存，便于问题定位
5. **日志检查：** 每个步骤都要检查控制台日志，确保没有错误
6. **状态一致性：** 重点检查界面显示与底层状态的一致性
7. **独立性验证：** 重点验证用户角色和伙伴角色的独立性
8. **位置验证：** 重点验证用户角色和伙伴角色的默认位置是否正确

---

## 九、快速测试清单

如果时间有限，可以只执行以下关键测试：

1. ✅ **登录** - 验证初始化
2. ✅ **创建数字人角色** - 验证创建和自动设为当前
3. ✅ **连接数字人** - 验证连接状态更新
4. ✅ **关闭面板后重新打开** - 验证状态保持
5. ✅ **切换当前角色** - 验证状态切换和恢复
6. ✅ **编辑角色（不改变类型）** - 验证状态保持
7. ✅ **删除当前角色（已连接）** - 验证状态清理
8. ✅ **退出登录** - 验证状态清理
9. ✅ **同时连接用户角色和伙伴角色** - 验证独立性

这9个关键测试可以覆盖80%的核心功能。

---

## 十、与用户角色的差异

### 10.1 主要差异点

1. **User字段：**
   - 用户角色：使用 `apiKey` 作为账号标识
   - 伙伴角色：使用 `user` 字段作为角色标识（传给大模型）

2. **当前角色标识：**
   - 用户角色：使用 `isCurrent` 字段
   - 伙伴角色：使用 `appState.llm.user` 匹配 `role.user`

3. **角色ID格式：**
   - 用户角色：`user:${role.id}`
   - 伙伴角色：`partner:${role.user}`

4. **默认位置：**
   - 用户角色：10%
   - 伙伴角色：90%

5. **自动设为当前：**
   - 用户角色：第一个角色自动设为当前
   - 伙伴角色：第一个角色自动设为当前（通过 `appState.llm.user`）

### 10.2 测试重点

- ✅ 验证 `appState.llm.user` 与 `role.user` 的同步
- ✅ 验证伙伴角色的 `user` 字段正确传给大模型
- ✅ 验证用户角色和伙伴角色的独立性
- ✅ 验证位置默认值（用户10%，伙伴90%）

