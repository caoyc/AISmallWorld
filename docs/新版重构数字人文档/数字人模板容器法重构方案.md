# 数字人模板容器法重构方案

## 一、需求分析

### 1.1 核心需求
- **最多两个数字人**：一个是用户角色，一个是伙伴角色
- **仿照立绘的模板容器法**：容器在模板中定义，使用Vue的响应式系统管理
- **保持独立**：每个数字人独立显示、拖拽、连接，互不影响

### 1.2 当前实现问题
1. **容器动态创建**：数字人容器不在模板中，通过 `document.createElement` 动态创建
2. **样式手动更新**：拖拽时需要手动查找容器并更新样式，不响应式
3. **事件手动绑定**：无法使用Vue的事件系统，需要手动 `addEventListener`
4. **显示/隐藏不统一**：通过 `watch` 监听器控制容器的 `display` 样式，而不是使用 `v-if`

## 二、立绘模板容器法分析

### 2.1 立绘实现方式（参考）

**模板部分：**
```vue
<!-- 伙伴立绘图片显示 -->
<div 
  v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar"
  class="illustration-container"
  :class="{ dragging: isDraggingPartner }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartner($event)"
>
  <img :src="partnerIllustrationImageUrl" />
</div>
```

**关键特点：**
1. ✅ 容器直接在模板中定义
2. ✅ 使用 `v-if` 条件渲染
3. ✅ 直接绑定 `@mousedown` 事件
4. ✅ 使用计算属性 `partnerAvatarPositionStyle` 动态计算样式
5. ✅ 不需要容器ID（Vue自动管理）

### 2.2 立绘的优势
- **响应式**：样式自动响应状态变化
- **事件系统**：使用Vue的事件系统，更可靠
- **DOM管理**：Vue自动管理DOM的创建和销毁
- **代码简洁**：不需要手动操作DOM

## 三、数字人模板容器法设计方案

### 3.1 模板部分设计

**在 `AvatarRender.vue` 模板中添加两个数字人容器：**

```vue
<!-- 伙伴数字人 SDK 渲染容器 -->
<div 
  v-if="appState.avatar.showPartnerDigitalHuman && currentPartnerRoleType === 'digital_human' && appState.currentPartnerRole"
  id="digital-human-partner"
  class="sdk-container"
  :class="{ dragging: isDraggingPartnerDigitalHuman }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartnerDigitalHuman($event)"
/>

<!-- 用户数字人 SDK 渲染容器 -->
<div 
  v-if="appState.avatar.showUserDigitalHuman && currentUserRoleType === 'digital_human' && appState.currentUserRole"
  id="digital-human-user"
  class="sdk-container user-digital-human"
  :class="{ dragging: isDraggingUserDigitalHuman }"
  :style="userAvatarPositionStyle"
  @mousedown="startDragUserDigitalHuman($event)"
/>
```

**关键点：**
1. ✅ **容器直接在模板中定义**：和立绘一样，使用 `v-if` 条件渲染
2. ✅ **固定容器ID**：`digital-human-partner` 和 `digital-human-user`（因为最多只有两个数字人，ID固定）
3. ✅ **直接绑定事件**：`@mousedown="startDragPartnerDigitalHuman($event)"` 直接在模板中绑定
4. ✅ **使用相同的计算属性样式**：`:style="partnerAvatarPositionStyle"` 和立绘使用同一个计算属性
5. ✅ **拖拽状态类**：`:class="{ dragging: isDraggingPartnerDigitalHuman }"` 和立绘一样

### 3.2 容器ID设计

**固定容器ID（不需要计算属性）：**
- 伙伴数字人：`digital-human-partner`
- 用户数字人：`digital-human-user`

**原因：**
- 最多只有两个数字人（一个用户，一个伙伴）
- 不需要区分不同的角色（因为只有当前用户和当前伙伴）
- 简化代码，不需要MD5哈希和计算属性

**位置样式计算属性（已存在，无需修改）：**
- `partnerAvatarPositionStyle`：已支持数字人拖拽状态（`isDraggingPartnerDigitalHuman`）
- `userAvatarPositionStyle`：已支持数字人拖拽状态（`isDraggingUserDigitalHuman`）

### 3.3 拖拽函数设计

**完全照抄立绘的拖拽函数：**

```typescript
// 开始拖动伙伴数字人（完全照抄 startDragPartner）
function startDragPartnerDigitalHuman(event: MouseEvent) {
  if (!appState.currentPartnerRole || !appState.llm.apiKey) return
  
  event.preventDefault()
  event.stopPropagation()
  
  // 禁用config-panel和chat-tab的pointer-events
  const configPanel = document.querySelector('.config-panel') as HTMLElement
  if (configPanel) {
    configPanel.style.pointerEvents = 'none'
  }
  const chatTab = document.querySelector('.chat-tab') as HTMLElement
  if (chatTab) {
    chatTab.style.pointerEvents = 'none'
  }
  
  isDraggingPartnerDigitalHuman.value = true
  dragType.value = 'partnerDigitalHuman'
  dragStartX.value = event.clientX
  dragStartY.value = event.clientY
  dragStartPositionX.value = appState.currentPartnerRole.positionX !== undefined ? appState.currentPartnerRole.positionX : 50
  dragStartPositionY.value = appState.currentPartnerRole.positionY !== undefined ? appState.currentPartnerRole.positionY : 50
  draggingPartnerPositionX.value = dragStartPositionX.value
  draggingPartnerPositionY.value = dragStartPositionY.value
  
  // 立即提升容器的z-index
  const container = event.currentTarget as HTMLElement
  if (container) {
    container.style.zIndex = '1000'
  }
  
  document.addEventListener('mousemove', handleDrag, { passive: false })
  document.addEventListener('mouseup', endDragPartnerDigitalHuman)
}

// 结束拖动伙伴数字人（完全照抄 endDragPartner）
async function endDragPartnerDigitalHuman(_event: MouseEvent) {
  if (!isDraggingPartnerDigitalHuman.value || !appState.currentPartnerRole || !appState.llm.apiKey) {
    cleanupDrag()
    return
  }
  
  document.removeEventListener('mousemove', handleDrag)
  document.removeEventListener('mouseup', endDragPartnerDigitalHuman)
  
  const finalPositionX = draggingPartnerPositionX.value ?? dragStartPositionX.value
  const finalPositionY = draggingPartnerPositionY.value ?? dragStartPositionY.value
  
  // 更新角色配置（和立绘完全一样）
  try {
    await updateRole(
      appState.currentPartnerRole.id,
      appState.llm.apiKey,
      {
        positionX: finalPositionX,
        positionY: finalPositionY
      }
    )
    // 重新加载角色信息（触发 watch，重新创建渲染器）
    await loadCurrentPartnerRole()
  } catch (error) {
    console.error('更新伙伴数字人位置失败:', error)
  }
  
  cleanupDrag()
}

// 用户数字人拖拽函数（完全照抄 startDragUser 和 endDragUser）
function startDragUserDigitalHuman(event: MouseEvent) {
  // ... 完全照抄 startDragUser，只是变量名改为 userDigitalHuman
}

async function endDragUserDigitalHuman(_event: MouseEvent) {
  // ... 完全照抄 endDragUser，只是变量名改为 userDigitalHuman，调用 updateUserRole
}
```

**关键点：**
1. ✅ **完全照抄立绘的逻辑**：除了函数名和变量名，其他完全一样
2. ✅ **使用 event.currentTarget**：直接获取容器元素，不需要 `getElementById`
3. ✅ **使用相同的 handleDrag 函数**：`handleDrag` 函数已经支持 `partnerDigitalHuman` 和 `userDigitalHuman` 类型
4. ✅ **不需要手动更新容器样式**：因为使用了计算属性，样式会自动响应状态变化

### 3.4 全局鼠标事件监听设计

**在 `globalMouseDown` 中添加数字人容器检测（照抄立绘的逻辑）：**

```typescript
// 在 globalMouseDown 函数中，添加数字人容器的检测
const digitalHumanContainers = document.querySelectorAll('.sdk-container') as NodeListOf<HTMLElement>
let clickedDigitalHuman: HTMLElement | null = null

for (const container of digitalHumanContainers) {
  const rect = container.getBoundingClientRect()
  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    clickedDigitalHuman = container
    break
  }
}

if (clickedDigitalHuman) {
  // 设置标志：正在处理数字人拖动
  isHandlingIllustrationDrag = true // 可以复用同一个标志
  
  // 隐藏面板（如果显示）
  const panelVisible = panelWrapper && panelWrapper.style.display !== 'none'
  if (panelVisible) {
    panelWrapper.style.display = 'none'
    historyPanelVisibleBeforeDrag.value = true
  } else {
    historyPanelVisibleBeforeDrag.value = false
  }
  
  // 手动触发 mousedown 事件
  const syntheticEvent = new MouseEvent('mousedown', {
    bubbles: true,
    cancelable: true,
    clientX: x,
    clientY: y,
    button: event.button,
    buttons: event.buttons,
    view: window
  })
  
  clickedDigitalHuman.dispatchEvent(syntheticEvent)
  
  event.preventDefault()
  event.stopPropagation()
}
```

**关键点：**
1. ✅ **检测数字人容器**：使用 `document.querySelectorAll('.sdk-container')` 查找所有数字人容器
2. ✅ **手动触发事件**：使用 `dispatchEvent` 在数字人容器上触发 `mousedown` 事件
3. ✅ **和立绘使用相同的逻辑**：完全照抄立绘的处理方式

### 3.5 SDK连接逻辑设计

**在 `watch` 中监听容器显示状态，自动连接/断开SDK：**

```typescript
// 监听伙伴数字人容器显示状态，自动连接SDK
watch(
  () => appState.avatar.showPartnerDigitalHuman && 
        currentPartnerRoleType.value === 'digital_human' && 
        appState.currentPartnerRole,
  async (shouldShow) => {
    if (!appState.currentPartnerRole) return
    
    const roleId = `partner:${appState.currentPartnerRole.user}`
    const containerId = 'digital-human-partner' // 固定ID
    
    if (shouldShow) {
      // 容器显示时，连接SDK
      const containerElement = document.getElementById(containerId)
      if (containerElement) {
        // 获取或创建渲染器
        let renderer = rendererManager.getRenderer(roleId)
        if (!renderer) {
          renderer = await rendererManager.createRenderer(roleId, {
            roleId,
            roleType: 'digital_human',
            positionX: appState.currentPartnerRole.positionX !== undefined ? appState.currentPartnerRole.positionX : 50,
            positionY: appState.currentPartnerRole.positionY !== undefined ? appState.currentPartnerRole.positionY : 50,
            scale: appState.currentPartnerRole.scale !== undefined ? appState.currentPartnerRole.scale : 1.0,
            avatarAppId: appState.currentPartnerRole.avatarAppId || '',
            avatarAppSecret: appState.currentPartnerRole.avatarAppSecret || ''
          })
        }
        
        // 设置回调函数
        if (renderer instanceof DigitalHumanRenderer) {
          renderer.setCallbacks({
            onSubtitleOn: (text: string) => {
              appState.ui.subTitleText = text
            },
            onSubtitleOff: () => {
              appState.ui.subTitleText = ''
            },
            onStateChange: (state: string) => {
              avatarState.value = state
            }
          })
        }
        
        // 连接SDK
        if (renderer.connect) {
          await renderer.connect()
          await renderer.render(containerElement)
          
          // 保存实例和连接状态
          if (renderer instanceof DigitalHumanRenderer) {
            const instance = renderer.getInstance()
            if (instance) {
              appState.avatar.instances.set(roleId, instance)
            }
          }
          appState.avatar.connectedRoles.add(roleId)
        }
      }
    } else {
      // 容器隐藏时，不断开SDK（保持连接状态，只隐藏容器）
      // 容器的显示/隐藏由 v-if 控制，SDK保持连接
    }
  },
  { immediate: true }
)

// 用户数字人同理
```

**关键点：**
1. ✅ **容器显示时连接SDK**：当 `v-if` 条件满足时，容器会被创建，此时连接SDK
2. ✅ **容器隐藏时不断开SDK**：当 `v-if` 条件不满足时，容器会被销毁，但SDK保持连接（下次显示时不需要重新连接）
3. ✅ **SDK连接逻辑独立**：在 `watch` 中处理，不影响拖拽逻辑

### 3.6 清理逻辑设计

**移除动态创建容器的代码：**
- 移除 `ConfigPanel.vue` 中 `handleConnectRoleFromList` 和 `handleConnectUserRoleFromList` 中的容器创建代码
- 移除 `AvatarRender.vue` 中 `setupPartnerDigitalHumanRenderer` 和 `setupUserDigitalHumanRenderer` 中的容器创建代码

**移除手动更新样式的代码：**
- 移除 `handleDrag` 中手动更新数字人容器位置的代码（因为使用了计算属性，样式会自动更新）

**移除 watch 中手动控制 display 的代码：**
- 移除 `watch(() => appState.avatar.showPartnerDigitalHuman)` 和 `watch(() => appState.avatar.showUserDigitalHuman)` 中手动设置 `display` 样式的代码（因为使用 `v-if` 控制）

## 四、实施步骤

### 4.1 第一步：修改模板
1. 在 `AvatarRender.vue` 模板中添加两个数字人容器（用户和伙伴）
2. 使用计算属性生成容器ID
3. 绑定 `@mousedown` 事件
4. 使用计算属性样式

### 4.2 第二步：添加拖拽函数
1. 添加 `startDragPartnerDigitalHuman` 和 `endDragPartnerDigitalHuman`（照抄立绘）
2. 添加 `startDragUserDigitalHuman` 和 `endDragUserDigitalHuman`（照抄立绘）
3. 确保 `handleDrag` 函数支持数字人类型（已支持，无需修改）

### 4.3 第三步：修改全局鼠标事件监听
1. 在 `globalMouseDown` 中添加数字人容器检测（照抄立绘的逻辑）

### 4.4 第四步：修改SDK连接逻辑
1. 在 `watch` 中监听容器显示状态，自动连接SDK
2. 移除 `setupPartnerDigitalHumanRenderer` 和 `setupUserDigitalHumanRenderer` 中的容器创建代码

### 4.5 第五步：清理旧代码
1. 移除 `ConfigPanel.vue` 中动态创建容器的代码
2. 移除 `handleDrag` 中手动更新数字人容器位置的代码
3. 移除 `watch` 中手动控制 `display` 样式的代码

## 五、与立绘的差异（必须保留）

### 5.1 容器ID
- **立绘**：不需要容器ID
- **数字人**：使用固定ID（`digital-human-partner` 和 `digital-human-user`），因为最多只有两个数字人

### 5.2 SDK连接逻辑
- **立绘**：不需要连接
- **数字人**：需要连接SDK服务器和初始化WebGL渲染引擎（数字人特有的技术需求）

## 六、预期效果

### 6.1 代码简化
- ✅ 移除所有动态创建容器的代码
- ✅ 移除所有手动更新样式的代码
- ✅ 移除所有手动控制 `display` 样式的代码

### 6.2 功能一致性
- ✅ 数字人拖拽逻辑与立绘完全一致
- ✅ 数字人显示/隐藏逻辑与立绘完全一致
- ✅ 数字人事件处理与立绘完全一致

### 6.3 最多两个数字人
- ✅ 通过 `v-if` 条件确保只有当前用户和伙伴角色是数字人时才显示
- ✅ 最多同时显示两个数字人（一个用户，一个伙伴）

## 七、风险评估

### 7.1 低风险
- ✅ 模板容器法已在立绘中验证，技术成熟
- ✅ 拖拽逻辑完全照抄立绘，风险低
- ✅ SDK连接逻辑独立，不影响拖拽

### 7.2 需要注意
- ⚠️ SDK连接时机：确保容器在模板中创建后再连接SDK（使用 `nextTick` 或 `watch` 的 `flush: 'post'`）
- ⚠️ 容器ID固定：使用固定ID `digital-human-partner` 和 `digital-human-user`，确保不会冲突

## 八、重构前代码清理清单

### 8.1 清理原则

**核心原则：**
- ✅ **不打补丁**：不保留旧代码，不兼容旧逻辑，直接删除
- ✅ **不兼容**：不保留向后兼容代码，错误直接暴露
- ✅ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ✅ **干净重构**：确保重构前清理干净，避免新旧代码混在一起导致联动问题

### 8.2 需要清理的代码位置

#### 8.2.1 ConfigPanel.vue - 动态创建容器代码

**位置1：`handleConnectRoleFromList` 函数（约第1812-2000行）**

**需要删除的代码：**
```typescript
// 删除：动态创建容器的所有代码
const roleIdHash = toMd5(partnerRoleId)
const containerId = `digital-human-${roleIdHash}`

// 检查容器是否已存在
let containerElement = document.getElementById(containerId)
if (!containerElement) {
  // 实时创建容器
  containerElement = document.createElement('div')
  containerElement.id = containerId
  containerElement.className = 'sdk-container'
  containerElement.style.position = 'fixed'
  containerElement.style.left = `${role.positionX !== undefined ? role.positionX : 50}%`
  containerElement.style.top = `${role.positionY !== undefined ? role.positionY : 50}%`
  containerElement.style.transform = `translate(-50%, -50%) scale(${role.scale !== undefined ? role.scale : 1.0})`
  // ... 所有样式设置
  avatarRender.appendChild(containerElement)
}
```

**清理原因：**
- ❌ 容器应该在模板中定义，不应该动态创建
- ❌ 动态创建导致无法使用Vue的响应式系统
- ❌ 动态创建导致无法直接绑定事件
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 容器在模板中定义，使用固定ID `digital-human-partner`
- ✅ 连接时直接使用 `document.getElementById('digital-human-partner')`
- ✅ 如果容器不存在，说明模板未渲染，直接报错（错误直接暴露）

---

**位置2：`handleConnectUserRoleFromList` 函数（约第2036-2220行）**

**需要删除的代码：**
```typescript
// 删除：动态创建容器的所有代码（与位置1类似）
const roleIdHash = toMd5(userRoleId)
const containerId = `digital-human-${roleIdHash}`
// ... 所有动态创建容器的代码
```

**清理原因：** 同位置1

**清理后：**
- ✅ 容器在模板中定义，使用固定ID `digital-human-user`
- ✅ 连接时直接使用 `document.getElementById('digital-human-user')`

---

#### 8.2.2 AvatarRender.vue - 动态创建容器和手动控制display

**位置3：`setupPartnerDigitalHumanRenderer` 函数（约第156-220行）**

**需要删除的代码：**
```typescript
// 删除：清理旧容器DOM元素的代码
const roleIdHash = toMd5(roleId)
const oldContainerId = `digital-human-${roleIdHash}`
const oldContainer = document.getElementById(oldContainerId)
if (oldContainer) {
  oldContainer.remove()
}

// 删除：如果已连接，手动查找容器并设置display的代码
if (appState.avatar.connectedRoles.has(roleIdForState)) {
  const roleIdHash = toMd5(roleIdForState)
  const containerId = `digital-human-${roleIdHash}`
  const containerElement = document.getElementById(containerId)
  if (containerElement) {
    await renderer.render(containerElement)
    containerElement.style.display = appState.avatar.showPartnerDigitalHuman ? 'flex' : 'none'
  }
}
```

**清理原因：**
- ❌ 容器应该在模板中定义，不应该手动创建或删除
- ❌ 显示/隐藏应该通过 `v-if` 控制，不应该手动设置 `display` 样式
- ❌ 手动控制 `display` 导致与 `v-if` 冲突，引发联动问题

**清理后：**
- ✅ 容器在模板中定义，使用固定ID `digital-human-partner`
- ✅ 显示/隐藏通过 `v-if` 控制，不需要手动设置 `display`
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

---

**位置4：`setupUserDigitalHumanRenderer` 函数（约第223-313行）**

**需要删除的代码：**
```typescript
// 删除：与位置3类似的代码
const roleIdHash = toMd5(roleId)
const oldContainerId = `digital-human-${roleIdHash}`
// ... 所有手动创建/删除容器的代码
// ... 所有手动设置display的代码
```

**清理原因：** 同位置3

**清理后：** 同位置3，使用固定ID `digital-human-user`

---

**位置5：`watch(() => appState.avatar.showPartnerDigitalHuman)`（约第343-353行）**

**需要删除的代码：**
```typescript
// 删除：手动控制容器display的watch
watch(() => appState.avatar.showPartnerDigitalHuman, (visible) => {
  if (appState.currentPartnerRole && appState.currentPartnerRole.type === 'digital_human') {
    const roleId = `partner:${appState.currentPartnerRole.user}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const containerElement = document.getElementById(containerId)
    if (containerElement) {
      containerElement.style.display = visible ? 'flex' : 'none'
    }
  }
})
```

**清理原因：**
- ❌ 显示/隐藏应该通过 `v-if` 控制，不应该手动设置 `display`
- ❌ 手动设置 `display` 与 `v-if` 冲突，导致联动问题
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 显示/隐藏通过 `v-if` 控制，不需要手动设置 `display`
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

---

**位置6：`watch(() => appState.avatar.showUserDigitalHuman)`（约第355-365行）**

**需要删除的代码：**
```typescript
// 删除：手动控制容器display的watch（与位置5类似）
watch(() => appState.avatar.showUserDigitalHuman, (visible) => {
  // ... 所有手动设置display的代码
})
```

**清理原因：** 同位置5

**清理后：** 同位置5

---

**位置7：`handleDrag` 函数中手动更新数字人容器位置的代码（约第729-757行）**

**需要删除的代码：**
```typescript
// 删除：手动更新数字人容器位置的代码
} else if (dragType.value === 'partnerDigitalHuman') {
  draggingPartnerPositionX.value = newPositionX
  draggingPartnerPositionY.value = newPositionY
  // 删除以下代码：
  if (appState.currentPartnerRole) {
    const roleId = `partner:${appState.currentPartnerRole.user}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const container = document.getElementById(containerId)
    if (container) {
      container.style.left = `${newPositionX}%`
      container.style.top = `${newPositionY}%`
    }
  }
} else if (dragType.value === 'userDigitalHuman') {
  draggingUserPositionX.value = newPositionX
  draggingUserPositionY.value = newPositionY
  // 删除以下代码：
  if (appState.currentUserRole) {
    const roleId = `user:${appState.currentUserRole.id}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const container = document.getElementById(containerId)
    if (container) {
      container.style.left = `${newPositionX}%`
      container.style.top = `${newPositionY}%`
    }
  }
}
```

**清理原因：**
- ❌ 位置应该通过计算属性 `partnerAvatarPositionStyle` 和 `userAvatarPositionStyle` 自动更新
- ❌ 手动更新样式不响应式，导致拖拽时位置不同步
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 位置通过计算属性自动更新，不需要手动设置
- ✅ 拖拽时只需要更新 `draggingPartnerPositionX` 和 `draggingPartnerPositionY`，计算属性会自动响应

---

#### 8.2.3 DigitalHumanRenderer.ts - 容器ID生成

**位置8：`DigitalHumanRenderer` 构造函数（约第25-26行）**

**需要修改的代码：**
```typescript
// 当前代码：
const roleIdHash = toMd5(config.roleId)
this.containerId = `digital-human-${roleIdHash}`

// 修改为：
// 不再在渲染器中生成容器ID，容器ID在模板中固定
// 伙伴数字人：'digital-human-partner'
// 用户数字人：'digital-human-user'
// 渲染器不再需要 containerId 属性，或者改为从外部传入
```

**清理原因：**
- ❌ 容器ID应该固定，不应该动态生成
- ❌ MD5哈希不再需要，简化代码

**清理后：**
- ✅ 容器ID固定，渲染器从外部传入容器ID（或通过配置传入）
- ✅ 简化代码，移除MD5哈希相关逻辑

---

### 8.3 清理后的代码结构

**清理后的代码应该：**
1. ✅ **模板中定义容器**：两个固定ID的容器（`digital-human-partner` 和 `digital-human-user`）
2. ✅ **使用 `v-if` 控制显示**：不需要手动设置 `display`
3. ✅ **使用计算属性控制位置**：不需要手动更新样式
4. ✅ **SDK连接在 `watch` 中处理**：容器显示时自动连接
5. ✅ **拖拽逻辑照抄立绘**：不需要特殊处理

### 8.4 清理检查清单

**重构前必须完成：**
- [ ] 删除 `ConfigPanel.vue` 中所有动态创建容器的代码
- [ ] 删除 `AvatarRender.vue` 中所有手动设置 `display` 的代码
- [ ] 删除 `AvatarRender.vue` 中所有手动更新位置的代码
- [ ] 删除 `AvatarRender.vue` 中所有手动创建/删除容器的代码
- [ ] 删除 `handleDrag` 中所有手动更新数字人容器位置的代码
- [ ] 修改 `DigitalHumanRenderer` 构造函数，移除MD5哈希逻辑
- [ ] 删除所有 `toMd5` 相关的导入和使用（如果不再需要）
- [ ] 确保所有容器ID改为固定值（`digital-human-partner` 和 `digital-human-user`）

**清理后验证：**
- [ ] 运行代码，确保所有错误直接暴露（不保留容错代码）
- [ ] 检查是否还有动态创建容器的代码
- [ ] 检查是否还有手动设置 `display` 的代码
- [ ] 检查是否还有手动更新位置的代码
- [ ] 检查是否还有MD5哈希相关的代码

### 8.5 清理顺序建议

**建议的清理顺序：**
1. **第一步**：先删除所有动态创建容器的代码（`ConfigPanel.vue`）
2. **第二步**：删除所有手动设置 `display` 的代码（`AvatarRender.vue`）
3. **第三步**：删除所有手动更新位置的代码（`handleDrag`）
4. **第四步**：修改 `DigitalHumanRenderer`，移除MD5哈希逻辑
5. **第五步**：运行代码，确保错误直接暴露，修复所有错误
6. **第六步**：开始重构，添加模板容器和新的逻辑

**重要提示：**
- ⚠️ **不要保留旧代码**：删除所有不再需要的代码，不保留向后兼容
- ⚠️ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ⚠️ **不打补丁**：不要在新代码中保留旧逻辑，确保干净重构

## 九、总结

**核心原则：除了容器ID（固定ID）和SDK连接逻辑（数字人特有）这两个技术细节外，其他所有实现都应该完全照抄立绘。**

**清理原则：**
- ✅ **不打补丁**：不保留旧代码，不兼容旧逻辑，直接删除
- ✅ **不兼容**：不保留向后兼容代码，错误直接暴露
- ✅ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ✅ **干净重构**：确保重构前清理干净，避免新旧代码混在一起导致联动问题

**优势：**
1. ✅ 代码简洁：使用Vue的响应式系统，不需要手动操作DOM
2. ✅ 功能一致：数字人行为与立绘完全一致
3. ✅ 易于维护：统一的实现方式，降低维护成本
4. ✅ 最多两个：通过 `v-if` 条件自然限制，最多同时显示两个数字人
5. ✅ **解决联动问题**：通过清理所有动态创建和手动控制的代码，彻底解决数字人联动问题

