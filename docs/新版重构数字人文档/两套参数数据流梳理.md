# 两套参数数据流梳理

## 核心原则

**大模型调用的参数维护和数字人连接的参数维护是独立的两套，各不依赖。**

---

# 一、大模型调用参数数据流

## 1.1 参数定义

**参数列表：**
- `baseURL`: 大模型API的基础URL
- `model`: 大模型名称
- `apiKey`: 大模型API密钥（用于用户隔离）
- `user`: 伙伴角色标识（用于对话历史隔离和API调用）

**存储位置：**
- 全局状态：`appState.llm.baseURL`、`appState.llm.model`、`appState.llm.apiKey`、`appState.llm.user`
- 数据库：`user_roles` 表（用户角色）：`baseURL`、`model`、`apiKey`
- 数据库：`roles` 表（伙伴角色）：`baseURL`、`model`、`apiKey`、`user`

**使用位置：**
- `src/stores/app.ts` - `sendMessage()`: 调用 `llmService.sendMessageWithStream()` 时传入
- `src/services/llm.ts` - `sendMessageWithStream()`: 使用这些参数初始化 OpenAI 客户端并调用API
- `src/services/chatHistory.ts` - `saveChatMessage()`: 使用 `apiKey` 和 `user` 保存对话历史

---

## 1.2 入口1：APIKey登录后获取当前角色

### 数据流节点（以注释形式标注）

```typescript
// ConfigPanel.vue - handleApiKeyLogin() (约第2845行)
async function handleApiKeyLogin() {
  // ... 验证输入 ...
  
  // 【节点1.1】设置全局APIKey（大模型参数）
  globalApiKey.value = loginApiKeyInput.value.trim()
  appState.llm.apiKey = globalApiKey.value  // ← 大模型参数：apiKey
  
  // 【节点1.2】加载用户角色列表
  await loadUserRoles()
  // loadUserRoles() 内部：
  //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
  //   - 查找 isCurrent === true 的角色
  //   - 设置 appState.currentUserRole = currentRole
  //   - 【节点1.3】应用用户角色的大模型配置到全局状态
  //     if (currentRole) {
  //       if (currentRole.baseURL) {
  //         appState.llm.baseURL = currentRole.baseURL  // ← 大模型参数：baseURL
  //       }
  //       if (currentRole.model) {
  //         appState.llm.model = currentRole.model  // ← 大模型参数：model
  //       }
  //       appState.llm.apiKey = globalApiKey.value  // ← 大模型参数：apiKey
  //     }
  
  if (!appState.currentUserRole) {
    // ... 弹出角色创建面板 ...
  } else {
    // 【节点1.4】加载伙伴角色列表
    await loadRoles()
    
    // 【节点1.5】获取并设置当前伙伴角色
    await getAndSetCurrentPartnerRole()
    // getAndSetCurrentPartnerRole() 内部：
    //   - 从 localStorage 恢复 appState.llm.user（如果存在且对应的伙伴角色存在）
    //   - 【节点1.6】设置 appState.llm.user = config.llm.user  // ← 大模型参数：user
    //   - 【需要添加】设置 appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user)
    
    // 【节点1.7】加载对话历史（使用 appState.llm.apiKey 和 appState.llm.user 过滤）
    await loadHistory()
    
    // 【节点1.8】触发角色更新事件
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
  }
}
```

### 数据流路径

```
【入口1：APIKey登录】
  ↓
【节点1.1】设置 appState.llm.apiKey = globalApiKey.value
  ↓
【节点1.2】loadUserRoles() → 从数据库获取用户角色列表
  ↓
【节点1.3】应用用户角色的大模型配置：
  - appState.llm.baseURL = currentRole.baseURL
  - appState.llm.model = currentRole.model
  - appState.llm.apiKey = globalApiKey.value
  ↓
【节点1.4】loadRoles() → 从数据库获取伙伴角色列表
  ↓
【节点1.5】getAndSetCurrentPartnerRole() → 从 localStorage 恢复或设置
  ↓
【节点1.6】设置 appState.llm.user = config.llm.user
  ↓
【节点1.7】loadHistory() → 使用 appState.llm.apiKey 和 appState.llm.user 加载对话历史
  ↓
【最终状态】appState.llm = { baseURL, model, apiKey, user }
  ↓
【使用位置】appStore.sendMessage() → llmService.sendMessageWithStream({ baseURL, model, apiKey, user })
```

---

## 1.3 入口2：切换角色时

### 切换用户角色

```typescript
// ConfigPanel.vue - handleSetCurrentUserRole() (约第3157行)
async function handleSetCurrentUserRole(role: UserRole) {
  try {
    // 【节点2.1】设置当前用户角色（调用API）
    await setCurrentUserRole(role.id, globalApiKey.value)
    
    // 【节点2.2】重新加载用户角色列表
    await loadUserRoles()
    // loadUserRoles() 内部：
    //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
    //   - 查找 isCurrent === true 的角色
    //   - 设置 appState.currentUserRole = currentRole
    //   - 【节点2.3】应用用户角色的大模型配置到全局状态
    //     if (currentRole) {
    //       if (currentRole.baseURL) {
    //         appState.llm.baseURL = currentRole.baseURL  // ← 大模型参数：baseURL
    //       }
    //       if (currentRole.model) {
    //         appState.llm.model = currentRole.model  // ← 大模型参数：model
    //       }
    //       appState.llm.apiKey = globalApiKey.value  // ← 大模型参数：apiKey
    //     }
    
    // 【节点2.4】记录当前角色（确保同步）
    appState.currentUserRole = role
    
    // 【节点2.5】应用用户角色的大模型配置到全局状态（再次确认）
    if (role.baseURL) {
      appState.llm.baseURL = role.baseURL  // ← 大模型参数：baseURL
    }
    if (role.model) {
      appState.llm.model = role.model  // ← 大模型参数：model
    }
    appState.llm.apiKey = globalApiKey.value  // ← 大模型参数：apiKey
    
    // 【节点2.6】保存配置
    handleSaveConfig()
    
    // 【节点2.7】触发角色更新事件
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
  } catch (error) {
    // ...
  }
}
```

### 切换伙伴角色

```typescript
// ConfigPanel.vue - handleSetCurrentRole() (约第3719行)
async function handleSetCurrentRole(role: Role) {
  // 【节点2.8】记录当前角色
  appState.llm.user = role.user  // ← 大模型参数：user
  // 【需要添加】appState.currentPartnerRole = role
  
  // 【节点2.9】应用角色的大模型配置
  if (role.baseURL !== undefined && role.baseURL !== null && role.baseURL.trim()) {
    appState.llm.baseURL = role.baseURL  // ← 大模型参数：baseURL
  }
  if (role.model !== undefined && role.model !== null && role.model.trim()) {
    appState.llm.model = role.model  // ← 大模型参数：model
  }
  if (role.apiKey !== undefined && role.apiKey !== null && role.apiKey.trim()) {
    appState.llm.apiKey = role.apiKey  // ← 大模型参数：apiKey
  }
  
  // 【节点2.10】保存配置
  handleSaveConfig()
  
  // 【节点2.11】重新加载角色列表
  await loadRoles()
  
  // 【节点2.12】切换当前伙伴角色时，同时切换历史记录
  await loadHistory()
  // loadHistory() 内部：
  //   - 使用 appState.llm.apiKey 和 appState.llm.user 加载对话历史
  //   - 设置 appState.chatHistory = historyList
  
  // 【节点2.13】触发角色更新事件
  const event = new CustomEvent('roleUpdated')
  window.dispatchEvent(event)
}
```

### 数据流路径

```
【入口2：切换用户角色】
  ↓
【节点2.1】setCurrentUserRole() → 更新数据库中的 isCurrent 字段
  ↓
【节点2.2】loadUserRoles() → 从数据库获取用户角色列表
  ↓
【节点2.3】应用用户角色的大模型配置：
  - appState.llm.baseURL = currentRole.baseURL
  - appState.llm.model = currentRole.model
  - appState.llm.apiKey = globalApiKey.value
  ↓
【节点2.4】appState.currentUserRole = role
  ↓
【节点2.5】再次确认大模型配置（从 role 对象直接设置）
  ↓
【节点2.6】handleSaveConfig() → 保存到 localStorage
  ↓
【最终状态】appState.llm = { baseURL, model, apiKey, user }（user 不变）

【入口2：切换伙伴角色】
  ↓
【节点2.8】设置 appState.llm.user = role.user
  ↓
【节点2.9】应用角色的大模型配置：
  - appState.llm.baseURL = role.baseURL
  - appState.llm.model = role.model
  - appState.llm.apiKey = role.apiKey
  ↓
【节点2.10】handleSaveConfig() → 保存到 localStorage
  ↓
【节点2.11】loadRoles() → 从数据库获取伙伴角色列表
  ↓
【节点2.12】loadHistory() → 使用 appState.llm.apiKey 和 appState.llm.user 加载对话历史
  ↓
【最终状态】appState.llm = { baseURL, model, apiKey, user }
```

---

## 1.4 大模型调用使用参数

```typescript
// src/stores/app.ts - sendMessage() (约第77行)
async sendMessage(): Promise<string | undefined> {
  // ... 处理用户消息 ...
  
  // 【节点1.9】发送到LLM获取回复（使用 appState.llm 中的参数）
  const stream = await llmService.sendMessageWithStream({
    provider: 'openai',
    model: llm.model,        // ← 大模型参数：model
    apiKey: llm.apiKey,     // ← 大模型参数：apiKey
    baseURL: llm.baseURL,   // ← 大模型参数：baseURL
    user: llm.user          // ← 大模型参数：user
  }, processedUserMessage, recentHistory)
  
  // ... 处理响应 ...
  
  // 【节点1.10】保存助手回复到数据库（使用 appState.llm 中的参数）
  await saveChatMessage(
    'assistant',
    finalContent,
    llm.apiKey,    // ← 大模型参数：apiKey（用于用户隔离）
    llm.user || '', // ← 大模型参数：user（用于对话历史隔离）
    assistantMessage.timestamp
  )
}
```

```typescript
// src/services/llm.ts - sendMessageWithStream() (约第88行)
async sendMessageWithStream(config: LlmConfig, userMessage: string, chatHistory?: ChatMessage[]): Promise<AsyncIterable<string>> {
  // 【节点1.11】初始化LLM客户端（使用传入的参数）
  this.initClient(config)
  // initClient() 内部：
  //   - 使用 config.baseURL 或 LLM_CONFIG.BASE_URL
  //   - 使用 config.apiKey 初始化 OpenAI 客户端
  
  // ... 构建消息 ...
  
  // 【节点1.12】调用大模型API（使用传入的参数）
  const stream = await this.openai.chat.completions.create({
    messages,
    model: config.model,        // ← 大模型参数：model
    stream: true,
    ...(config.user && { user: config.user })  // ← 大模型参数：user
  })
  
  // ... 返回流 ...
}
```

---

# 二、数字人连接参数数据流

## 2.1 参数定义

**参数列表：**
- `avatarAppId`: 数字人SDK的应用ID
- `avatarAppSecret`: 数字人SDK的应用密钥

**存储位置：**
- 数据库：`user_roles` 表（用户角色）：`avatarAppId`、`avatarAppSecret`
- 数据库：`roles` 表（伙伴角色）：`avatarAppId`、`avatarAppSecret`
- 渲染器配置：`DigitalHumanRendererConfig.avatarAppId`、`DigitalHumanRendererConfig.avatarAppSecret`

**使用位置：**
- `src/renderers/digital-human/DigitalHumanRenderer.ts` - `connect()`: 使用这些参数连接数字人SDK
- `src/services/avatar.ts` - `connect()`: 使用这些参数初始化SDK实例

---

## 2.2 入口1：APIKey登录后获取当前角色

### 数据流节点（以注释形式标注）

```typescript
// ConfigPanel.vue - handleApiKeyLogin() (约第2845行)
async function handleApiKeyLogin() {
  // ... 验证输入 ...
  
  // 【节点2.1】设置全局APIKey（大模型参数，与数字人参数无关）
  globalApiKey.value = loginApiKeyInput.value.trim()
  appState.llm.apiKey = globalApiKey.value
  
  // 【节点2.2】加载用户角色列表
  await loadUserRoles()
  // loadUserRoles() 内部：
  //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
  //   - 查找 isCurrent === true 的角色
  //   - 设置 appState.currentUserRole = currentRole
  //   - 注意：loadUserRoles() 只处理大模型参数，不处理数字人参数
  //   - 数字人参数（avatarAppId, avatarAppSecret）存储在 currentRole 对象中，但不在这里使用
  
  if (!appState.currentUserRole) {
    // ... 弹出角色创建面板 ...
  } else {
    // 【节点2.3】加载伙伴角色列表
    await loadRoles()
    // loadRoles() 内部：
    //   - 调用 getRoles(globalApiKey.value) 获取角色列表
    //   - 设置 roles.value = roleList
    //   - 注意：loadRoles() 只加载角色列表，不处理数字人参数
    //   - 数字人参数（avatarAppId, avatarAppSecret）存储在 roleList 中，但不在这里使用
    
    // 【节点2.4】获取并设置当前伙伴角色
    await getAndSetCurrentPartnerRole()
    // getAndSetCurrentPartnerRole() 内部：
    //   - 从 localStorage 恢复 appState.llm.user
    //   - 注意：只处理大模型参数，不处理数字人参数
    
    // 【节点2.5】加载对话历史
    await loadHistory()
    
    // 【节点2.6】触发角色更新事件
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
    // 注意：roleUpdated 事件会触发 AvatarRender.vue 的 handleRoleUpdated
    // handleRoleUpdated 会调用 setupPartnerDigitalHumanRenderer 和 setupUserDigitalHumanRenderer
    // 但此时数字人还未连接，数字人参数只是存储在角色对象中，等待连接时使用
  }
}
```

### 数据流路径

```
【入口1：APIKey登录】
  ↓
【节点2.1】设置 appState.llm.apiKey（大模型参数，与数字人无关）
  ↓
【节点2.2】loadUserRoles() → 从数据库获取用户角色列表
  ↓
【节点2.2.1】appState.currentUserRole = currentRole
  - currentRole.avatarAppId  // ← 数字人参数：avatarAppId（存储在对象中，未使用）
  - currentRole.avatarAppSecret  // ← 数字人参数：avatarAppSecret（存储在对象中，未使用）
  ↓
【节点2.3】loadRoles() → 从数据库获取伙伴角色列表
  ↓
【节点2.3.1】roles.value = roleList
  - roleList[].avatarAppId  // ← 数字人参数：avatarAppId（存储在对象中，未使用）
  - roleList[].avatarAppSecret  // ← 数字人参数：avatarAppSecret（存储在对象中，未使用）
  ↓
【节点2.4】getAndSetCurrentPartnerRole() → 设置 appState.llm.user（大模型参数）
  ↓
【节点2.5】loadHistory() → 加载对话历史（大模型参数相关）
  ↓
【节点2.6】触发 roleUpdated 事件
  ↓
【最终状态】数字人参数存储在角色对象中，等待连接时使用
```

---

## 2.3 入口2：切换角色时

### 切换用户角色

```typescript
// ConfigPanel.vue - handleSetCurrentUserRole() (约第3157行)
async function handleSetCurrentUserRole(role: UserRole) {
  try {
    // 【节点2.7】设置当前用户角色（调用API）
    await setCurrentUserRole(role.id, globalApiKey.value)
    
    // 【节点2.8】重新加载用户角色列表
    await loadUserRoles()
    // loadUserRoles() 内部：
    //   - 设置 appState.currentUserRole = currentRole
    //   - 注意：只处理大模型参数，不处理数字人参数
    //   - 数字人参数（avatarAppId, avatarAppSecret）存储在 currentRole 对象中，但不在这里使用
    
    // 【节点2.9】记录当前角色（确保同步）
    appState.currentUserRole = role
    // role.avatarAppId  // ← 数字人参数：avatarAppId（存储在对象中，未使用）
    // role.avatarAppSecret  // ← 数字人参数：avatarAppSecret（存储在对象中，未使用）
    
    // 【节点2.10】应用用户角色的大模型配置到全局状态
    if (role.baseURL) {
      appState.llm.baseURL = role.baseURL  // ← 大模型参数：baseURL
    }
    if (role.model) {
      appState.llm.model = role.model  // ← 大模型参数：model
    }
    appState.llm.apiKey = globalApiKey.value  // ← 大模型参数：apiKey
    // 注意：不处理数字人参数，数字人参数只在连接时使用
    
    // 【节点2.11】保存配置
    handleSaveConfig()
    
    // 【节点2.12】触发角色更新事件
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
    // 注意：roleUpdated 事件会触发 AvatarRender.vue 的 handleRoleUpdated
    // handleRoleUpdated 会调用 setupUserDigitalHumanRenderer(appState.currentUserRole)
    // 但此时数字人还未连接，数字人参数只是存储在角色对象中，等待连接时使用
  } catch (error) {
    // ...
  }
}
```

### 切换伙伴角色

```typescript
// ConfigPanel.vue - handleSetCurrentRole() (约第3719行)
async function handleSetCurrentRole(role: Role) {
  // 【节点2.13】记录当前角色
  appState.llm.user = role.user  // ← 大模型参数：user
  // 【需要添加】appState.currentPartnerRole = role
  // role.avatarAppId  // ← 数字人参数：avatarAppId（存储在对象中，未使用）
  // role.avatarAppSecret  // ← 数字人参数：avatarAppSecret（存储在对象中，未使用）
  
  // 【节点2.14】应用角色的大模型配置
  if (role.baseURL !== undefined && role.baseURL !== null && role.baseURL.trim()) {
    appState.llm.baseURL = role.baseURL  // ← 大模型参数：baseURL
  }
  if (role.model !== undefined && role.model !== null && role.model.trim()) {
    appState.llm.model = role.model  // ← 大模型参数：model
  }
  if (role.apiKey !== undefined && role.apiKey !== null && role.apiKey.trim()) {
    appState.llm.apiKey = role.apiKey  // ← 大模型参数：apiKey
  }
  // 注意：不处理数字人参数，数字人参数只在连接时使用
  
  // 【节点2.15】保存配置
  handleSaveConfig()
  
  // 【节点2.16】重新加载角色列表
  await loadRoles()
  
  // 【节点2.17】切换当前伙伴角色时，同时切换历史记录
  await loadHistory()
  
  // 【节点2.18】触发角色更新事件
  const event = new CustomEvent('roleUpdated')
  window.dispatchEvent(event)
  // 注意：roleUpdated 事件会触发 AvatarRender.vue 的 handleRoleUpdated
  // handleRoleUpdated 会调用 setupPartnerDigitalHumanRenderer(appState.currentPartnerRole)
  // 但此时数字人还未连接，数字人参数只是存储在角色对象中，等待连接时使用
}
```

### 数据流路径

```
【入口2：切换用户角色】
  ↓
【节点2.7】setCurrentUserRole() → 更新数据库中的 isCurrent 字段
  ↓
【节点2.8】loadUserRoles() → 从数据库获取用户角色列表
  ↓
【节点2.9】appState.currentUserRole = role
  - role.avatarAppId  // ← 数字人参数：存储在对象中，未使用
  - role.avatarAppSecret  // ← 数字人参数：存储在对象中，未使用
  ↓
【节点2.10】应用大模型配置（不处理数字人参数）
  ↓
【节点2.11】handleSaveConfig() → 保存到 localStorage（只保存大模型参数）
  ↓
【节点2.12】触发 roleUpdated 事件
  ↓
【最终状态】数字人参数存储在 appState.currentUserRole 对象中，等待连接时使用

【入口2：切换伙伴角色】
  ↓
【节点2.13】设置 appState.llm.user 和 appState.currentPartnerRole = role
  - role.avatarAppId  // ← 数字人参数：存储在对象中，未使用
  - role.avatarAppSecret  // ← 数字人参数：存储在对象中，未使用
  ↓
【节点2.14】应用大模型配置（不处理数字人参数）
  ↓
【节点2.15】handleSaveConfig() → 保存到 localStorage（只保存大模型参数）
  ↓
【节点2.16】loadRoles() → 从数据库获取伙伴角色列表
  ↓
【节点2.17】loadHistory() → 加载对话历史（大模型参数相关）
  ↓
【节点2.18】触发 roleUpdated 事件
  ↓
【最终状态】数字人参数存储在 appState.currentPartnerRole 对象中，等待连接时使用
```

---

## 2.4 数字人连接使用参数

### 连接按钮点击

```typescript
// ConfigPanel.vue - handleConnectRoleFromList() (约第1812行)
async function handleConnectRoleFromList(role: Role) {
  // ... 基础验证 ...
  
  // 【节点2.19】获取或创建渲染器（使用角色的数字人参数）
  let renderer = rendererManager.getRenderer(partnerRoleId)
  if (!renderer) {
    // 【节点2.20】创建渲染器（传入数字人参数）
    renderer = await rendererManager.createRenderer(partnerRoleId, {
      roleId: partnerRoleId,
      roleType: 'digital_human',
      positionX: role.positionX !== undefined ? role.positionX : 50,
      positionY: role.positionY !== undefined ? role.positionY : 50,
      scale: role.scale !== undefined ? role.scale : 1.0,
      avatarAppId: role.avatarAppId,        // ← 数字人参数：avatarAppId（从角色对象中获取）
      avatarAppSecret: role.avatarAppSecret  // ← 数字人参数：avatarAppSecret（从角色对象中获取）
    })
  }
  
  // ... 检查容器 ...
  
  // 【节点2.21】连接数字人（使用渲染器配置中的数字人参数）
  if (renderer.connect) {
    await renderer.connect()
    // renderer.connect() 内部：
    //   - 从 renderer.config 中获取 avatarAppId 和 avatarAppSecret
    //   - 调用 avatarService.connect({ appId, appSecret }, callbacks, containerId)
    //   - avatarService.connect() 使用这些参数初始化SDK实例
  }
}
```

```typescript
// src/renderers/digital-human/DigitalHumanRenderer.ts - connect() (约第41行)
async connect(): Promise<void> {
  // ... 验证配置 ...
  
  const config = this.config as DigitalHumanRendererConfig
  
  // 【节点2.22】从渲染器配置中获取数字人参数
  if (!config.avatarAppId || !config.avatarAppSecret) {
    throw new Error('数字人 App ID 和 App Secret 未配置')
  }
  
  // ... 验证容器 ...
  
  // 【节点2.23】调用服务连接数字人（传入数字人参数）
  this.instance = await this.service.connect(
    {
      appId: config.avatarAppId,        // ← 数字人参数：avatarAppId
      appSecret: config.avatarAppSecret // ← 数字人参数：avatarAppSecret
    },
    this.callbacks,
    this.containerId
  )
}
```

```typescript
// src/services/avatar.ts - connect() (约第39行)
async connect(config: AvatarConfig, callbacks: AvatarCallbacks, containerId?: string): Promise<any> {
  const { appId, appSecret } = config  // ← 数字人参数：从 config 中获取
  
  // ... 验证SDK和容器 ...
  
  // 【节点2.24】初始化SDK实例（使用数字人参数）
  const instanceTTSA = new window.XmovAvatar.TTSA({
    appId: appId,        // ← 数字人参数：avatarAppId
    appSecret: appSecret // ← 数字人参数：avatarAppSecret
  })
  
  // ... 连接逻辑 ...
}
```

### 数据流路径

```
【连接按钮点击】
  ↓
【节点2.19】获取或创建渲染器
  ↓
【节点2.20】创建渲染器（从角色对象中获取数字人参数）：
  - avatarAppId: role.avatarAppId
  - avatarAppSecret: role.avatarAppSecret
  ↓
【节点2.21】renderer.connect()
  ↓
【节点2.22】从渲染器配置中获取数字人参数：
  - config.avatarAppId
  - config.avatarAppSecret
  ↓
【节点2.23】调用 avatarService.connect({ appId, appSecret }, callbacks, containerId)
  ↓
【节点2.24】初始化SDK实例（使用数字人参数）：
  - new XmovAvatar.TTSA({ appId, appSecret })
  ↓
【最终状态】数字人SDK实例已连接
```

---

# 三、两套参数的独立性

## 3.1 参数存储独立性

**大模型参数：**
- 存储在：`appState.llm.baseURL`、`appState.llm.model`、`appState.llm.apiKey`、`appState.llm.user`
- 数据库：`user_roles.baseURL`、`user_roles.model`、`user_roles.apiKey`
- 数据库：`roles.baseURL`、`roles.model`、`roles.apiKey`、`roles.user`

**数字人参数：**
- 存储在：角色对象中（`appState.currentUserRole.avatarAppId`、`appState.currentUserRole.avatarAppSecret`）
- 数据库：`user_roles.avatarAppId`、`user_roles.avatarAppSecret`
- 数据库：`roles.avatarAppId`、`roles.avatarAppSecret`
- 渲染器配置：`DigitalHumanRendererConfig.avatarAppId`、`DigitalHumanRendererConfig.avatarAppSecret`

**独立性：**
- ✅ 两套参数在数据库中是独立的字段
- ✅ 两套参数在全局状态中是独立的存储位置
- ✅ 两套参数在角色对象中是独立的属性

---

## 3.2 参数使用独立性

**大模型参数使用：**
- 只在 `appStore.sendMessage()` → `llmService.sendMessageWithStream()` 中使用
- 只在 `saveChatMessage()` 中使用（用于用户隔离和对话历史隔离）
- 不在数字人连接相关代码中使用

**数字人参数使用：**
- 只在 `renderer.connect()` → `avatarService.connect()` 中使用
- 只在创建渲染器时使用（`rendererManager.createRenderer()`）
- 不在大模型调用相关代码中使用

**独立性：**
- ✅ 大模型调用不依赖数字人参数
- ✅ 数字人连接不依赖大模型参数
- ✅ 两套参数完全独立，互不影响

---

## 3.3 参数更新独立性

**大模型参数更新：**
- 在 `loadUserRoles()` 中更新（入口1和入口2）
- 在 `handleSetCurrentUserRole()` 中更新（入口2）
- 在 `handleSetCurrentRole()` 中更新（入口2）
- 不在数字人连接相关代码中更新

**数字人参数更新：**
- 在创建渲染器时从角色对象中获取（连接按钮点击）
- 在 `setupPartnerDigitalHumanRenderer()` 中从角色对象中获取（watch 监听）
- 在 `setupUserDigitalHumanRenderer()` 中从角色对象中获取（watch 监听）
- 不在大模型调用相关代码中更新

**独立性：**
- ✅ 大模型参数更新不影响数字人参数
- ✅ 数字人参数更新不影响大模型参数
- ✅ 两套参数更新完全独立

---

# 四、数据流节点汇总

## 4.1 大模型参数数据流节点

### 入口1：APIKey登录后
- 【节点1.1】设置 `appState.llm.apiKey = globalApiKey.value`
- 【节点1.2】`loadUserRoles()` → 从数据库获取用户角色列表
- 【节点1.3】应用用户角色的大模型配置：`appState.llm.baseURL`、`appState.llm.model`、`appState.llm.apiKey`
- 【节点1.4】`loadRoles()` → 从数据库获取伙伴角色列表
- 【节点1.5】`getAndSetCurrentPartnerRole()` → 从 localStorage 恢复或设置
- 【节点1.6】设置 `appState.llm.user = config.llm.user`
- 【节点1.7】`loadHistory()` → 使用 `appState.llm.apiKey` 和 `appState.llm.user` 加载对话历史
- 【节点1.8】触发 `roleUpdated` 事件

### 入口2：切换角色时
- 【节点2.1】`setCurrentUserRole()` → 更新数据库中的 `isCurrent` 字段
- 【节点2.2】`loadUserRoles()` → 从数据库获取用户角色列表
- 【节点2.3】应用用户角色的大模型配置：`appState.llm.baseURL`、`appState.llm.model`、`appState.llm.apiKey`
- 【节点2.4】`appState.currentUserRole = role`
- 【节点2.5】再次确认大模型配置（从 `role` 对象直接设置）
- 【节点2.6】`handleSaveConfig()` → 保存到 localStorage
- 【节点2.7】触发 `roleUpdated` 事件
- 【节点2.8】设置 `appState.llm.user = role.user`
- 【节点2.9】应用角色的大模型配置：`appState.llm.baseURL`、`appState.llm.model`、`appState.llm.apiKey`
- 【节点2.10】`handleSaveConfig()` → 保存到 localStorage
- 【节点2.11】`loadRoles()` → 从数据库获取伙伴角色列表
- 【节点2.12】`loadHistory()` → 使用 `appState.llm.apiKey` 和 `appState.llm.user` 加载对话历史
- 【节点2.13】触发 `roleUpdated` 事件

### 大模型调用使用
- 【节点1.9】`appStore.sendMessage()` → 调用 `llmService.sendMessageWithStream({ baseURL, model, apiKey, user })`
- 【节点1.10】`saveChatMessage()` → 使用 `llm.apiKey` 和 `llm.user` 保存对话历史
- 【节点1.11】`llmService.initClient()` → 使用 `config.baseURL` 和 `config.apiKey` 初始化 OpenAI 客户端
- 【节点1.12】`llmService.sendMessageWithStream()` → 使用 `config.model` 和 `config.user` 调用大模型API

---

## 4.2 数字人参数数据流节点

### 入口1：APIKey登录后
- 【节点2.1】设置 `appState.llm.apiKey`（大模型参数，与数字人无关）
- 【节点2.2】`loadUserRoles()` → 从数据库获取用户角色列表
- 【节点2.2.1】`appState.currentUserRole = currentRole`（数字人参数存储在对象中，未使用）
- 【节点2.3】`loadRoles()` → 从数据库获取伙伴角色列表
- 【节点2.3.1】`roles.value = roleList`（数字人参数存储在对象中，未使用）
- 【节点2.4】`getAndSetCurrentPartnerRole()` → 设置 `appState.llm.user`（大模型参数）
- 【节点2.5】`loadHistory()` → 加载对话历史（大模型参数相关）
- 【节点2.6】触发 `roleUpdated` 事件（数字人参数存储在角色对象中，等待连接时使用）

### 入口2：切换角色时
- 【节点2.7】`setCurrentUserRole()` → 更新数据库中的 `isCurrent` 字段
- 【节点2.8】`loadUserRoles()` → 从数据库获取用户角色列表
- 【节点2.9】`appState.currentUserRole = role`（数字人参数存储在对象中，未使用）
- 【节点2.10】应用大模型配置（不处理数字人参数）
- 【节点2.11】`handleSaveConfig()` → 保存到 localStorage（只保存大模型参数）
- 【节点2.12】触发 `roleUpdated` 事件（数字人参数存储在角色对象中，等待连接时使用）
- 【节点2.13】设置 `appState.llm.user` 和 `appState.currentPartnerRole = role`（数字人参数存储在对象中，未使用）
- 【节点2.14】应用大模型配置（不处理数字人参数）
- 【节点2.15】`handleSaveConfig()` → 保存到 localStorage（只保存大模型参数）
- 【节点2.16】`loadRoles()` → 从数据库获取伙伴角色列表
- 【节点2.17】`loadHistory()` → 加载对话历史（大模型参数相关）
- 【节点2.18】触发 `roleUpdated` 事件（数字人参数存储在角色对象中，等待连接时使用）

### 数字人连接使用
- 【节点2.19】获取或创建渲染器
- 【节点2.20】创建渲染器（从角色对象中获取数字人参数）：`avatarAppId: role.avatarAppId`、`avatarAppSecret: role.avatarAppSecret`
- 【节点2.21】`renderer.connect()`
- 【节点2.22】从渲染器配置中获取数字人参数：`config.avatarAppId`、`config.avatarAppSecret`
- 【节点2.23】调用 `avatarService.connect({ appId, appSecret }, callbacks, containerId)`
- 【节点2.24】初始化SDK实例（使用数字人参数）：`new XmovAvatar.TTSA({ appId, appSecret })`

---

# 五、关键原则总结

## 5.1 两套参数完全独立

**大模型参数：**
- 存储在 `appState.llm` 中
- 在登录和切换角色时更新
- 在大模型调用时使用
- 不依赖数字人参数

**数字人参数：**
- 存储在角色对象中（`appState.currentUserRole`、`appState.currentPartnerRole`）
- 在连接时从角色对象中获取
- 在数字人连接时使用
- 不依赖大模型参数

## 5.2 两个入口的处理方式

**入口1：APIKey登录后**
- 大模型参数：立即设置到 `appState.llm`
- 数字人参数：存储在角色对象中，等待连接时使用

**入口2：切换角色时**
- 大模型参数：立即设置到 `appState.llm`
- 数字人参数：存储在角色对象中，等待连接时使用

## 5.3 参数使用时机

**大模型参数：**
- 使用时机：每次调用 `appStore.sendMessage()` 时
- 使用位置：`llmService.sendMessageWithStream()` 和 `saveChatMessage()`

**数字人参数：**
- 使用时机：点击连接按钮时
- 使用位置：`renderer.connect()` → `avatarService.connect()` → `new XmovAvatar.TTSA()`

