# 数字人重构前代码清理执行方案

## 一、清理原则

### 1.1 核心原则

**不打补丁、不兼容、错误直接暴露、干净重构**

- ✅ **不打补丁**：不保留旧代码，不兼容旧逻辑，直接删除
- ✅ **不兼容**：不保留向后兼容代码，错误直接暴露
- ✅ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ✅ **干净重构**：确保重构前清理干净，避免新旧代码混在一起导致联动问题

### 1.2 清理目标

**数字人的业务逻辑与立绘完全一致：**
- ✅ 容器在模板中定义，使用 `v-if` 控制显示
- ✅ 当角色变化时，容器自动创建/销毁
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接，容器销毁时自动断开
- ✅ **所有入口不需要任何数字人特殊处理代码**（除了连接按钮）

**两套参数完全独立：**
- ✅ 大模型参数（`baseURL`、`model`、`apiKey`、`user`）存储在 `appState.llm` 中
- ✅ 数字人参数（`avatarAppId`、`avatarAppSecret`）存储在角色对象中
- ✅ 两套参数互不依赖，各不干扰

---

## 二、需要清理的代码位置

### 2.1 ConfigPanel.vue - 入口函数清理

#### 位置1：`handleSetCurrentUserRole()` 函数（约第3157-3200行）

**需要删除的代码：**
```typescript
// 删除：切换时清理之前的数字人连接和容器（约第3159-3177行）
if (appState.currentUserRole) {
  const oldUserRoleId = `user:${appState.currentUserRole.id}`
  const oldRenderer = rendererManager.getRenderer(oldUserRoleId)
  if (oldRenderer) {
    // 断开连接
    if (oldRenderer.disconnect) {
      await oldRenderer.disconnect()
    }
    // 隐藏数字人
    oldRenderer.hide()
    appState.avatar.showUserDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(oldUserRoleId)
    appState.avatar.connectedRoles.delete(oldUserRoleId)
    // 销毁渲染器和容器
    rendererManager.destroyRenderer(oldUserRoleId)
  }
}
```

**删除原因：**
- ❌ 容器在模板中定义，通过 `v-if` 自动销毁，不需要手动清理
- ❌ SDK连接逻辑在 `watch` 中处理，容器销毁时自动断开，不需要手动断开
- ❌ 手动清理会导致与 `v-if` 冲突，引发联动问题
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 函数只负责设置当前用户角色和应用大模型配置
- ✅ 不涉及数字人相关代码

---

#### 位置2：`handleSetCurrentRole()` 函数（约第3719-3767行）

**需要删除的代码：**
```typescript
// 删除：切换时清理之前的数字人连接和容器（约第3720-3738行）
if (appState.llm.user) {
  const oldPartnerRoleId = `partner:${appState.llm.user}`
  const oldRenderer = rendererManager.getRenderer(oldPartnerRoleId)
  if (oldRenderer) {
    // 断开连接
    if (oldRenderer.disconnect) {
      await oldRenderer.disconnect()
    }
    // 隐藏数字人
    oldRenderer.hide()
    appState.avatar.showPartnerDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(oldPartnerRoleId)
    appState.avatar.connectedRoles.delete(oldPartnerRoleId)
    // 销毁渲染器和容器
    rendererManager.destroyRenderer(oldPartnerRoleId)
  }
}
```

**需要添加的代码：**
```typescript
// 添加：设置 appState.currentPartnerRole
appState.currentPartnerRole = role
```

**删除原因：** 同位置1

**清理后：**
- ✅ 函数只负责设置当前伙伴角色和应用大模型配置
- ✅ 不涉及数字人相关代码

---

#### 位置3：`getAndSetCurrentPartnerRole()` 函数（约第3527-3553行）

**需要添加的代码：**
```typescript
// 在设置 appState.llm.user 后，添加：
if (config.llm && config.llm.user) {
  const roleExists = roles.value.some(r => r.user === config.llm.user)
  if (roleExists) {
    appState.llm.user = config.llm.user
    // 添加：同时设置 appState.currentPartnerRole
    appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user) || null
    console.log('已恢复当前伙伴角色:', config.llm.user)
    return true
  }
}
```

**修改原因：**
- ⚠️ 当前实现只设置了 `appState.llm.user`，未设置 `appState.currentPartnerRole`
- ⚠️ 需要确保两个状态同步

---

### 2.2 ConfigPanel.vue - 连接函数清理

#### 位置4：`handleConnectRoleFromList()` 函数（约第1812-2000行）

**需要删除的代码：**

1. **动态创建容器的代码：**
```typescript
// 删除：动态创建容器的所有代码
const roleIdHash = toMd5(partnerRoleId)
const containerId = `digital-human-${roleIdHash}`

// 检查容器是否已存在
let containerElement = document.getElementById(containerId)
if (!containerElement) {
  // 实时创建容器
  containerElement = document.createElement('div')
  containerElement.id = containerId
  containerElement.className = 'sdk-container'
  containerElement.style.position = 'fixed'
  containerElement.style.left = `${role.positionX !== undefined ? role.positionX : 50}%`
  containerElement.style.top = `${role.positionY !== undefined ? role.positionY : 50}%`
  containerElement.style.transform = `translate(-50%, -50%) scale(${role.scale !== undefined ? role.scale : 1.0})`
  containerElement.style.width = '512px'
  containerElement.style.height = '768px'
  containerElement.style.zIndex = '100'
  containerElement.style.pointerEvents = 'auto'
  // ... 所有样式设置
  avatarRender.appendChild(containerElement)
}
```

2. **设置显示状态的代码：**
```typescript
// 删除：设置显示状态
appState.avatar.showPartnerDigitalHuman = true
```

3. **更新渲染器配置的代码（如果存在）：**
```typescript
// 删除：更新渲染器配置
if (config.avatarAppId !== role.avatarAppId || config.avatarAppSecret !== role.avatarAppSecret) {
  await renderer.updateConfig({
    avatarAppId: role.avatarAppId,
    avatarAppSecret: role.avatarAppSecret,
    // ...
  })
}
```

**需要修改的代码：**
```typescript
// 修改：使用固定容器ID
const containerId = 'digital-human-partner' // 固定ID，不再使用MD5哈希

// 检查容器是否存在
const containerElement = document.getElementById(containerId)
if (!containerElement) {
  // 错误直接暴露：如果容器不存在，直接报错
  showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
  isConnecting.value = false
  return
}
```

**删除原因：**
- ❌ 容器在模板中定义，不应该动态创建
- ❌ 动态创建导致无法使用Vue的响应式系统
- ❌ 动态创建导致无法直接绑定事件
- ❌ 设置显示状态会导致与 `v-if` 冲突，引发联动问题
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 使用固定容器ID `digital-human-partner`
- ✅ 连接时直接使用 `document.getElementById('digital-human-partner')`
- ✅ 如果容器不存在，直接报错（错误直接暴露）
- ✅ 不设置显示状态（显示状态由 `v-if` 控制）

---

#### 位置5：`handleConnectUserRoleFromList()` 函数（约第2036-2223行）

**需要删除的代码：** 同位置4，只是：
- 容器ID改为 `digital-human-user`
- 变量名改为 `userRoleId`

**清理后：**
- ✅ 使用固定容器ID `digital-human-user`
- ✅ 连接时直接使用 `document.getElementById('digital-human-user')`
- ✅ 如果容器不存在，直接报错（错误直接暴露）
- ✅ 不设置显示状态（显示状态由 `v-if` 控制）

---

### 2.3 ConfigPanel.vue - 历史面板头像点击清理

#### 位置6：`toggleIllustration()` 函数（约第3312-3350行）

**需要修改的代码：**
```typescript
// 当前代码可能存在的问题：
// 1. 可能调用了 renderer.show() 或 renderer.hide()
// 2. 可能手动设置了容器的 display 样式
// 3. 可能 roleId 写错了（用户角色应该是 `user:${currentUserRole.id}`，不是 `'user'`）

// 修改为：
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 数字人：检查是否已连接
      const roleId = `user:${currentUserRole.id}` // 注意：不是 'user'
      const renderer = rendererManager.getRenderer(roleId)
      if (!renderer) {
        // 未连接：提示在角色面板连接
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      // 已连接：切换显示/隐藏（通过 v-if 自动响应）
      appState.avatar.showUserDigitalHuman = !appState.avatar.showUserDigitalHuman
    } else {
      // 立绘：显示/隐藏（不修改立绘代码）
      showUserIllustration.value = !showUserIllustration.value
    }
  } else {
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      // 数字人：检查是否已连接
      const roleId = `partner:${partnerRole.user}`
      const renderer = rendererManager.getRenderer(roleId)
      if (!renderer) {
        // 未连接：提示在角色面板连接
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      // 已连接：切换显示/隐藏（通过 v-if 自动响应）
      appState.avatar.showPartnerDigitalHuman = !appState.avatar.showPartnerDigitalHuman
    } else {
      // 立绘：显示/隐藏（不修改立绘代码）
      showPartnerIllustration.value = !showPartnerIllustration.value
    }
  }
}
```

**删除原因：**
- ❌ 不应该调用 `renderer.show()` 或 `renderer.hide()`（显示/隐藏由 `v-if` 控制）
- ❌ 不应该手动设置容器的 `display` 样式（显示/隐藏由 `v-if` 控制）
- ❌ 不应该在未连接时自动连接（连接是独立行为）

**清理后：**
- ✅ 只切换显示状态（`appState.avatar.showUserDigitalHuman` 或 `appState.avatar.showPartnerDigitalHuman`）
- ✅ 显示/隐藏由 `v-if` 自动响应
- ✅ 不涉及连接/断开逻辑

---

#### 位置7：`getToggleIllustrationTitle()` 函数（约第3353-3379行）

**需要修改的代码：**
```typescript
// 当前代码可能存在的问题：
// 用户角色的 roleId 写成了 'user'，应该是 `user:${currentUserRole.id}`

// 修改为：
function getToggleIllustrationTitle(role: 'user' | 'assistant'): string {
  if (role === 'user') {
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 【注意】roleId 应该是 `user:${currentUserRole.id}`，不是 `'user'`
      const roleId = `user:${currentUserRole.id}`
      if (!appState.avatar.connectedRoles.has(roleId)) {
        return '显示数字人（未连接）'
      }
      return appState.avatar.showUserDigitalHuman ? '隐藏数字人' : '显示数字人'
    } else {
      return showUserIllustration.value ? '隐藏用户立绘' : '显示用户立绘'
    }
  } else {
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      const roleId = `partner:${partnerRole.user}`
      if (!appState.avatar.connectedRoles.has(roleId)) {
        return '显示数字人（未连接）'
      }
      return appState.avatar.showPartnerDigitalHuman ? '隐藏数字人' : '显示数字人'
    } else {
      return showPartnerIllustration.value ? '隐藏伙伴立绘' : '显示伙伴立绘'
    }
  }
}
```

**修改原因：**
- ⚠️ 用户角色的 `roleId` 写错了，应该是 `user:${currentUserRole.id}`，不是 `'user'`

---

### 2.4 AvatarRender.vue - 渲染器设置清理

#### 位置8：`setupPartnerDigitalHumanRenderer()` 函数（约第156-220行）

**需要删除的代码：**

1. **清理旧容器DOM元素的代码：**
```typescript
// 删除：清理旧容器DOM元素的代码
const roleIdHash = toMd5(roleId)
const oldContainerId = `digital-human-${roleIdHash}`
const oldContainer = document.getElementById(oldContainerId)
if (oldContainer) {
  oldContainer.remove()
}
```

2. **手动查找容器并设置display的代码：**
```typescript
// 删除：如果已连接，手动查找容器并设置display的代码
if (appState.avatar.connectedRoles.has(roleIdForState)) {
  const roleIdHash = toMd5(roleIdForState)
  const containerId = `digital-human-${roleIdHash}`
  const containerElement = document.getElementById(containerId)
  if (containerElement) {
    await renderer.render(containerElement)
    // 删除：手动设置display
    containerElement.style.display = appState.avatar.showPartnerDigitalHuman ? 'flex' : 'none'
  }
}
```

**删除原因：**
- ❌ 容器应该在模板中定义，不应该手动创建或删除
- ❌ 显示/隐藏应该通过 `v-if` 控制，不应该手动设置 `display` 样式
- ❌ 手动控制 `display` 导致与 `v-if` 冲突，引发联动问题

**清理后：**
- ✅ 容器在模板中定义，使用固定ID `digital-human-partner`
- ✅ 显示/隐藏通过 `v-if` 控制，不需要手动设置 `display`
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

---

#### 位置9：`setupUserDigitalHumanRenderer()` 函数（约第223-313行）

**需要删除的代码：** 同位置8，只是：
- 容器ID改为 `digital-human-user`
- 变量名改为 `userRoleId`

**清理后：** 同位置8，使用固定ID `digital-human-user`

---

#### 位置10：`watch(() => appState.avatar.showPartnerDigitalHuman)`（约第343-353行）

**需要删除的代码：**
```typescript
// 删除：手动控制容器display的watch
watch(() => appState.avatar.showPartnerDigitalHuman, (visible) => {
  if (appState.currentPartnerRole && appState.currentPartnerRole.type === 'digital_human') {
    const roleId = `partner:${appState.currentPartnerRole.user}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const containerElement = document.getElementById(containerId)
    if (containerElement) {
      containerElement.style.display = visible ? 'flex' : 'none'
    }
  }
})
```

**删除原因：**
- ❌ 显示/隐藏应该通过 `v-if` 控制，不应该手动设置 `display`
- ❌ 手动设置 `display` 与 `v-if` 冲突，导致联动问题
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 显示/隐藏通过 `v-if` 控制，不需要手动设置 `display`
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

---

#### 位置11：`watch(() => appState.avatar.showUserDigitalHuman)`（约第355-365行）

**需要删除的代码：** 同位置10

**清理后：** 同位置10

---

### 2.5 AvatarRender.vue - 拖拽函数清理

#### 位置12：`handleDrag()` 函数中手动更新数字人容器位置的代码（约第729-757行）

**需要删除的代码：**
```typescript
// 删除：手动更新数字人容器位置的代码
} else if (dragType.value === 'partnerDigitalHuman') {
  draggingPartnerPositionX.value = newPositionX
  draggingPartnerPositionY.value = newPositionY
  // 删除以下代码：
  if (appState.currentPartnerRole) {
    const roleId = `partner:${appState.currentPartnerRole.user}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const container = document.getElementById(containerId)
    if (container) {
      container.style.left = `${newPositionX}%`
      container.style.top = `${newPositionY}%`
    }
  }
} else if (dragType.value === 'userDigitalHuman') {
  draggingUserPositionX.value = newPositionX
  draggingUserPositionY.value = newPositionY
  // 删除以下代码：
  if (appState.currentUserRole) {
    const roleId = `user:${appState.currentUserRole.id}`
    const roleIdHash = toMd5(roleId)
    const containerId = `digital-human-${roleIdHash}`
    const container = document.getElementById(containerId)
    if (container) {
      container.style.left = `${newPositionX}%`
      container.style.top = `${newPositionY}%`
    }
  }
}
```

**删除原因：**
- ❌ 位置应该通过计算属性 `partnerAvatarPositionStyle` 和 `userAvatarPositionStyle` 自动更新
- ❌ 手动更新样式不响应式，导致拖拽时位置不同步
- ❌ 这是导致数字人联动问题的根源之一

**清理后：**
- ✅ 位置通过计算属性自动更新，不需要手动设置
- ✅ 拖拽时只需要更新 `draggingPartnerPositionX` 和 `draggingPartnerPositionY`，计算属性会自动响应

---

### 2.6 DigitalHumanRenderer.ts - 容器ID生成清理

#### 位置13：`DigitalHumanRenderer` 构造函数（约第25-26行）

**需要修改的代码：**
```typescript
// 当前代码：
const roleIdHash = toMd5(config.roleId)
this.containerId = `digital-human-${roleIdHash}`

// 修改为：
// 不再在渲染器中生成容器ID，容器ID在模板中固定
// 伙伴数字人：'digital-human-partner'
// 用户数字人：'digital-human-user'
// 渲染器不再需要 containerId 属性，或者改为从外部传入
```

**修改原因：**
- ❌ 容器ID应该固定，不应该动态生成
- ❌ MD5哈希不再需要，简化代码

**清理后：**
- ✅ 容器ID固定，渲染器从外部传入容器ID（或通过配置传入）
- ✅ 简化代码，移除MD5哈希相关逻辑

---

### 2.7 其他文件 - MD5哈希清理

#### 位置14：所有 `toMd5` 相关的导入和使用

**需要删除的代码：**
```typescript
// 删除：所有 toMd5 相关的导入
import { toMd5 } from '@/utils/md5'

// 删除：所有 toMd5 的调用
const roleIdHash = toMd5(roleId)
const containerId = `digital-human-${roleIdHash}`
```

**删除原因：**
- ❌ 容器ID固定，不再需要MD5哈希
- ❌ 简化代码，减少依赖

**清理后：**
- ✅ 不再需要 `toMd5` 函数
- ✅ 所有容器ID改为固定值

---

## 三、清理执行步骤

### 3.1 第一步：清理入口函数（ConfigPanel.vue）

**目标：** 删除两个入口函数中的数字人清理代码

**步骤：**
1. 打开 `src/components/ConfigPanel.vue`
2. 找到 `handleSetCurrentUserRole()` 函数（约第3157行）
3. 删除约第3159-3177行的数字人清理代码
4. 找到 `handleSetCurrentRole()` 函数（约第3719行）
5. 删除约第3720-3738行的数字人清理代码
6. 在 `handleSetCurrentRole()` 中添加 `appState.currentPartnerRole = role`
7. 找到 `getAndSetCurrentPartnerRole()` 函数（约第3527行）
8. 添加设置 `appState.currentPartnerRole` 的代码

**验证：**
- [ ] 运行代码，确保切换角色时不会报错
- [ ] 检查是否还有手动清理数字人的代码

---

### 3.2 第二步：清理连接函数（ConfigPanel.vue）

**目标：** 删除连接函数中的动态创建容器和设置显示状态的代码

**步骤：**
1. 找到 `handleConnectRoleFromList()` 函数（约第1812行）
2. 删除所有动态创建容器的代码
3. 删除设置 `appState.avatar.showPartnerDigitalHuman = true` 的代码
4. 删除更新渲染器配置的代码（如果存在）
5. 修改为使用固定容器ID `digital-human-partner`
6. 找到 `handleConnectUserRoleFromList()` 函数（约第2036行）
7. 执行相同的清理操作，使用固定容器ID `digital-human-user`

**验证：**
- [ ] 运行代码，确保连接时不会报错（即使容器不存在也应该直接报错）
- [ ] 检查是否还有动态创建容器的代码
- [ ] 检查是否还有设置显示状态的代码

---

### 3.3 第三步：清理历史面板头像点击（ConfigPanel.vue）

**目标：** 修复 `toggleIllustration()` 和 `getToggleIllustrationTitle()` 函数

**步骤：**
1. 找到 `toggleIllustration()` 函数（约第3312行）
2. 确保只切换显示状态，不调用 `renderer.show()` 或 `renderer.hide()`
3. 确保不手动设置容器的 `display` 样式
4. 确保用户角色的 `roleId` 是 `user:${currentUserRole.id}`，不是 `'user'`
5. 找到 `getToggleIllustrationTitle()` 函数（约第3353行）
6. 修复用户角色的 `roleId` 错误

**验证：**
- [ ] 运行代码，确保点击头像时不会报错
- [ ] 检查是否还有调用 `renderer.show()` 或 `renderer.hide()` 的代码
- [ ] 检查是否还有手动设置 `display` 样式的代码

---

### 3.4 第四步：清理渲染器设置（AvatarRender.vue）

**目标：** 删除渲染器设置函数中的容器创建和手动控制display的代码

**步骤：**
1. 找到 `setupPartnerDigitalHumanRenderer()` 函数（约第156行）
2. 删除清理旧容器DOM元素的代码
3. 删除手动查找容器并设置display的代码
4. 找到 `setupUserDigitalHumanRenderer()` 函数（约第223行）
5. 执行相同的清理操作
6. 找到 `watch(() => appState.avatar.showPartnerDigitalHuman)`（约第343行）
7. 删除整个 watch 监听器
8. 找到 `watch(() => appState.avatar.showUserDigitalHuman)`（约第355行）
9. 删除整个 watch 监听器

**验证：**
- [ ] 运行代码，确保不会报错
- [ ] 检查是否还有手动创建/删除容器的代码
- [ ] 检查是否还有手动设置 `display` 样式的代码

---

### 3.5 第五步：清理拖拽函数（AvatarRender.vue）

**目标：** 删除 `handleDrag()` 函数中手动更新数字人容器位置的代码

**步骤：**
1. 找到 `handleDrag()` 函数（约第729行）
2. 找到 `dragType.value === 'partnerDigitalHuman'` 的分支
3. 删除手动更新容器位置的代码（`container.style.left` 和 `container.style.top`）
4. 保留更新 `draggingPartnerPositionX` 和 `draggingPartnerPositionY` 的代码
5. 找到 `dragType.value === 'userDigitalHuman'` 的分支
6. 执行相同的清理操作

**验证：**
- [ ] 运行代码，确保拖拽时不会报错
- [ ] 检查是否还有手动更新容器位置的代码

---

### 3.6 第六步：清理渲染器类（DigitalHumanRenderer.ts）

**目标：** 修改渲染器构造函数，移除MD5哈希逻辑

**步骤：**
1. 打开 `src/renderers/digital-human/DigitalHumanRenderer.ts`
2. 找到构造函数（约第25行）
3. 删除 `toMd5` 相关的代码
4. 修改 `containerId` 的生成逻辑，改为从外部传入或通过配置传入

**验证：**
- [ ] 运行代码，确保不会报错
- [ ] 检查是否还有MD5哈希相关的代码

---

### 3.7 第七步：清理MD5哈希依赖

**目标：** 删除所有 `toMd5` 相关的导入和使用

**步骤：**
1. 搜索整个项目，查找所有 `toMd5` 的使用
2. 删除所有 `import { toMd5 } from '@/utils/md5'` 的导入
3. 删除所有 `toMd5()` 的调用
4. 如果 `toMd5` 函数不再被使用，可以考虑删除 `src/utils/md5.ts` 文件

**验证：**
- [ ] 运行代码，确保不会报错
- [ ] 检查是否还有 `toMd5` 相关的代码

---

### 3.8 第八步：最终验证

**目标：** 确保所有清理工作完成，代码可以正常运行（即使有错误也应该直接暴露）

**验证清单：**
- [ ] 运行代码，确保所有错误直接暴露（不保留容错代码）
- [ ] 检查是否还有动态创建容器的代码
- [ ] 检查是否还有手动设置 `display` 的代码
- [ ] 检查是否还有手动更新位置的代码
- [ ] 检查是否还有MD5哈希相关的代码
- [ ] 检查是否还有手动清理数字人连接和容器的代码
- [ ] 检查是否还有设置显示状态的代码（连接函数中）
- [ ] 检查是否还有更新渲染器配置的代码（连接函数中）
- [ ] 检查是否还有调用 `renderer.show()` 或 `renderer.hide()` 的代码
- [ ] 检查是否还有在未连接时自动连接的代码

---

## 四、清理后的代码结构

### 4.1 清理后的代码应该：

1. ✅ **入口函数只处理大模型参数**：不涉及数字人相关代码
2. ✅ **连接函数只负责连接SDK**：不动态创建容器，不设置显示状态
3. ✅ **历史面板头像点击只切换显示状态**：不涉及连接/断开逻辑
4. ✅ **渲染器设置函数不创建容器**：容器在模板中定义
5. ✅ **拖拽函数只更新状态**：不手动更新容器位置
6. ✅ **渲染器类不生成容器ID**：容器ID固定，从外部传入

### 4.2 清理后的代码不应该有：

1. ❌ 动态创建容器的代码
2. ❌ 手动设置 `display` 样式的代码
3. ❌ 手动更新容器位置的代码
4. ❌ MD5哈希相关的代码
5. ❌ 手动清理数字人连接和容器的代码
6. ❌ 设置显示状态的代码（连接函数中）
7. ❌ 更新渲染器配置的代码（连接函数中）
8. ❌ 调用 `renderer.show()` 或 `renderer.hide()` 的代码

---

## 五、清理顺序建议

**建议的清理顺序：**
1. **第一步**：清理入口函数（ConfigPanel.vue）- 删除手动清理代码
2. **第二步**：清理连接函数（ConfigPanel.vue）- 删除动态创建容器和设置显示状态
3. **第三步**：清理历史面板头像点击（ConfigPanel.vue）- 修复函数逻辑
4. **第四步**：清理渲染器设置（AvatarRender.vue）- 删除容器创建和手动控制display
5. **第五步**：清理拖拽函数（AvatarRender.vue）- 删除手动更新位置
6. **第六步**：清理渲染器类（DigitalHumanRenderer.ts）- 移除MD5哈希逻辑
7. **第七步**：清理MD5哈希依赖 - 删除所有相关代码
8. **第八步**：最终验证 - 确保所有清理工作完成

**重要提示：**
- ⚠️ **不要保留旧代码**：删除所有不再需要的代码，不保留向后兼容
- ⚠️ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ⚠️ **不打补丁**：不要在新代码中保留旧逻辑，确保干净重构
- ⚠️ **逐步验证**：每完成一步，立即验证，确保不会引入新的问题

---

## 六、清理完成后的状态

### 6.1 代码状态

**清理完成后，代码应该处于以下状态：**
- ✅ 所有动态创建容器的代码已删除
- ✅ 所有手动设置 `display` 的代码已删除
- ✅ 所有手动更新位置的代码已删除
- ✅ 所有MD5哈希相关的代码已删除
- ✅ 所有手动清理数字人连接和容器的代码已删除
- ✅ 所有设置显示状态的代码（连接函数中）已删除
- ✅ 所有更新渲染器配置的代码（连接函数中）已删除
- ✅ 所有调用 `renderer.show()` 或 `renderer.hide()` 的代码已删除
- ✅ 所有在未连接时自动连接的代码已删除

### 6.2 功能状态

**清理完成后，功能可能暂时不可用（这是正常的）：**
- ⚠️ 数字人连接可能失败（因为容器还不存在）
- ⚠️ 数字人显示/隐藏可能不工作（因为 `v-if` 条件还不完整）
- ⚠️ 数字人拖拽可能不工作（因为容器还不存在）

**这是正常的，因为：**
- ✅ 容器还没有在模板中定义（这是重构的任务）
- ✅ `v-if` 条件还不完整（这是重构的任务）
- ✅ SDK连接逻辑还没有在 `watch` 中实现（这是重构的任务）

**清理的目标是：**
- ✅ 删除所有旧的、有问题的代码
- ✅ 为重构做好准备
- ✅ 确保重构时不会与旧代码冲突

---

## 七、总结

### 7.1 清理原则

**不打补丁、不兼容、错误直接暴露、干净重构**

### 7.2 清理目标

**数字人的业务逻辑与立绘完全一致，两套参数完全独立**

### 7.3 清理重点

1. **删除所有动态创建容器的代码**
2. **删除所有手动控制display的代码**
3. **删除所有手动更新位置的代码**
4. **删除所有MD5哈希相关的代码**
5. **删除所有手动清理数字人连接和容器的代码**
6. **删除所有设置显示状态的代码（连接函数中）**
7. **删除所有更新渲染器配置的代码（连接函数中）**

### 7.4 清理后的好处

1. ✅ **代码简洁**：删除所有不必要的代码
2. ✅ **错误直接暴露**：删除容错代码，问题更容易发现
3. ✅ **为重构做好准备**：清理干净，重构时不会与旧代码冲突
4. ✅ **解决联动问题**：通过清理所有动态创建和手动控制的代码，彻底解决数字人联动问题

