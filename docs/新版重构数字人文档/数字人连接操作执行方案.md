# 数字人连接操作执行方案

## 一、目标

**干净实现点击数字人列表中的"连接"按钮，可以在主页面显示数字人，用户和伙伴数字人互不干扰。**

**不涉及拖拽功能。**

---

## 二、完整数据流（闭环）

### 2.1 完整数据流路径

#### 路径1：用户登录后 → 连接数字人

```
【入口1：用户登录后获取当前用户和伙伴角色】
  ↓
【步骤1.1：加载用户角色列表】
  - loadUserRoles() → 从数据库获取用户角色列表
  - 查找 isCurrent === true 的角色
  - 设置 appState.currentUserRole = currentRole
  ↓
【步骤1.2：加载伙伴角色列表】
  - loadRoles() → 从数据库获取伙伴角色列表
  - 设置 roles.value = roleList
  ↓
【步骤1.3：获取并设置当前伙伴角色】
  - getAndSetCurrentPartnerRole() → 从 localStorage 恢复或设置
  - 设置 appState.llm.user = config.llm.user
  - 设置 appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user)
  ↓
【步骤1.4：记录当前角色并激活】
  - appState.currentUserRole = currentRole（已设置）
  - 调用 activateUserRole(currentRole) 激活用户角色
  - appState.currentPartnerRole = role（已设置）
  - 调用 activatePartnerRole(role) 激活伙伴角色
  ↓
【步骤1.5：更新连接按钮可用状态】
  - 触发 roleUpdated 事件
  - 连接按钮的 disabled 状态通过计算属性自动更新：
    - 只有当前角色可以连接
    - 只有数字人类型的角色可以连接
  ↓
【用户点击列表"连接"按钮】
  ↓
【步骤2.1：基础验证】
  - 检查是否正在连接
  - 检查SDK是否已加载
  - 检查角色是否配置了 avatarAppId 和 avatarAppSecret
  - 检查该角色是否已连接
  - 检查该角色是否为当前角色（依赖步骤1.4的记录）
  - 检查当前角色类型是否为数字人
  ↓
【步骤2.2：获取或创建渲染器】
  - 从角色对象中获取数字人参数：
    - avatarAppId: role.avatarAppId
    - avatarAppSecret: role.avatarAppSecret
  - 创建渲染器，传入数字人参数和固定容器ID
  ↓
【步骤2.3：检查容器是否存在】
  - 使用固定容器ID查找容器：
    - 伙伴数字人：digital-human-partner
    - 用户数字人：digital-human-user
  ↓
【步骤2.4：设置回调函数】
  - 设置字幕显示、状态变化等回调
  ↓
【步骤2.5：连接SDK并显示数字人】
  - renderer.connect() → 使用渲染器配置中的数字人参数
  - renderer.render(containerElement) → 渲染到容器（将数字人显示在页面容器中）
  - 保存实例到 appState.avatar.instances
  - 记录连接状态到 appState.avatar.connectedRoles
  - 设置显示状态：appState.avatar.showPartnerDigitalHuman = true 或 appState.avatar.showUserDigitalHuman = true
  ↓
【最终状态】
  - SDK已连接
  - 渲染器已创建
  - 数字人显示在页面容器中
  - 连接按钮可用状态已更新（显示"已连接"或"断开"）
```

#### 路径2：切换角色时 → 清理旧连接 → 连接新数字人

```
【入口2：切换的时候更新当前角色】
  ↓
【步骤3.1：失活旧角色】
  - 调用 deactivateUserRole(oldRole) 或 deactivatePartnerRole(oldRole)
  - 失活函数内部会：
    - 如果是数字人：断开连接、隐藏显示、清理状态、销毁渲染器
    - 如果是立绘：隐藏显示、清理状态
  ↓
【步骤3.2：设置当前角色（调用API）】
  - setCurrentUserRole() 或 直接设置 appState.llm.user
  ↓
【步骤3.3：重新加载角色列表】
  - loadUserRoles() 或 loadRoles() → 从数据库获取最新角色列表
  ↓
【步骤3.4：更新当前角色标识并激活新角色】
  - appState.currentUserRole = role（用户角色）
  - 调用 activateUserRole(role) 激活用户角色
  - appState.currentPartnerRole = role（伙伴角色）
  - 调用 activatePartnerRole(role) 激活伙伴角色
  ↓
【步骤3.5：更新连接按钮可用状态】
  - 触发 roleUpdated 事件
  - 连接按钮的 disabled 状态通过计算属性自动更新：
    - 只有当前角色可以连接
    - 只有数字人类型的角色可以连接
  ↓
【用户点击列表"连接"按钮】
  ↓
【步骤4.1：基础验证】（同路径1的步骤2.1）
  ↓
【步骤4.2：获取或创建渲染器】（同路径1的步骤2.2）
  ↓
【步骤4.3：检查容器是否存在】（同路径1的步骤2.3）
  ↓
【步骤4.4：设置回调函数】（同路径1的步骤2.4）
  ↓
【步骤4.5：连接SDK并显示数字人】（同路径1的步骤2.5）
  ↓
【最终状态】
  - 旧角色的数字人连接已断开
  - 新角色的数字人已连接并显示
  - 连接按钮可用状态已更新
```

### 2.2 数据流关键节点

#### 节点1：记录当前角色（两个入口都需要）

**位置：**
- 入口1：`getAndSetCurrentPartnerRole()` 中设置 `appState.currentPartnerRole`
- 入口2：`handleSetCurrentUserRole()` 和 `handleSetCurrentRole()` 中设置 `appState.currentUserRole` 和 `appState.currentPartnerRole`

**作用：**
- 为连接按钮的可用状态判断提供依据
- 为连接函数验证"是否为当前角色"提供依据

#### 节点2：更新连接按钮可用状态（两个入口都需要）

**位置：**
- 入口1：`handleApiKeyLogin()` 中触发 `roleUpdated` 事件
- 入口2：`handleSetCurrentUserRole()` 和 `handleSetCurrentRole()` 中触发 `roleUpdated` 事件

**作用：**
- 通知组件更新连接按钮的 `disabled` 状态
- 确保只有当前角色可以连接

#### 节点3：连接并显示数字人（连接按钮点击）

**位置：**
- `handleConnectRoleFromList()` 或 `handleConnectUserRoleFromList()`

**作用：**
- 连接SDK
- 渲染到容器
- 设置显示状态，使数字人显示在页面容器中

### 2.3 数据流闭环验证

**闭环路径：**
```
入口1/入口2
  ↓
失活旧角色（入口2）
  ↓
记录当前角色
  ↓
激活新角色
  ↓
更新连接按钮可用状态
  ↓
用户点击"连接"按钮
  ↓
连接并显示数字人
  ↓
数字人显示在页面容器中
  ↓
连接按钮可用状态更新（显示"已连接"）
```

**关键验证点：**
- ✅ 入口处记录当前角色并激活 → 连接按钮可用状态正确
- ✅ 切换角色时失活旧角色 → 旧角色的所有状态已清理
- ✅ 切换角色时激活新角色 → 新角色的状态已设置
- ✅ 连接按钮可用状态正确 → 只有当前角色可以连接
- ✅ 连接成功 → 数字人显示在页面容器中
- ✅ 切换角色 → 失活旧角色 → 激活新角色 → 更新连接按钮可用状态 → 可以连接新角色

---

## 三、核心原则

### 3.1 两套参数完全独立

**大模型参数：**
- 存储在 `appState.llm` 中
- 用于大模型API调用
- 与数字人连接无关

**数字人参数：**
- 存储在角色对象中（`appState.currentUserRole.avatarAppId`、`appState.currentPartnerRole.avatarAppId`）
- 用于数字人SDK连接
- 与大模型调用无关

**独立性：**
- ✅ 两套参数完全独立，互不影响
- ✅ 数字人连接不依赖大模型参数
- ✅ 大模型调用不依赖数字人参数

### 3.2 容器在模板中定义

**固定容器ID：**
- 伙伴数字人：`digital-human-partner`
- 用户数字人：`digital-human-user`

**容器定义位置：**
- `AvatarRender.vue` 模板中定义
- 使用 `v-if` 控制显示/隐藏
- 不需要动态创建

**原因：**
- 最多只有两个数字人（一个用户，一个伙伴）
- 使用固定ID简化代码
- 容器在模板中定义，可以使用Vue的响应式系统

### 3.3 连接是独立行为

**连接按钮的作用：**
- ✅ 只负责连接SDK
- ✅ 不涉及角色切换
- ✅ 不涉及容器创建（容器在模板中定义）
- ✅ 设置显示状态，使数字人显示在页面容器中

**连接后的状态：**
- SDK已连接
- 渲染器已创建
- 数字人显示在页面容器中

### 3.4 角色激活/失活函数设计

**核心原则：**
- 每个类型角色（立绘、数字人|用户、伙伴）都应该有切换函数：激活、失活
- 激活函数：设置和初始化角色相关状态
- 失活函数：清理和重置角色相关状态

**函数列表：**

#### 用户角色激活/失活函数

```typescript
// 激活用户角色（立绘或数字人）
async function activateUserRole(role: UserRole) {
  if (role.type === 'illustration') {
    // 激活用户立绘
    activateUserIllustration(role)
  } else if (role.type === 'digital_human') {
    // 激活用户数字人（不连接，只设置状态）
    activateUserDigitalHuman(role)
  }
}

// 失活用户角色（立绘或数字人）
async function deactivateUserRole(role: UserRole) {
  if (role.type === 'illustration') {
    // 失活用户立绘
    deactivateUserIllustration(role)
  } else if (role.type === 'digital_human') {
    // 失活用户数字人（断开连接，清理状态）
    await deactivateUserDigitalHuman(role)
  }
}

// 激活用户立绘
function activateUserIllustration(role: UserRole) {
  // 设置立绘显示状态
  showUserIllustration.value = true
  // 其他立绘相关初始化
}

// 失活用户立绘
function deactivateUserIllustration(role: UserRole) {
  // 隐藏立绘
  showUserIllustration.value = false
  // 其他立绘相关清理
}

// 激活用户数字人
function activateUserDigitalHuman(role: UserRole) {
  // 设置数字人显示状态（不连接，只设置状态）
  appState.avatar.showUserDigitalHuman = true
  // 其他数字人相关初始化
}

// 失活用户数字人
async function deactivateUserDigitalHuman(role: UserRole) {
  const userRoleId = `user:${role.id}`
  const renderer = rendererManager.getRenderer(userRoleId)
  
  if (renderer) {
    // 断开连接
    if (renderer.disconnect) {
      await renderer.disconnect()
    }
    // 隐藏数字人
    appState.avatar.showUserDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(userRoleId)
    appState.avatar.connectedRoles.delete(userRoleId)
    // 销毁渲染器
    rendererManager.destroyRenderer(userRoleId)
  }
}
```

#### 伙伴角色激活/失活函数

```typescript
// 激活伙伴角色（立绘或数字人）
async function activatePartnerRole(role: Role) {
  if (role.type === 'illustration') {
    // 激活伙伴立绘
    activatePartnerIllustration(role)
  } else if (role.type === 'digital_human') {
    // 激活伙伴数字人（不连接，只设置状态）
    activatePartnerDigitalHuman(role)
  }
}

// 失活伙伴角色（立绘或数字人）
async function deactivatePartnerRole(role: Role) {
  if (role.type === 'illustration') {
    // 失活伙伴立绘
    deactivatePartnerIllustration(role)
  } else if (role.type === 'digital_human') {
    // 失活伙伴数字人（断开连接，清理状态）
    await deactivatePartnerDigitalHuman(role)
  }
}

// 激活伙伴立绘
function activatePartnerIllustration(role: Role) {
  // 设置立绘显示状态
  showPartnerIllustration.value = true
  // 其他立绘相关初始化
}

// 失活伙伴立绘
function deactivatePartnerIllustration(role: Role) {
  // 隐藏立绘
  showPartnerIllustration.value = false
  // 其他立绘相关清理
}

// 激活伙伴数字人
function activatePartnerDigitalHuman(role: Role) {
  // 设置数字人显示状态（不连接，只设置状态）
  appState.avatar.showPartnerDigitalHuman = true
  // 其他数字人相关初始化
}

// 失活伙伴数字人
async function deactivatePartnerDigitalHuman(role: Role) {
  const partnerRoleId = `partner:${role.user}`
  const renderer = rendererManager.getRenderer(partnerRoleId)
  
  if (renderer) {
    // 断开连接
    if (renderer.disconnect) {
      await renderer.disconnect()
    }
    // 隐藏数字人
    appState.avatar.showPartnerDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(partnerRoleId)
    appState.avatar.connectedRoles.delete(partnerRoleId)
    // 销毁渲染器
    rendererManager.destroyRenderer(partnerRoleId)
  }
}
```

**使用场景：**
- 切换角色时：先调用旧角色的失活函数，再调用新角色的激活函数
- 登录后：调用当前角色的激活函数
- 退出登录时：调用当前角色的失活函数

---

## 四、入口1：用户登录后获取当前用户和伙伴角色

**位置：** `ConfigPanel.vue` - `handleApiKeyLogin()` 函数

### 4.1 步骤1.1-1.3：加载角色列表并设置当前角色

**代码流程：**
```typescript
async function handleApiKeyLogin() {
  // 1. 验证输入
  if (!loginApiKeyInput.value || !loginApiKeyInput.value.trim()) {
    showToastMessage('请输入 API Key', 'error')
    return
  }
  
  try {
    // 2. 设置全局APIKey
    globalApiKey.value = loginApiKeyInput.value.trim()
    appState.llm.apiKey = globalApiKey.value
    
    // 3. 加载用户角色列表（步骤1.1）
    await loadUserRoles()
    // loadUserRoles() 内部会：
    //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
    //   - 查找 isCurrent === true 的角色
    //   - 设置 appState.currentUserRole = currentRole
    
    // 4. 检查是否有当前用户角色
    if (!appState.currentUserRole) {
      // 没有当前用户角色：弹出角色创建面板
      showApiKeyLoginModal.value = false
      showUserRoleManagementModal.value = true
      showUserRoleEditForm.value = true
      showToastMessage('请先创建用户角色', 'info')
    } else {
      // 有当前用户角色：加载数据
      // 4.1 加载伙伴角色列表（步骤1.2）
      await loadRoles()
      // loadRoles() 内部会：
      //   - 调用 getRoles(globalApiKey.value) 获取角色列表
      //   - 设置 roles.value = roleList
      
      // 4.2 获取并设置当前伙伴角色（步骤1.3）
      await getAndSetCurrentPartnerRole()
      // getAndSetCurrentPartnerRole() 内部会：
      //   - 从 localStorage 恢复 appState.llm.user（如果存在且对应的角色存在）
      //   - 设置 appState.llm.user = config.llm.user
      //   - 【需要添加】设置 appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user)
      
      // 4.3 加载对话历史
      await loadHistory()
      
      // 4.4 触发角色更新事件（步骤1.5）
      const event = new CustomEvent('roleUpdated')
      window.dispatchEvent(event)
      
      showApiKeyLoginModal.value = false
      showToastMessage('登录成功', 'success')
    }
    
    loginApiKeyInput.value = ''
  } catch (error) {
    globalApiKey.value = ''
    appState.llm.apiKey = ''
  }
}
```

### 4.2 步骤1.4：记录当前角色并激活

**需要修改的代码：**

**在 `getAndSetCurrentPartnerRole()` 中：**
```typescript
// 在 getAndSetCurrentPartnerRole() 中
if (config.llm && config.llm.user) {
  const roleExists = roles.value.some(r => r.user === config.llm.user)
  if (roleExists) {
    appState.llm.user = config.llm.user
    // 【需要添加】同时设置 appState.currentPartnerRole
    const partnerRole = roles.value.find(r => r.user === config.llm.user)
    if (partnerRole) {
      appState.currentPartnerRole = partnerRole
      // 【需要添加】激活伙伴角色
      await activatePartnerRole(partnerRole)
    }
  }
}
```

**在 `loadUserRoles()` 中：**
```typescript
// 在 loadUserRoles() 中，设置当前用户角色后
if (currentRole) {
  appState.currentUserRole = currentRole
  // 【需要添加】激活用户角色
  await activateUserRole(currentRole)
}
```

**已实现的：**
- ✅ `loadUserRoles()` 已设置 `appState.currentUserRole = currentRole`

**需要添加的：**
- ⚠️ `getAndSetCurrentPartnerRole()` 中需要设置 `appState.currentPartnerRole` 并激活
- ⚠️ `loadUserRoles()` 中需要激活用户角色

### 4.3 步骤1.5：更新连接按钮可用状态

**实现方式：**

**1. 触发 `roleUpdated` 事件：**
```typescript
// 在 handleApiKeyLogin() 中
const event = new CustomEvent('roleUpdated')
window.dispatchEvent(event)
// 这个事件会通知组件更新连接按钮的可用状态
```

**2. 连接按钮的 `disabled` 状态通过计算属性自动更新：**

**模板代码：**
```vue
<!-- 伙伴角色连接按钮 -->
<button
  @click="handleConnectRoleFromList(role)"
  :disabled="!appState.currentPartnerRole || 
             appState.currentPartnerRole.user !== role.user || 
             appState.currentPartnerRole.type !== 'digital_human'"
>
  连接
</button>

<!-- 用户角色连接按钮 -->
<button
  @click="handleConnectUserRoleFromList(role)"
  :disabled="!appState.currentUserRole || 
             appState.currentUserRole.id !== role.id || 
             appState.currentUserRole.type !== 'digital_human'"
>
  连接
</button>
```

**作用：**
- 只有当前角色可以连接
- 只有数字人类型的角色可以连接

---

## 五、入口2：切换的时候更新当前角色

**位置：** `ConfigPanel.vue` - `handleSetCurrentUserRole()` 和 `handleSetCurrentRole()` 函数

### 5.1 步骤3.1：清理旧角色的数字人连接（使用失活函数）

**应该做的：**
1. ✅ 调用旧角色的失活函数，清理旧角色的所有状态（立绘或数字人）

**代码示例（切换用户角色）：**
```typescript
async function handleSetCurrentUserRole(role: UserRole) {
  try {
    // 步骤3.1：失活旧角色（清理旧角色的所有状态）
    if (appState.currentUserRole) {
      await deactivateUserRole(appState.currentUserRole)
    }
    
    // 步骤3.2：设置当前用户角色（调用API）
    await setCurrentUserRole(role.id, globalApiKey.value)
    
    // 步骤3.3：重新加载用户角色列表
    await loadUserRoles()
    
    // 步骤3.4：更新当前角色标识（记录当前角色）
    appState.currentUserRole = role
    
    // 步骤3.4.1：激活新角色（设置新角色的状态）
    await activateUserRole(role)
    
    // 应用用户角色的大模型配置到全局状态
    if (role.baseURL) {
      appState.llm.baseURL = role.baseURL
    }
    if (role.model) {
      appState.llm.model = role.model
    }
    appState.llm.apiKey = globalApiKey.value
    
    // 保存配置
    handleSaveConfig()
    
    // 步骤3.5：触发角色更新事件（更新连接按钮可用状态）
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
    
    showToastMessage(`已切换到用户角色"${role.name || '(未命名)'}"`, 'success')
  } catch (error) {
    showToastMessage((error as Error).message, 'error')
  }
}
```

**代码示例（切换伙伴角色）：**
```typescript
async function handleSetCurrentRole(role: Role) {
  // 步骤3.1：失活旧角色（清理旧角色的所有状态）
  if (appState.currentPartnerRole) {
    await deactivatePartnerRole(appState.currentPartnerRole)
  }
  
  // 步骤3.2：设置当前角色（直接设置，不需要调用API）
  appState.llm.user = role.user
  
  // 步骤3.3：重新加载角色列表
  await loadRoles()
  
  // 步骤3.4：更新当前角色标识（记录当前角色）
  appState.currentPartnerRole = role  // ← 更新当前标识
  
  // 步骤3.4.1：激活新角色（设置新角色的状态）
  await activatePartnerRole(role)
  
  // 应用角色的大模型配置
  if (role.baseURL !== undefined && role.baseURL !== null && role.baseURL.trim()) {
    appState.llm.baseURL = role.baseURL
  }
  if (role.model !== undefined && role.model !== null && role.model.trim()) {
    appState.llm.model = role.model
  }
  if (role.apiKey !== undefined && role.apiKey !== null && role.apiKey.trim()) {
    appState.llm.apiKey = role.apiKey
  }
  
  // 保存配置
  handleSaveConfig()
  
  // 切换当前伙伴角色时，同时切换历史记录
  await loadHistory()
  
  // 步骤3.5：触发角色更新事件（更新连接按钮可用状态）
  const event = new CustomEvent('roleUpdated')
  window.dispatchEvent(event)
  
  showToastMessage(`已切换到角色"${role.name || role.user}"`, 'success')
}
```

### 5.2 步骤3.4：更新当前角色标识（记录当前角色）

**应该做的：**
1. ✅ 在 `handleSetCurrentUserRole()` 中：`appState.currentUserRole = role`（已实现）
2. ✅ 在 `handleSetCurrentRole()` 中：`appState.currentPartnerRole = role`（需要添加）

### 5.3 步骤3.5：更新连接按钮可用状态

**实现方式：**
```typescript
// 在 handleSetCurrentUserRole() 和 handleSetCurrentRole() 中
const event = new CustomEvent('roleUpdated')
window.dispatchEvent(event)
// 这个事件会通知组件更新连接按钮的可用状态
```

**作用：**
- 通知组件更新连接按钮的 `disabled` 状态
- 确保只有当前角色可以连接

---

## 六、连接操作执行步骤（步骤2.1-2.5 / 步骤4.1-4.5）

**位置：** `ConfigPanel.vue` - `handleConnectRoleFromList()` 和 `handleConnectUserRoleFromList()` 函数

### 6.1 步骤2.1 / 4.1：基础验证

**应该做的：**
1. ✅ 检查是否正在连接（防止重复点击）
2. ✅ 检查SDK是否已加载（`window.XmovAvatar`）
3. ✅ 检查角色是否配置了 `avatarAppId` 和 `avatarAppSecret`
4. ✅ 检查该角色是否已连接（`appState.avatar.connectedRoles.has(roleId)`）
5. ✅ 检查该角色是否为当前角色（只有当前角色可以连接，依赖步骤1.4/3.4的记录）
6. ✅ 检查当前角色类型是否为数字人

**代码示例：**
```typescript
// 1. 检查是否正在连接
if (isConnecting.value) return

// 2. 检查SDK是否已加载
if (!window.XmovAvatar) {
  showToastMessage('SDK未加载，请刷新页面重试', 'error')
  return
}

// 3. 检查角色是否配置了 appId 和 appSecret
if (!role.avatarAppId || !role.avatarAppSecret) {
  showToastMessage('请先配置数字人的 App ID 和 App Secret', 'error')
  return
}

// 4. 检查该角色是否已连接
const partnerRoleId = `partner:${role.user}` // 或 `user:${role.id}`
if (appState.avatar.connectedRoles.has(partnerRoleId)) {
  showToastMessage('该角色已连接', 'info')
  return
}

// 5. 检查该角色是否为当前角色（依赖步骤1.4/3.4的记录）
if (!appState.currentPartnerRole || appState.currentPartnerRole.user !== role.user) {
  showToastMessage('只有当前角色可以连接', 'error')
  return
}

// 6. 检查当前角色类型是否为数字人
if (appState.currentPartnerRole.type !== 'digital_human') {
  showToastMessage('当前角色类型不是数字人', 'error')
  return
}
```

### 6.2 步骤2.2 / 4.2：获取或创建渲染器

**应该做的：**
1. ✅ 获取渲染器（如果已存在）
2. ✅ 如果不存在，创建渲染器（使用角色的数字人参数）

**代码示例：**
```typescript
const partnerRoleId = `partner:${role.user}` // 或 `user:${role.id}`

// 获取或创建渲染器
let renderer = rendererManager.getRenderer(partnerRoleId)
if (!renderer) {
  // 创建渲染器（从角色对象中获取数字人参数）
  renderer = await rendererManager.createRenderer(partnerRoleId, {
    roleId: partnerRoleId,
    roleType: 'digital_human',
    positionX: role.positionX !== undefined ? role.positionX : 50,
    positionY: role.positionY !== undefined ? role.positionY : 50,
    scale: role.scale !== undefined ? role.scale : 1.0,
    avatarAppId: role.avatarAppId,        // ← 数字人参数：从角色对象中获取
    avatarAppSecret: role.avatarAppSecret, // ← 数字人参数：从角色对象中获取
    containerId: 'digital-human-partner'   // ← 固定容器ID（伙伴）或 'digital-human-user'（用户）
  })
}
```

**不应该做的：**
- ❌ 不应该更新渲染器配置（如果配置已更改，应该在切换角色时处理，而不是在连接时）

### 6.3 步骤2.3 / 4.3：检查容器是否存在

**应该做的：**
1. ✅ 使用固定容器ID查找容器
   - 伙伴数字人：`digital-human-partner`
   - 用户数字人：`digital-human-user`
2. ✅ 如果容器不存在，直接报错（错误直接暴露）

**代码示例：**
```typescript
// 使用固定容器ID
const containerId = 'digital-human-partner' // 或 'digital-human-user'

// 检查容器是否存在
const containerElement = document.getElementById(containerId)
if (!containerElement) {
  showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
  isConnecting.value = false
  return
}
```

**不应该做的：**
- ❌ 不应该动态创建容器（容器在模板中定义，通过 `v-if` 控制显示）
- ❌ 不应该使用MD5哈希生成容器ID（使用固定ID）

### 6.4 步骤2.4 / 4.4：设置回调函数

**应该做的：**
1. ✅ 设置回调函数（字幕显示、状态变化等）

**代码示例：**
```typescript
if (renderer instanceof DigitalHumanRenderer) {
  renderer.setCallbacks({
    onSubtitleOn: (text: string) => {
      appState.ui.subTitleText = text
    },
    onSubtitleOff: () => {
      appState.ui.subTitleText = ''
    },
    onStateChange: (state: string) => {
      avatarState.value = state
    }
  })
}
```

### 6.5 步骤2.5 / 4.5：连接SDK并显示数字人

**应该做的：**
1. ✅ 调用 `renderer.connect()` 连接SDK
2. ✅ 调用 `renderer.render(containerElement)` 渲染到容器（**将数字人显示在页面容器中**）
3. ✅ 保存实例到 `appState.avatar.instances`
4. ✅ 记录连接状态到 `appState.avatar.connectedRoles`
5. ✅ 设置显示状态，使容器显示（**将数字人显示在页面容器中**）

**代码示例：**
```typescript
if (renderer.connect) {
  // 先设置显示状态，确保容器出现在DOM中
  appState.avatar.showPartnerDigitalHuman = true  // 或 appState.avatar.showUserDigitalHuman = true
  // 等待Vue更新DOM
  await nextTick()
  
  // 先调用render设置容器（connect需要容器已初始化）
  await renderer.render(containerElement)
  // 再调用connect连接SDK（使用渲染器配置中的数字人参数）
  await renderer.connect()
  
  // 保存实例和连接状态
  if (renderer instanceof DigitalHumanRenderer) {
    const instance = renderer.getInstance()
    if (instance) {
      appState.avatar.instances.set(partnerRoleId, instance)
    }
  }
  appState.avatar.connectedRoles.add(partnerRoleId)
  
  // 显示状态已在连接前设置，这里不需要再次设置
  
  showToastMessage('连接成功', 'success')
} else {
  showToastMessage('渲染器不支持连接操作', 'error')
}
```

**关键点：**
- ✅ **将数字人显示在页面容器中**：通过 `renderer.render(containerElement)` 将数字人渲染到容器
- ✅ **容器显示**：通过设置 `appState.avatar.showPartnerDigitalHuman = true` 或 `appState.avatar.showUserDigitalHuman = true`，使容器通过 `v-if` 显示
- ✅ **容器在模板中定义**：容器在 `AvatarRender.vue` 模板中定义，使用 `v-if` 控制显示

---

## 七、角色激活/失活函数实现

### 7.1 用户角色激活/失活函数

```typescript
// 激活用户角色（立绘或数字人）
async function activateUserRole(role: UserRole) {
  if (role.type === 'illustration') {
    // 激活用户立绘
    activateUserIllustration(role)
  } else if (role.type === 'digital_human') {
    // 激活用户数字人（不连接，只设置状态）
    activateUserDigitalHuman(role)
  }
}

// 失活用户角色（立绘或数字人）
async function deactivateUserRole(role: UserRole) {
  if (role.type === 'illustration') {
    // 失活用户立绘
    deactivateUserIllustration(role)
  } else if (role.type === 'digital_human') {
    // 失活用户数字人（断开连接，清理状态）
    await deactivateUserDigitalHuman(role)
  }
}

// 激活用户立绘
function activateUserIllustration(role: UserRole) {
  // 设置立绘显示状态
  showUserIllustration.value = true
  // 其他立绘相关初始化（如果需要）
}

// 失活用户立绘
function deactivateUserIllustration(role: UserRole) {
  // 隐藏立绘
  showUserIllustration.value = false
  // 其他立绘相关清理（如果需要）
}

// 激活用户数字人
function activateUserDigitalHuman(role: UserRole) {
  // 设置数字人显示状态（不连接，只设置状态）
  // 注意：激活时不连接SDK，连接需要用户点击"连接"按钮
  appState.avatar.showUserDigitalHuman = true
  // 其他数字人相关初始化（如果需要）
}

// 失活用户数字人
async function deactivateUserDigitalHuman(role: UserRole) {
  const userRoleId = `user:${role.id}`
  const renderer = rendererManager.getRenderer(userRoleId)
  
  if (renderer) {
    // 断开连接
    if (renderer.disconnect) {
      await renderer.disconnect()
    }
    // 隐藏数字人
    appState.avatar.showUserDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(userRoleId)
    appState.avatar.connectedRoles.delete(userRoleId)
    // 销毁渲染器
    rendererManager.destroyRenderer(userRoleId)
  } else {
    // 如果渲染器不存在，只清理显示状态
    appState.avatar.showUserDigitalHuman = false
  }
}
```

### 7.2 伙伴角色激活/失活函数

```typescript
// 激活伙伴角色（立绘或数字人）
async function activatePartnerRole(role: Role) {
  if (role.type === 'illustration') {
    // 激活伙伴立绘
    activatePartnerIllustration(role)
  } else if (role.type === 'digital_human') {
    // 激活伙伴数字人（不连接，只设置状态）
    activatePartnerDigitalHuman(role)
  }
}

// 失活伙伴角色（立绘或数字人）
async function deactivatePartnerRole(role: Role) {
  if (role.type === 'illustration') {
    // 失活伙伴立绘
    deactivatePartnerIllustration(role)
  } else if (role.type === 'digital_human') {
    // 失活伙伴数字人（断开连接，清理状态）
    await deactivatePartnerDigitalHuman(role)
  }
}

// 激活伙伴立绘
function activatePartnerIllustration(role: Role) {
  // 设置立绘显示状态
  showPartnerIllustration.value = true
  // 其他立绘相关初始化（如果需要）
}

// 失活伙伴立绘
function deactivatePartnerIllustration(role: Role) {
  // 隐藏立绘
  showPartnerIllustration.value = false
  // 其他立绘相关清理（如果需要）
}

// 激活伙伴数字人
function activatePartnerDigitalHuman(role: Role) {
  // 设置数字人显示状态（不连接，只设置状态）
  // 注意：激活时不连接SDK，连接需要用户点击"连接"按钮
  appState.avatar.showPartnerDigitalHuman = true
  // 其他数字人相关初始化（如果需要）
}

// 失活伙伴数字人
async function deactivatePartnerDigitalHuman(role: Role) {
  const partnerRoleId = `partner:${role.user}`
  const renderer = rendererManager.getRenderer(partnerRoleId)
  
  if (renderer) {
    // 断开连接
    if (renderer.disconnect) {
      await renderer.disconnect()
    }
    // 隐藏数字人
    appState.avatar.showPartnerDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(partnerRoleId)
    appState.avatar.connectedRoles.delete(partnerRoleId)
    // 销毁渲染器
    rendererManager.destroyRenderer(partnerRoleId)
  } else {
    // 如果渲染器不存在，只清理显示状态
    appState.avatar.showPartnerDigitalHuman = false
  }
}
```

### 7.3 函数使用说明

**激活函数的作用：**
- ✅ 设置角色的显示状态
- ✅ 初始化角色相关的状态
- ❌ **不连接数字人SDK**（连接需要用户点击"连接"按钮）

**失活函数的作用：**
- ✅ 清理角色的显示状态
- ✅ 断开数字人SDK连接（如果已连接）
- ✅ 清理角色相关的所有状态
- ✅ 销毁渲染器（如果存在）

**使用时机：**
- **登录后**：调用当前用户角色和伙伴角色的激活函数
- **切换角色时**：先调用旧角色的失活函数，再调用新角色的激活函数
- **退出登录时**：调用当前角色的失活函数

---

## 八、完整代码示例

### 8.1 伙伴角色连接函数

```typescript
// 从角色列表连接伙伴角色数字人
async function handleConnectRoleFromList(role: Role) {
  // 步骤2.1：基础验证
  if (isConnecting.value) return
  
  if (!window.XmovAvatar) {
    showToastMessage('SDK未加载，请刷新页面重试', 'error')
    return
  }
  
  if (!role.avatarAppId || !role.avatarAppSecret) {
    showToastMessage('请先配置数字人的 App ID 和 App Secret', 'error')
    return
  }
  
  const partnerRoleId = `partner:${role.user}`
  if (appState.avatar.connectedRoles.has(partnerRoleId)) {
    showToastMessage('该角色已连接', 'info')
    return
  }
  
  if (!appState.currentPartnerRole || appState.currentPartnerRole.user !== role.user) {
    showToastMessage('只有当前角色可以连接', 'error')
    return
  }
  
  if (appState.currentPartnerRole.type !== 'digital_human') {
    showToastMessage('当前角色类型不是数字人', 'error')
    return
  }
  
  // 步骤2.2：获取或创建渲染器
  isConnecting.value = true
  try {
    // 先设置显示状态，确保容器出现在DOM中
    appState.avatar.showPartnerDigitalHuman = true
    // 等待Vue更新DOM
    await nextTick()
    
    let renderer = rendererManager.getRenderer(partnerRoleId)
    if (!renderer) {
      // 创建渲染器（从角色对象中获取数字人参数）
      renderer = await rendererManager.createRenderer(partnerRoleId, {
        roleId: partnerRoleId,
        roleType: 'digital_human',
        positionX: role.positionX !== undefined ? role.positionX : 50,
        positionY: role.positionY !== undefined ? role.positionY : 50,
        scale: role.scale !== undefined ? role.scale : 1.0,
        avatarAppId: role.avatarAppId,        // ← 数字人参数
        avatarAppSecret: role.avatarAppSecret, // ← 数字人参数
        containerId: 'digital-human-partner'   // ← 固定容器ID
      })
    }
    
    // 步骤2.3：检查容器是否存在（使用固定ID）
    const containerId = 'digital-human-partner'
    const containerElement = document.getElementById(containerId)
    if (!containerElement) {
      showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
      appState.avatar.showPartnerDigitalHuman = false
      isConnecting.value = false
      return
    }
    
    // 步骤2.4：设置回调函数
    if (renderer instanceof DigitalHumanRenderer) {
      renderer.setCallbacks({
        onSubtitleOn: (text: string) => {
          appState.ui.subTitleText = text
        },
        onSubtitleOff: () => {
          appState.ui.subTitleText = ''
        },
        onStateChange: (state: string) => {
          avatarState.value = state
        }
      })
    }
    
    // 步骤2.5：连接SDK并显示数字人
    if (renderer.connect) {
      // 先设置显示状态，确保容器出现在DOM中
      appState.avatar.showPartnerDigitalHuman = true
      // 等待Vue更新DOM
      await nextTick()
      
      // 先调用render设置容器（connect需要容器已初始化）
      await renderer.render(containerElement)
      // 再调用connect连接SDK
      await renderer.connect()
      
      if (renderer instanceof DigitalHumanRenderer) {
        const instance = renderer.getInstance()
        if (instance) {
          appState.avatar.instances.set(partnerRoleId, instance)
        }
      }
      appState.avatar.connectedRoles.add(partnerRoleId)
      
      // 显示状态已在连接前设置，这里不需要再次设置
      
      showToastMessage('连接成功', 'success')
    } else {
      showToastMessage('渲染器不支持连接操作', 'error')
    }
  } catch (error) {
    console.error('连接失败:', error)
    const errorMessage = error instanceof Error ? error.message : String(error)
    showToastMessage(`连接失败: ${errorMessage}`, 'error')
  } finally {
    isConnecting.value = false
  }
}
```

### 8.2 用户角色连接函数

**与伙伴角色连接函数完全一致，只是：**
- `roleId` 改为 `user:${role.id}`
- `containerId` 改为 `digital-human-user`
- 验证逻辑改为检查 `appState.currentUserRole`

```typescript
// 从角色列表连接用户角色数字人
async function handleConnectUserRoleFromList(role: UserRole) {
  // 步骤2.1：基础验证
  if (isConnecting.value) return
  
  if (!window.XmovAvatar) {
    showToastMessage('SDK未加载，请刷新页面重试', 'error')
    return
  }
  
  if (!role.avatarAppId || !role.avatarAppSecret) {
    showToastMessage('请先配置数字人的 App ID 和 App Secret', 'error')
    return
  }
  
  const userRoleId = `user:${role.id}`
  if (appState.avatar.connectedRoles.has(userRoleId)) {
    showToastMessage('该角色已连接', 'info')
    return
  }
  
  if (!appState.currentUserRole || appState.currentUserRole.id !== role.id) {
    showToastMessage('只有当前角色可以连接', 'error')
    return
  }
  
  if (appState.currentUserRole.type !== 'digital_human') {
    showToastMessage('当前角色类型不是数字人', 'error')
    return
  }
  
  // 步骤2.2：获取或创建渲染器
  isConnecting.value = true
  try {
    // 先设置显示状态，确保容器出现在DOM中
    appState.avatar.showUserDigitalHuman = true
    // 等待Vue更新DOM
    await nextTick()
    
    let renderer = rendererManager.getRenderer(userRoleId)
    if (!renderer) {
      // 创建渲染器（从角色对象中获取数字人参数）
      renderer = await rendererManager.createRenderer(userRoleId, {
        roleId: userRoleId,
        roleType: 'digital_human',
        positionX: role.positionX !== undefined ? role.positionX : 50,
        positionY: role.positionY !== undefined ? role.positionY : 50,
        scale: role.scale !== undefined ? role.scale : 1.0,
        avatarAppId: role.avatarAppId,        // ← 数字人参数
        avatarAppSecret: role.avatarAppSecret, // ← 数字人参数
        containerId: 'digital-human-user'      // ← 固定容器ID
      })
    }
    
    // 步骤2.3：检查容器是否存在（使用固定ID）
    const containerId = 'digital-human-user'
    const containerElement = document.getElementById(containerId)
    if (!containerElement) {
      showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
      appState.avatar.showUserDigitalHuman = false
      isConnecting.value = false
      return
    }
    
    // 步骤2.4：设置回调函数
    if (renderer instanceof DigitalHumanRenderer) {
      renderer.setCallbacks({
        onSubtitleOn: (text: string) => {
          appState.ui.subTitleText = text
        },
        onSubtitleOff: () => {
          appState.ui.subTitleText = ''
        },
        onStateChange: (state: string) => {
          avatarState.value = state
        }
      })
    }
    
    // 步骤2.5：连接SDK并显示数字人
    if (renderer.connect) {
      // 先调用render设置容器（connect需要容器已初始化）
      await renderer.render(containerElement)
      // 再调用connect连接SDK
      await renderer.connect()
      
      if (renderer instanceof DigitalHumanRenderer) {
        const instance = renderer.getInstance()
        if (instance) {
          appState.avatar.instances.set(userRoleId, instance)
        }
      }
      appState.avatar.connectedRoles.add(userRoleId)
      
      // 显示状态已在连接前设置，这里不需要再次设置
      
      showToastMessage('连接成功', 'success')
    } else {
      showToastMessage('渲染器不支持连接操作', 'error')
    }
  } catch (error) {
    console.error('连接失败:', error)
    const errorMessage = error instanceof Error ? error.message : String(error)
    showToastMessage(`连接失败: ${errorMessage}`, 'error')
  } finally {
    isConnecting.value = false
  }
}
```

---

## 九、不应该做的事情

### 8.1 ❌ 不应该做1：动态创建容器

**当前代码（需要删除）：**
```typescript
// 删除：动态创建容器的所有代码
const roleIdHash = toMd5(partnerRoleId)
const containerId = `digital-human-${roleIdHash}`

// 检查容器是否已存在
let containerElement = document.getElementById(containerId)
if (!containerElement) {
  // 实时创建容器
  containerElement = document.createElement('div')
  containerElement.id = containerId
  containerElement.className = 'sdk-container'
  // ... 所有样式设置
  avatarRender.appendChild(containerElement)
}
```

**删除原因：**
- ❌ 容器在模板中定义，不应该动态创建
- ❌ 动态创建导致无法使用Vue的响应式系统
- ❌ 这是导致数字人联动问题的根源之一

**重构后：**
- ✅ 使用固定容器ID：`digital-human-partner` 或 `digital-human-user`
- ✅ 容器在模板中定义，通过 `v-if` 控制显示
- ✅ 如果容器不存在，直接报错（错误直接暴露）

### 8.2 ❌ 不应该做2：更新渲染器配置

**当前代码（需要删除）：**
```typescript
// 删除：更新渲染器配置
if (config.avatarAppId !== role.avatarAppId || config.avatarAppSecret !== role.avatarAppSecret) {
  await renderer.updateConfig({
    avatarAppId: role.avatarAppId,
    avatarAppSecret: role.avatarAppSecret,
    // ...
  })
}
```

**删除原因：**
- ❌ 如果配置已更改，应该在切换角色时处理，而不是在连接时
- ❌ 连接时更新配置会导致逻辑混乱

**重构后：**
- ✅ 如果渲染器已存在，直接使用（配置应该在切换角色时已更新）

### 8.3 ❌ 不应该做3：切换角色

**当前代码（不存在，但需要确保）：**
- ✅ 连接函数中不应该调用 `handleSetCurrentRole` 或 `handleSetCurrentUserRole`
- ✅ 连接是独立行为，不应该有切换角色的逻辑

**确保：**
- ✅ 连接按钮的 `disabled` 状态已确保只有当前角色可以连接
- ✅ 连接函数中不需要切换角色的代码

---

## 十、用户和伙伴数字人互不干扰

### 9.1 独立的数据结构

**伙伴数字人：**
- `roleId = partner:${role.user}`
- 容器ID = `digital-human-partner`

**用户数字人：**
- `roleId = user:${role.id}`
- 容器ID = `digital-human-user`

### 9.2 独立的渲染器

- 每个数字人有独立的渲染器实例
- 每个渲染器有独立的配置（avatarAppId, avatarAppSecret）
- 每个渲染器连接到独立的容器

### 9.3 独立的状态管理

- `appState.avatar.instances`：每个数字人有独立的实例
- `appState.avatar.connectedRoles`：每个数字人有独立的连接状态
- `appState.avatar.showPartnerDigitalHuman` 和 `appState.avatar.showUserDigitalHuman`：独立的显示状态

### 9.4 互不干扰的原因

- ✅ 使用不同的 `roleId` 区分用户和伙伴数字人
- ✅ 使用不同的固定容器ID区分容器
- ✅ 每个数字人有独立的渲染器实例和配置
- ✅ 显示状态独立管理

---

## 十一、执行检查清单

### 11.1 代码修改检查清单

**需要修改的文件：**
- [ ] `src/components/ConfigPanel.vue`
  - [ ] **新增函数**：实现用户角色激活/失活函数（`activateUserRole`, `deactivateUserRole`, `activateUserIllustration`, `deactivateUserIllustration`, `activateUserDigitalHuman`, `deactivateUserDigitalHuman`）
  - [ ] **新增函数**：实现伙伴角色激活/失活函数（`activatePartnerRole`, `deactivatePartnerRole`, `activatePartnerIllustration`, `deactivatePartnerIllustration`, `activatePartnerDigitalHuman`, `deactivatePartnerDigitalHuman`）
  - [ ] 入口1：`getAndSetCurrentPartnerRole()` 中添加 `appState.currentPartnerRole = role` 并调用 `activatePartnerRole(role)`
  - [ ] 入口1：`loadUserRoles()` 中调用 `activateUserRole(currentRole)`
  - [ ] 入口2：`handleSetCurrentUserRole()` 中调用 `deactivateUserRole(oldRole)` 和 `activateUserRole(role)`
  - [ ] 入口2：`handleSetCurrentRole()` 中调用 `deactivatePartnerRole(oldRole)` 和 `activatePartnerRole(role)`
  - [ ] 修改 `handleConnectRoleFromList` 函数
  - [ ] 修改 `handleConnectUserRoleFromList` 函数
  - [ ] 删除所有动态创建容器的代码
  - [ ] 删除所有更新渲染器配置的代码
  - [ ] 使用固定容器ID

**需要确保的容器定义：**
- [ ] `src/components/AvatarRender.vue` 模板中已定义两个数字人容器
  - [ ] 伙伴数字人容器：`id="digital-human-partner"`
  - [ ] 用户数字人容器：`id="digital-human-user"`
  - [ ] 使用 `v-if` 控制显示

**需要确保的渲染器配置：**
- [ ] `src/renderers/digital-human/DigitalHumanRenderer.ts`
  - [ ] 支持从配置中传入 `containerId`
  - [ ] 或根据 `roleId` 前缀判断使用固定容器ID

### 11.2 功能验证检查清单

**入口1验证：**
- [ ] 用户登录后，`appState.currentUserRole` 已设置
- [ ] 用户登录后，`appState.currentPartnerRole` 已设置
- [ ] 用户登录后，连接按钮可用状态正确（只有当前角色可以连接）

**入口2验证：**
- [ ] 切换用户角色时，旧角色的数字人连接已断开
- [ ] 切换用户角色时，`appState.currentUserRole` 已更新
- [ ] 切换伙伴角色时，旧角色的数字人连接已断开
- [ ] 切换伙伴角色时，`appState.currentPartnerRole` 已更新
- [ ] 切换角色后，连接按钮可用状态正确

**连接功能验证：**
- [ ] 点击伙伴角色列表中的"连接"按钮，可以连接伙伴数字人
- [ ] 点击用户角色列表中的"连接"按钮，可以连接用户数字人
- [ ] 连接后，数字人在主页面显示
- [ ] 用户数字人和伙伴数字人可以同时显示，互不干扰
- [ ] 连接失败时，显示错误提示

**独立性验证：**
- [ ] 连接用户数字人，不影响伙伴数字人
- [ ] 连接伙伴数字人，不影响用户数字人
- [ ] 两个数字人可以同时连接和显示
- [ ] 每个数字人使用独立的配置（avatarAppId, avatarAppSecret）

**错误处理验证：**
- [ ] SDK未加载时，显示错误提示
- [ ] 角色未配置数字人参数时，显示错误提示
- [ ] 角色已连接时，显示提示信息
- [ ] 非当前角色时，连接按钮不可用（disabled）
- [ ] 容器不存在时，显示错误提示（错误直接暴露）

---

## 十二、总结

### 12.1 核心要点

1. **完整闭环流程**
   - 入口1/入口2 → 记录当前角色 → 更新连接按钮可用状态 → 用户点击"连接"按钮 → 连接并显示数字人 → 数字人显示在页面容器中

2. **两个入口处的处理**
   - 入口1：用户登录后获取当前用户和伙伴角色，记录当前角色，更新连接按钮可用状态
   - 入口2：切换的时候更新当前角色，清理旧连接的数字人，记录当前角色，更新连接按钮可用状态

3. **连接操作**
   - 点击列表"连接"时，将数字人显示在页面容器中
   - 使用固定容器ID，不动态创建容器
   - 从角色对象中获取数字人参数，与大模型参数完全独立

4. **用户和伙伴互不干扰**
   - 使用不同的 `roleId` 和容器ID
   - 每个数字人有独立的渲染器实例
   - 显示状态独立管理

### 12.2 关键原则

- ✅ **不打补丁**：不保留旧代码，不兼容旧逻辑，直接删除
- ✅ **不兼容**：不保留向后兼容代码，错误直接暴露
- ✅ **错误直接暴露**：删除所有容错代码，让错误直接暴露，便于发现问题
- ✅ **干净实现**：确保代码简洁，逻辑清晰
- ✅ **完整闭环**：从入口到连接完成，形成完整的业务流程

### 12.3 预期效果

- ✅ 用户登录后，当前角色已记录，连接按钮可用状态正确
- ✅ 切换角色时，旧连接已清理，新角色已记录，连接按钮可用状态正确
- ✅ 点击连接按钮，可以连接数字人
- ✅ 连接后，数字人在主页面显示
- ✅ 用户和伙伴数字人互不干扰
- ✅ 代码简洁，逻辑清晰
- ✅ 错误直接暴露，便于调试
