# 用户角色状态维护流程梳理

## 概述

本文档按照业务闭环流程，逐一检查用户角色每个节点的状态维护现状，确保所有状态依赖正确。

## 状态对象说明

### 核心状态对象

1. **`userRoles: Ref<UserRole[]>`** - 用户角色列表
2. **`appState.currentUserRole: UserRole | null`** - 当前用户角色引用
3. **`rendererManager`** - 渲染器管理器（管理数字人SDK实例）
4. **角色对象属性（内存状态）**：
   - `isConnecting?: boolean` - 是否正在连接
   - `isConnected?: boolean` - 是否已连接
   - `showDigitalHuman?: boolean` - 是否显示数字人容器
   - `digitalHumanInstance?: DigitalHumanInstance | null` - 数字人SDK实例引用

## 业务流程状态检查

### 步骤1：菜单 - 用户apiKey登录

**调用函数：** `handleLogin()`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `globalApiKey` | - | 赋值 | `loginApiKeyInput.value.trim()` | ✅ |
| `appState.llm.apiKey` | - | 赋值 | `globalApiKey.value` | ✅ |
| `userRoles` | - | 赋值 | `await getUserRoles(apiKey)` | ✅ |
| `userRoles[]` | `isConnecting` | 初始化 | `false` | ✅ |
| `userRoles[]` | `isConnected` | 初始化 | `false` | ✅ |
| `userRoles[]` | `showDigitalHuman` | 初始化 | `false` | ✅ |
| `userRoles[]` | `digitalHumanInstance` | 初始化 | `null` | ✅ |
| `userRoles[]` | `isConnected` | 恢复 | `true` | ✅ 如果 rendererManager 中存在渲染器 |
| `userRoles[]` | `showDigitalHuman` | 恢复 | `true` | ✅ 如果 rendererManager 中存在渲染器 |
| `userRoles[]` | `digitalHumanInstance` | 恢复 | `renderer.getInstance()` | ✅ 如果 rendererManager 中存在渲染器 |
| `appState.currentUserRole` | - | 赋值 | `roleList.find(r => r.isCurrent)` | ✅ |
| `appState.currentUserRole` | - | 激活 | `await activateUserRole(currentRole)` | ✅ |
| `appState.currentUserRole` | `showDigitalHuman` | 设置 | `true` | ✅ 如果是数字人类型（激活时） |

**代码位置：** `src/components/ConfigPanel.vue:2774-2815`

**状态检查：** ✅ **正确**

---

### 步骤2：菜单 - 用户角色管理

**调用函数：** `handleOpenUserRoleManagement()`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `showUserRoleManagementModal` | - | 设置 | `true` | ✅ |
| `showMenu` | - | 设置 | `false` | ✅ |

**代码位置：** `src/components/ConfigPanel.vue:2695-2703`

**状态检查：** ✅ **正确**（注意：不重新加载角色列表，避免丢失连接状态）

**关键代码：**
```typescript
async function handleOpenUserRoleManagement() {
  showUserRoleManagementModal.value = true
  showMenu.value = false
  
  // 注意：不在这里加载用户角色列表，因为：
  // 1. 登录时已经加载过了（handleLogin）
  // 2. 保存/删除/切换角色时会重新加载
  // 3. 打开面板只是为了显示，不需要重新加载和初始化，避免丢失连接状态
}
```

---

### 步骤3：创建首个数字人用户角色，预期当前用户角色为空，会自动设置当前

**调用函数：** `handleSaveUserRole()` - 创建分支

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| 数据库 | - | INSERT | 新记录 | ✅ |
| `userRoles` | - | 添加 | `userRoles.value.push(newRole)` | ✅ |
| `userRoles[]` (新角色) | `isConnecting` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `isConnected` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `showDigitalHuman` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `digitalHumanInstance` | 初始化 | `null` | ✅ |
| 数据库 | `is_current` | UPDATE | `1` | ✅ 如果 `!appState.currentUserRole` |
| `userRoles[]` (新角色) | `isCurrent` | 更新 | `true` | ✅ |
| `userRoles[]` (其他角色) | `isCurrent` | 更新 | `false` | ✅ |
| `appState.currentUserRole` | - | 设置 | 新角色 | ✅ |
| `appState.currentUserRole` | - | 激活 | `await activateUserRole(roleInList)` | ✅ |
| `appState.currentUserRole` | `showDigitalHuman` | 设置 | `true` | ✅ 如果是数字人类型（激活时） |

**代码位置：** `src/components/ConfigPanel.vue:3051-3100`

**状态检查：** ✅ **正确**

**关键逻辑：**
```typescript
// 如果当前用户角色为空，自动设置为当前角色
if (!appState.currentUserRole) {
  const updatedRole = await setCurrentUserRole(createdRoleId, globalApiKey.value)
  // 更新列表中的角色的 isCurrent 属性
  const roleInList = userRoles.value.find(r => r.id === updatedRole.id)
  if (roleInList) {
    roleInList.isCurrent = true
    // 将其他角色的 isCurrent 设为 false
    userRoles.value.forEach(r => {
      if (r.id !== updatedRole.id) {
        r.isCurrent = false
      }
    })
    appState.currentUserRole = roleInList
    // 激活新创建的角色（如果是数字人类型，会设置 showDigitalHuman = true）
    await activateUserRole(roleInList)
  }
}
```

---

### 步骤4：连接数字人

**调用函数：** `handleConnectUserRoleFromList(role: UserRole)`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `role` | `isConnecting` | 设置 | `true` | ✅ |
| `role` | `showDigitalHuman` | 设置 | `true` | ✅ |
| `rendererManager` | `renderers[userRoleId]` | 创建/获取 | `createRenderer()` 或 `getRenderer()` | ✅ |
| `rendererManager` | `renderers[userRoleId]` | 调用 | `renderer.render(containerElement)` | ✅ |
| `rendererManager` | `renderers[userRoleId]` | 调用 | `renderer.connect()` | ✅ |
| `role` | `digitalHumanInstance` | 设置 | `renderer.getInstance()` | ✅ |
| `role` | `isConnected` | 设置 | `true` | ✅ |
| `role` | `isConnecting` | 设置 | `false` | ✅ 连接完成 |

**错误处理：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `role` | `isConnecting` | 回滚 | `false` | ✅ catch块 |
| `role` | `showDigitalHuman` | 回滚 | `false` | ✅ catch块 |

**代码位置：** `src/components/ConfigPanel.vue:1979-2093`

**状态检查：** ✅ **正确**

**前置检查：**
- ✅ 检查 `appState.currentUserRole` 是否与传入的 `role` 一致
- ✅ 检查当前角色类型是否为数字人
- ✅ 检查角色是否配置了 `appId` 和 `appSecret`

---

### 步骤5：关闭用户角色列表

**调用函数：** 关闭模态框（`showUserRoleManagementModal.value = false`）

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `showUserRoleManagementModal` | - | 设置 | `false` | ✅ |

**状态检查：** ✅ **正确**（仅关闭UI，不影响状态）

---

### 步骤6：菜单 - 用户角色管理（再次打开）

**调用函数：** `handleOpenUserRoleManagement()`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `showUserRoleManagementModal` | - | 设置 | `true` | ✅ |
| `showMenu` | - | 设置 | `false` | ✅ |

**状态检查：** ✅ **正确**（不重新加载角色列表，保持连接状态）

**关键点：** 不调用 `loadUserRoles()`，避免丢失内存中的连接状态

---

### 步骤7：断开数字人连接

**调用函数：** `handleDisconnectUserRoleFromList(role: UserRole)`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `rendererManager` | `renderers[userRoleId]` | 调用 | `renderer.disconnect()` | ✅ |
| `rendererManager` | `renderers[userRoleId]` | 调用 | `renderer.hide()` | ✅ |
| `role` | `showDigitalHuman` | 设置 | `false` | ✅ |
| `role` | `digitalHumanInstance` | 设置 | `null` | ✅ |
| `role` | `isConnected` | 设置 | `false` | ✅ |
| `role` | `isConnecting` | 设置 | `false` | ✅ |

**代码位置：** `src/components/ConfigPanel.vue:2096-2125`

**状态检查：** ✅ **正确**

**注意：** 渲染器可选销毁（代码中注释掉了 `destroyRenderer`，可以保留以便后续重新连接）

---

### 步骤8：创建第二个数字人角色

**调用函数：** `handleSaveUserRole()` - 创建分支

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| 数据库 | - | INSERT | 新记录 | ✅ |
| `userRoles` | - | 添加 | `userRoles.value.push(newRole)` | ✅ |
| `userRoles[]` (新角色) | `isConnecting` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `isConnected` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `showDigitalHuman` | 初始化 | `false` | ✅ |
| `userRoles[]` (新角色) | `digitalHumanInstance` | 初始化 | `null` | ✅ |
| `appState.currentUserRole` | - | 保持 | 不变（因为已有当前角色） | ✅ |

**代码位置：** `src/components/ConfigPanel.vue:3051-3100`

**状态检查：** ✅ **正确**

**关键逻辑：** 因为 `appState.currentUserRole` 已存在，不会自动设置为当前角色

---

### 步骤9：设置第二个数字人为当前

**调用函数：** `handleSetCurrentUserRole(role: UserRole)`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `appState.currentUserRole` (旧) | - | 失活 | `await deactivateUserRole(oldRole)` | ✅ |
| `appState.currentUserRole` (旧) | `isConnected` | 清理 | `false` | ✅ 如果已连接 |
| `appState.currentUserRole` (旧) | `showDigitalHuman` | 清理 | `false` | ✅ 如果已连接 |
| `appState.currentUserRole` (旧) | `digitalHumanInstance` | 清理 | `null` | ✅ 如果已连接 |
| `rendererManager` | `renderers[oldUserRoleId]` | 销毁 | 删除渲染器 | ✅ 如果旧角色已连接 |
| 数据库 | `is_current` | UPDATE | `1` 为新角色，`0` 为其他角色 | ✅ |
| `userRoles[]` (旧角色) | `isCurrent` | 更新 | `false` | ✅ |
| `userRoles[]` (新角色) | `isCurrent` | 更新 | `true` | ✅ |
| `appState.currentUserRole` | - | 更新引用 | 新角色对象 | ✅ |
| `appState.currentUserRole` (新) | - | 激活 | `await activateUserRole(newRole)` | ✅ |
| `appState.currentUserRole` (新) | `showDigitalHuman` | 设置 | `true` | ✅ 如果是数字人类型（激活时） |

**代码位置：** `src/components/ConfigPanel.vue:3162-3205`

**状态检查：** ✅ **正确**

**关键逻辑：**
```typescript
// 步骤3.1：失活旧角色（清理旧角色的所有状态）
if (appState.currentUserRole) {
  await deactivateUserRole(appState.currentUserRole)
}

// 步骤3.3：只更新 isCurrent 属性，不重新加载所有角色
userRoles.value.forEach(r => {
  r.isCurrent = (r.id === role.id)
})

// 步骤3.4.1：激活新角色（设置新角色的状态）
await activateUserRole(appState.currentUserRole)
```

---

### 步骤10：连接第二个数字人

**调用函数：** `handleConnectUserRoleFromList(role: UserRole)`

**状态变更清单：** 同步骤4

**状态检查：** ✅ **正确**

---

### 步骤11：设置第一个数字人为当前

**调用函数：** `handleSetCurrentUserRole(role: UserRole)`

**状态变更清单：** 同步骤9

**状态检查：** ✅ **正确**

**关键点：** 
- 第二个数字人的连接状态会被清理（通过 `deactivateUserRole`）
- 第一个数字人的显示状态会被激活（通过 `activateUserRole`）
- 但第一个数字人的连接状态（`isConnected`）不会被恢复，需要重新连接

---

### 步骤12：编辑第二个数字人

**调用函数：** `handleSaveUserRole()` - 更新分支

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| 数据库 | - | UPDATE | 更新记录 | ✅ |
| `userRoles[]` (更新角色) | 所有数据库属性 | 更新 | 从API返回的更新值 | ✅ |
| `userRoles[]` (更新角色) | `isConnecting` | 保持 | 保持原值 | ✅ 如果类型未变更 |
| `userRoles[]` (更新角色) | `isConnected` | 检查/清理 | 如果类型变更则 `false`，否则保持 | ✅ |
| `userRoles[]` (更新角色) | `showDigitalHuman` | 检查/清理 | 如果类型变更则 `false`，否则保持 | ✅ |
| `userRoles[]` (更新角色) | `digitalHumanInstance` | 检查/清理 | 如果类型变更则 `null`，否则保持 | ✅ |
| `rendererManager` | `renderers[userRoleId]` | 销毁 | 删除渲染器 | ✅ 如果类型从数字人改为立绘 |
| `appState.currentUserRole` | - | 更新属性 | 更新现有对象的属性 | ✅ 如果更新的是当前角色（保持引用不变） |

**代码位置：** `src/components/ConfigPanel.vue:2983-3047`

**状态检查：** ✅ **正确**

**关键逻辑：**
```typescript
// 如果类型从数字人改为立绘，需要清理数字人状态
if (typeChanged && oldRole?.type === 'digital_human') {
  const userRoleId = `user:${oldRole.id}`
  const renderer = rendererManager.getRenderer(userRoleId)
  if (renderer) {
    if (renderer.disconnect) {
      await renderer.disconnect()
    }
    rendererManager.destroyRenderer(userRoleId)
  }
  // 清理内存状态属性
  oldRole.isConnected = false
  oldRole.showDigitalHuman = false
  oldRole.digitalHumanInstance = null
  oldRole.isConnecting = false
}

// 如果类型未变更，保持内存状态属性
if (!typeChanged && oldRole) {
  // 保持原有的内存状态属性
  userRoles.value[roleIndex].isConnecting = oldRole.isConnecting
  userRoles.value[roleIndex].isConnected = oldRole.isConnected
  userRoles.value[roleIndex].showDigitalHuman = oldRole.showDigitalHuman
  userRoles.value[roleIndex].digitalHumanInstance = oldRole.digitalHumanInstance
}
```

---

### 步骤13：删除第二个数字人

**调用函数：** `handleDeleteUserRole(role: UserRole)`

**状态变更清单：**

| 对象 | 属性 | 变更操作 | 变更值 | 状态 |
|------|------|----------|--------|------|
| `rendererManager` | `renderers[userRoleId]` | 断开 | `renderer.disconnect()` | ✅ 如果角色已连接 |
| `rendererManager` | `renderers[userRoleId]` | 销毁 | 删除渲染器 | ✅ 如果角色已连接 |
| `appState.currentUserRole` | - | 失活 | `await deactivateUserRole(role)` | ✅ 如果删除的是当前角色 |
| `appState.currentUserRole` | - | 清空 | `null` | ✅ 如果删除的是当前角色 |
| 数据库 | - | DELETE | 删除记录 | ✅ |
| `userRoles` | - | 移除 | `userRoles.value.filter(r => r.id !== role.id)` | ✅ |

**代码位置：** `src/components/ConfigPanel.vue:3126-3159`

**状态检查：** ✅ **正确**

**关键逻辑：**
```typescript
// 如果角色已连接，先断开连接和销毁渲染器
if (renderer) {
  if (renderer.disconnect) {
    await renderer.disconnect()
  }
  rendererManager.destroyRenderer(userRoleId)
}

// 如果删除的是当前角色，先失活
if (appState.currentUserRole?.id === role.id) {
  await deactivateUserRole(role)
  appState.currentUserRole = null
}

// 只从列表中移除那个角色，不重新加载所有角色
userRoles.value = userRoles.value.filter(r => r.id !== role.id)
```

---

## 状态依赖关系检查

### 关键依赖关系

1. **连接状态依赖：**
   - `role.isConnected = true` → 必须存在 `rendererManager.getRenderer(roleId)`
   - `role.isConnected = true` → 必须存在 `role.digitalHumanInstance`
   - `role.showDigitalHuman = true` → 必须存在容器DOM元素（通过 `v-if` 控制）

2. **当前角色依赖：**
   - `appState.currentUserRole` → 必须指向 `userRoles` 数组中的某个角色对象
   - `appState.currentUserRole.isCurrent = true` → 必须与数据库中的 `is_current` 字段一致

3. **激活/失活依赖：**
   - `activateUserRole(role)` → 如果角色是数字人类型，会设置 `role.showDigitalHuman = true`
   - `deactivateUserRole(role)` → 如果角色已连接，会断开连接并清理状态

### 潜在问题检查

#### ✅ 问题1：关闭面板后重新打开，状态是否保持？

**检查结果：** ✅ **正确**
- `handleOpenUserRoleManagement()` 不调用 `loadUserRoles()`
- 内存中的连接状态（`isConnected`, `showDigitalHuman`, `digitalHumanInstance`）会被保持

#### ✅ 问题2：切换当前角色时，旧角色的连接状态是否正确清理？

**检查结果：** ✅ **正确**
- `handleSetCurrentUserRole()` 会调用 `deactivateUserRole(oldRole)`
- `deactivateUserDigitalHuman()` 会断开连接、清理状态、销毁渲染器

#### ✅ 问题3：创建角色后，如果自动设置为当前，是否正确激活？

**检查结果：** ✅ **正确**
- 创建角色后，如果 `!appState.currentUserRole`，会自动设置为当前
- 会调用 `activateUserRole(roleInList)` 激活新角色
- 如果是数字人类型，会设置 `showDigitalHuman = true`

#### ✅ 问题4：编辑角色时，如果类型未变更，内存状态是否正确保持？

**检查结果：** ✅ **正确**
- 如果类型未变更，会保持原有的内存状态属性
- 如果类型变更，会清理旧类型的状态

#### ✅ 问题5：删除角色时，如果删除的是当前角色，是否正确清理？

**检查结果：** ✅ **正确**
- 会先断开连接和销毁渲染器
- 会调用 `deactivateUserRole(role)` 失活角色
- 会设置 `appState.currentUserRole = null`

---

## 总结

### 状态维护现状

✅ **所有步骤的状态维护都是正确的**

1. **登录时：** 正确初始化所有角色的内存状态，并恢复已存在的连接状态
2. **创建角色：** 正确初始化新角色的内存状态，如果自动设置为当前，会正确激活
3. **连接数字人：** 正确设置连接状态，错误时会正确回滚
4. **断开连接：** 正确清理所有连接相关状态
5. **切换当前角色：** 正确失活旧角色并激活新角色
6. **编辑角色：** 正确保持或清理内存状态（根据类型是否变更）
7. **删除角色：** 正确清理连接状态和当前角色引用

### 关键设计点

1. **精确更新原则：** 所有操作都只更新相关的对象和属性，不重新加载整个列表
2. **状态恢复机制：** 登录时会检查 `rendererManager` 中是否存在渲染器，恢复连接状态
3. **激活/失活机制：** 通过 `activateUserRole` 和 `deactivateUserRole` 统一管理角色状态
4. **引用一致性：** 更新角色时，保持 `appState.currentUserRole` 的引用指向列表中的对象

### 建议

1. ✅ 当前实现已经符合文档要求
2. ✅ 所有状态依赖关系都正确
3. ✅ 没有发现潜在问题

