# 内存状态同步事件梳理

## 概述
本文档梳理所有需要维护内存状态的事件，包括数据库变更操作和界面操作。内存状态维护对象包括：
- 角色对象（Role/UserRole）：`isConnected`、`showDigitalHuman`、`digitalHumanInstance`、`isConnecting`
- 渲染器管理器（rendererManager）：渲染器实例
- 全局状态（appState）：`currentUserRole`、`currentPartnerRole`
- 角色列表（userRoles/roles）：角色数组

## 一、数据库变更相关操作

### 1.1 用户角色相关

#### 1.1.1 用户登录（handleLogin）
**触发时机：** 用户输入 API Key 登录
**数据库变更：** 无（读取操作）
**需要维护的状态：**
- `userRoles` 数组：从数据库加载
- `appState.currentUserRole`：设置为 `isCurrent=true` 的角色
- 角色对象的数字人属性：初始化（`isConnecting=false`, `isConnected=false`, `showDigitalHuman=false`, `digitalHumanInstance=null`）
- `rendererManager`：无需操作（新登录，无渲染器）
- 激活当前用户角色：调用 `activateUserRole(currentRole)`

#### 1.1.2 用户退出（handleLogout）
**触发时机：** 用户点击退出登录
**数据库变更：** 无
**需要维护的状态：**
- `userRoles` 数组：清空 `[]`
- `appState.currentUserRole`：设置为 `null`
- `roles` 数组：清空 `[]`（伙伴角色列表）
- `appState.currentPartnerRole`：设置为 `null`
- 所有用户角色的数字人状态：需要清理
- 所有伙伴角色的数字人状态：需要清理
- `rendererManager`：
  - 销毁所有用户角色相关的渲染器（`user:${role.id}`）
  - 销毁所有伙伴角色相关的渲染器（`partner:${role.user}`）
- 失活当前用户角色：如果存在，调用 `deactivateUserRole(currentRole)`
- 失活当前伙伴角色：如果存在，调用 `deactivatePartnerRole(currentPartnerRole)`
- `appState.chatHistory`：清空 `[]`
- `appState.llm.apiKey`：清空 `''`
- `appState.llm.user`：清空 `''`

#### 1.1.3 创建用户角色（handleSaveUserRole - 新建）
**触发时机：** 用户在编辑表单中创建新角色
**数据库变更：** INSERT 新记录
**需要维护的状态：**
- `userRoles` 数组：重新加载（`loadUserRoles()`）
- `appState.currentUserRole`：如果之前为空，自动设置为新创建的角色
- 新角色的数字人属性：初始化（默认值）
- `rendererManager`：无需操作（新角色，无渲染器）
- 如果设置为当前角色：调用 `activateUserRole(newRole)`

#### 1.1.4 更新用户角色（handleSaveUserRole - 编辑）
**触发时机：** 用户在编辑表单中更新角色
**数据库变更：** UPDATE 记录
**需要维护的状态：**
- `userRoles` 数组：重新加载（`loadUserRoles()`）
- `appState.currentUserRole`：如果更新的是当前角色，需要更新引用
- 更新角色的数字人属性：
  - **如果角色类型从数字人改为立绘**：需要清理数字人状态和渲染器
  - **如果角色类型从立绘改为数字人**：初始化数字人属性
  - **如果更新的是已连接的数字人**：需要检查渲染器是否需要重新创建（配置变更）
- `rendererManager`：
  - 如果角色类型变更或配置变更，可能需要销毁旧渲染器
  - 如果角色已连接，需要更新渲染器配置或重新创建

#### 1.1.5 删除用户角色（handleDeleteUserRole）
**触发时机：** 用户在角色列表中删除角色
**数据库变更：** DELETE 记录
**需要维护的状态：**
- `userRoles` 数组：重新加载（`loadUserRoles()`）
- `appState.currentUserRole`：
  - 如果删除的是当前角色：设置为 `null` 或自动选择其他角色
  - 否则：保持不变
- 被删除角色的数字人状态：需要清理
- `rendererManager`：销毁被删除角色的渲染器（`user:${role.id}`）
- 如果删除的是当前角色：调用 `deactivateUserRole(deletedRole)`

#### 1.1.6 设置当前用户角色（handleSetCurrentUserRole）
**触发时机：** 用户在角色列表中点击"设为当前"
**数据库变更：** UPDATE `is_current` 字段
**需要维护的状态：**
- `userRoles` 数组：重新加载（`loadUserRoles()`）
- `appState.currentUserRole`：更新为新角色
- 旧角色的数字人状态：失活（`deactivateUserRole(oldRole)`）
- 新角色的数字人状态：激活（`activateUserRole(newRole)`）
- `rendererManager`：
  - 旧角色的渲染器：如果存在，销毁或保留（取决于策略）
  - 新角色的渲染器：如果已存在，恢复状态；否则不创建（等待用户连接）

### 1.2 伙伴角色相关

#### 1.2.1 创建伙伴角色（handleSaveRole - 新建）
**触发时机：** 用户在编辑表单中创建新角色
**数据库变更：** INSERT 新记录
**需要维护的状态：**
- `roles` 数组：重新加载（`loadRoles()`）
- `appState.currentPartnerRole`：如果之前为空，可能需要自动设置
- 新角色的数字人属性：初始化（默认值）
- `rendererManager`：无需操作（新角色，无渲染器）

#### 1.2.2 更新伙伴角色（handleSaveRole - 编辑）
**触发时机：** 用户在编辑表单中更新角色
**数据库变更：** UPDATE 记录
**需要维护的状态：**
- `roles` 数组：重新加载（`loadRoles()`）
- `appState.currentPartnerRole`：如果更新的是当前角色，需要更新引用
- 更新角色的数字人属性：
  - **如果角色类型从数字人改为立绘**：需要清理数字人状态和渲染器
  - **如果角色类型从立绘改为数字人**：初始化数字人属性
  - **如果更新的是已连接的数字人**：需要检查渲染器是否需要重新创建（配置变更）
- `rendererManager`：
  - 如果角色类型变更或配置变更，可能需要销毁旧渲染器
  - 如果角色已连接，需要更新渲染器配置或重新创建

#### 1.2.3 删除伙伴角色（handleDeleteRole）
**触发时机：** 用户在角色列表中删除角色
**数据库变更：** DELETE 记录
**需要维护的状态：**
- `roles` 数组：重新加载（`loadRoles()`）
- `appState.currentPartnerRole`：
  - 如果删除的是当前角色：设置为 `null` 或自动选择其他角色
  - 否则：保持不变
- 被删除角色的数字人状态：需要清理
- `rendererManager`：销毁被删除角色的渲染器（`partner:${role.user}`）
- 如果删除的是当前角色：调用 `deactivatePartnerRole(deletedRole)`

#### 1.2.4 设置当前伙伴角色（handleSetCurrentRole）
**触发时机：** 用户在角色列表中点击"设为当前"
**数据库变更：** 无（前端直接设置 `appState.llm.user`）
**需要维护的状态：**
- `roles` 数组：重新加载（`loadRoles()`）
- `appState.currentPartnerRole`：更新为新角色
- `appState.llm.user`：更新为 `role.user`
- 旧角色的数字人状态：失活（`deactivatePartnerRole(oldRole)`）
- 新角色的数字人状态：激活（`activatePartnerRole(newRole)`）
- `rendererManager`：
  - 旧角色的渲染器：如果存在，销毁或保留（取决于策略）
  - 新角色的渲染器：如果已存在，恢复状态；否则不创建（等待用户连接）

## 二、界面操作相关

### 2.1 用户角色数字人操作

#### 2.1.1 连接用户角色数字人（handleConnectUserRoleFromList）
**触发时机：** 用户在角色列表中点击"连接"按钮
**数据库变更：** 无
**需要维护的状态：**
- 角色对象的 `isConnecting`：设置为 `true`（连接中）
- 角色对象的 `showDigitalHuman`：设置为 `true`（显示容器）
- `rendererManager`：
  - 检查是否存在渲染器（`getRenderer(userRoleId)`）
  - 如果不存在，创建渲染器（`createRenderer(userRoleId, config)`）
  - 调用 `renderer.render(containerElement)` 设置容器
  - 调用 `renderer.connect()` 连接SDK
- 角色对象的 `digitalHumanInstance`：保存渲染器实例（`renderer.getInstance()`）
- 角色对象的 `isConnected`：设置为 `true`
- 角色对象的 `isConnecting`：设置为 `false`（连接完成）

#### 2.1.2 断开用户角色数字人（handleDisconnectUserRoleFromList）
**触发时机：** 用户在角色列表中点击"断开"按钮
**数据库变更：** 无
**需要维护的状态：**
- `rendererManager`：
  - 获取渲染器（`getRenderer(userRoleId)`）
  - 调用 `renderer.disconnect()` 断开连接
  - 调用 `renderer.hide()` 隐藏数字人
  - **可选**：销毁渲染器（`destroyRenderer(userRoleId)`）或保留以便后续重新连接
- 角色对象的 `showDigitalHuman`：设置为 `false`
- 角色对象的 `digitalHumanInstance`：设置为 `null`
- 角色对象的 `isConnected`：设置为 `false`

#### 2.1.3 切换用户数字人显示/隐藏（toggleIllustration - 用户数字人）
**触发时机：** 用户点击切换按钮
**数据库变更：** 无
**需要维护的状态：**
- 角色对象的 `showDigitalHuman`：切换状态（`!role.showDigitalHuman`）
- `rendererManager`：无需操作（渲染器已存在，只切换显示状态）

### 2.2 伙伴角色数字人操作

#### 2.2.1 连接伙伴角色数字人（handleConnectRoleFromList）
**触发时机：** 用户在角色列表中点击"连接"按钮
**数据库变更：** 无
**需要维护的状态：**
- 角色对象的 `isConnecting`：设置为 `true`（连接中）
- 角色对象的 `showDigitalHuman`：设置为 `true`（显示容器）
- `rendererManager`：
  - 检查是否存在渲染器（`getRenderer(partnerRoleId)`）
  - 如果不存在，创建渲染器（`createRenderer(partnerRoleId, config)`）
  - 调用 `renderer.render(containerElement)` 设置容器
  - 调用 `renderer.connect()` 连接SDK
- 角色对象的 `digitalHumanInstance`：保存渲染器实例（`renderer.getInstance()`）
- 角色对象的 `isConnected`：设置为 `true`
- 角色对象的 `isConnecting`：设置为 `false`（连接完成）

#### 2.2.2 断开伙伴角色数字人（handleDisconnectRoleFromList）
**触发时机：** 用户在角色列表中点击"断开"按钮
**数据库变更：** 无
**需要维护的状态：**
- `rendererManager`：
  - 获取渲染器（`getRenderer(partnerRoleId)`）
  - 调用 `renderer.disconnect()` 断开连接
  - 调用 `renderer.hide()` 隐藏数字人
  - **可选**：销毁渲染器（`destroyRenderer(partnerRoleId)`）或保留以便后续重新连接
- 角色对象的 `showDigitalHuman`：设置为 `false`
- 角色对象的 `digitalHumanInstance`：设置为 `null`
- 角色对象的 `isConnected`：设置为 `false`

#### 2.2.3 切换伙伴数字人显示/隐藏（toggleIllustration - 伙伴数字人）
**触发时机：** 用户点击切换按钮
**数据库变更：** 无
**需要维护的状态：**
- 角色对象的 `showDigitalHuman`：切换状态（`!role.showDigitalHuman`）
- `rendererManager`：无需操作（渲染器已存在，只切换显示状态）

## 三、状态维护对象总结

### 3.1 角色对象（Role/UserRole）
需要维护的属性：
- `isConnecting?: boolean` - 是否正在连接
- `isConnected?: boolean` - 是否已连接
- `showDigitalHuman?: boolean` - 是否显示数字人容器
- `digitalHumanInstance?: DigitalHumanInstance | null` - 数字人SDK实例引用

### 3.2 渲染器管理器（rendererManager）
需要维护的状态：
- 渲染器实例 Map：`key = roleId`（`user:${id}` 或 `partner:${user}`），`value = IRenderer`
- 操作：
  - `getRenderer(roleId)` - 获取渲染器
  - `createRenderer(roleId, config)` - 创建渲染器
  - `destroyRenderer(roleId)` - 销毁渲染器

### 3.3 全局状态（appState）
需要维护的状态：
- `appState.currentUserRole: UserRole | null` - 当前用户角色
- `appState.currentPartnerRole: Role | null` - 当前伙伴角色

### 3.4 角色列表（userRoles/roles）
需要维护的状态：
- `userRoles: UserRole[]` - 用户角色列表
- `roles: Role[]` - 伙伴角色列表

## 四、关键问题点

### 4.1 数据库变更后的状态恢复
**问题：** 当从数据库重新加载角色列表时，会创建新对象，丢失内存中的连接状态。
**解决方案：** 
- 在 `loadUserRoles()` 和 `loadRoles()` 中，检查 `rendererManager` 是否存在渲染器
- 如果存在，恢复角色对象的连接状态（`isConnected=true`, `showDigitalHuman=true`, `digitalHumanInstance=instance`）

### 4.2 角色类型变更时的清理
**问题：** 当角色类型从数字人改为立绘时，需要清理数字人相关状态和渲染器。
**解决方案：**
- 在更新角色时，检查类型是否变更
- 如果从数字人改为立绘：清理数字人状态，销毁渲染器
- 如果从立绘改为数字人：初始化数字人属性

### 4.3 当前角色切换时的状态迁移
**问题：** 切换当前角色时，需要失活旧角色、激活新角色，但渲染器可能已存在。
**解决方案：**
- 失活旧角色：清理状态，销毁渲染器（或保留，取决于策略）
- 激活新角色：如果渲染器已存在，恢复状态；否则只设置显示状态（不连接）

### 4.4 角色删除时的清理
**问题：** 删除角色时，需要清理所有相关状态和渲染器。
**解决方案：**
- 如果删除的是当前角色：先失活，再删除
- 销毁渲染器：`rendererManager.destroyRenderer(roleId)`
- 清理角色对象的状态（如果对象还存在）

## 五、待实现的状态同步逻辑

### 5.1 loadUserRoles() 中的状态恢复
```typescript
// 在初始化属性后，检查渲染器是否存在
roleList.forEach(role => {
  // ... 初始化属性 ...
  
  // 检查渲染器是否存在（恢复连接状态）
  const roleId = `user:${role.id}`
  const renderer = rendererManager.getRenderer(roleId)
  if (renderer) {
    // 渲染器存在，恢复连接状态
    role.isConnected = true
    role.showDigitalHuman = true
    if (renderer instanceof DigitalHumanRenderer) {
      role.digitalHumanInstance = renderer.getInstance()
    }
  }
})
```

### 5.2 loadRoles() 中的状态恢复
```typescript
// 在初始化属性后，检查渲染器是否存在
roleList.forEach(role => {
  // ... 初始化属性 ...
  
  // 检查渲染器是否存在（恢复连接状态）
  const roleId = `partner:${role.user}`
  const renderer = rendererManager.getRenderer(roleId)
  if (renderer) {
    // 渲染器存在，恢复连接状态
    role.isConnected = true
    role.showDigitalHuman = true
    if (renderer instanceof DigitalHumanRenderer) {
      role.digitalHumanInstance = renderer.getInstance()
    }
  }
})
```

### 5.3 更新角色时的类型变更检查
```typescript
// 在 handleSaveUserRole 和 handleSaveRole 中
if (editingRole) {
  const oldRole = userRoles.value.find(r => r.id === editingRole.id)
  const typeChanged = oldRole?.type !== roleForm.value.type
  
  if (typeChanged && oldRole?.type === 'digital_human') {
    // 从数字人改为立绘：清理数字人状态
    const roleId = `user:${oldRole.id}`
    const renderer = rendererManager.getRenderer(roleId)
    if (renderer) {
      await renderer.disconnect()
      rendererManager.destroyRenderer(roleId)
    }
  }
  
  // 更新数据库
  await updateUserRole(...)
  
  // 重新加载列表
  await loadUserRoles()
}
```

