# 打开伙伴角色管理面板导致用户角色数字人消失问题分析

## 一、问题描述

当打开"伙伴角色管理"面板时，已经连接并显示的用户角色数字人会消失。

## 二、问题根源

### 2.1 核心问题

在 `AvatarRender.vue` 中的 `setupUserDigitalHumanRenderer` 函数存在逻辑缺陷：

```typescript:240:300:src/components/AvatarRender.vue
async function setupUserDigitalHumanRenderer(role: UserRole | null) {
  if (!containerRef.value) return

  // 销毁旧的渲染器
  if (userDigitalHumanRenderer.value && appState.currentUserRole) {
    const roleId = `user:${appState.currentUserRole.id}`
    
    // 清理角色对象上的状态
    appState.currentUserRole.showDigitalHuman = false  // ❌ 问题：无条件清理状态
    appState.currentUserRole.digitalHumanInstance = null
    appState.currentUserRole.isConnected = false
    
    // 销毁渲染器
    rendererManager.destroyRenderer(roleId)
    userDigitalHumanRenderer.value = null
  }

  // 如果角色是数字人类型，创建渲染器
  if (role && role.type === 'digital_human') {
    // ... 创建新渲染器
  }
}
```

**问题分析：**

1. **无条件销毁逻辑**：只要 `userDigitalHumanRenderer.value && appState.currentUserRole` 存在，就会销毁旧的渲染器并清理状态，**即使角色没有变化**。

2. **缺少角色比较**：函数没有检查传入的 `role` 是否与 `appState.currentUserRole` 是同一个角色，导致即使角色相同也会销毁并重新创建。

3. **状态丢失**：销毁时会设置 `showDigitalHuman = false`，即使后续重新创建渲染器，也不会自动恢复连接状态和显示状态。

### 2.2 触发路径

**路径1：`roleUpdated` 事件触发**

```typescript:309:314:src/components/AvatarRender.vue
const handleRoleUpdated = async () => {
  await setupPartnerDigitalHumanRenderer(appState.currentPartnerRole)
  await setupUserDigitalHumanRenderer(appState.currentUserRole)  // ❌ 无条件调用
}
```

当打开伙伴角色管理面板时，如果触发了 `roleUpdated` 事件（虽然 `handleOpenRoleManagement` 没有直接触发，但可能有其他代码触发），就会调用 `setupUserDigitalHumanRenderer`。

**路径2：watch 监听器触发**

```typescript:322:324:src/components/AvatarRender.vue
watch(() => appState.currentUserRole, async (newRole) => {
  await setupUserDigitalHumanRenderer(newRole)  // ❌ 即使角色引用相同也会触发
})
```

如果 `appState.currentUserRole` 的引用发生变化（即使对象内容相同），watch 也会触发。

**路径3：`appState.llm.user` 或 `appState.llm.apiKey` 变化**

```typescript:303:307:src/components/AvatarRender.vue
watch([() => appState.llm.user, () => appState.llm.apiKey], async () => {
  await loadCurrentPartnerRole()
  await setupPartnerDigitalHumanRenderer(appState.currentPartnerRole)
  await setupUserDigitalHumanRenderer(appState.currentUserRole)  // ❌ 无条件调用
}, { immediate: true })
```

如果打开伙伴角色管理面板时，`appState.llm.user` 或 `appState.llm.apiKey` 发生变化，也会触发。

## 三、容器操作流程

### 3.1 当前流程（有问题）

1. **打开伙伴角色管理面板** → `handleOpenRoleManagement()`
2. **可能触发 `roleUpdated` 事件或其他 watch** → `handleRoleUpdated()` 或 watch 回调
3. **调用 `setupUserDigitalHumanRenderer(appState.currentUserRole)`**
4. **检查条件**：`if (userDigitalHumanRenderer.value && appState.currentUserRole)`
5. **销毁旧渲染器**：
   - 设置 `appState.currentUserRole.showDigitalHuman = false` ❌
   - 设置 `appState.currentUserRole.digitalHumanInstance = null`
   - 设置 `appState.currentUserRole.isConnected = false`
   - 调用 `rendererManager.destroyRenderer(roleId)`
   - 设置 `userDigitalHumanRenderer.value = null`
6. **重新创建渲染器**（如果角色是数字人类型）
7. **但是不会恢复连接状态和显示状态** ❌

### 3.2 问题影响

- ✅ 容器在DOM中（由 `v-if` 控制，`showDigitalHuman = false` 时容器被移除）
- ❌ 用户角色数字人消失（`showDigitalHuman = false` 导致容器不显示）
- ❌ 连接状态丢失（`isConnected = false`）
- ❌ SDK实例丢失（`digitalHumanInstance = null`）

## 四、修复方案

### 4.1 方案1：添加角色比较（推荐）

在 `setupUserDigitalHumanRenderer` 中添加角色比较，只有当角色真正变化时才销毁旧渲染器：

```typescript
async function setupUserDigitalHumanRenderer(role: UserRole | null) {
  if (!containerRef.value) return

  // 销毁旧的渲染器（只有当角色真正变化时）
  if (userDigitalHumanRenderer.value && appState.currentUserRole) {
    // ✅ 添加角色比较：只有当角色ID不同时才销毁
    const oldRoleId = `user:${appState.currentUserRole.id}`
    const newRoleId = role ? `user:${role.id}` : null
    
    // 如果角色相同，不需要销毁和重新创建
    if (oldRoleId === newRoleId && role && role.type === 'digital_human') {
      // 角色相同且类型相同，保持现有状态，不重新创建
      return
    }
    
    // 角色不同，销毁旧渲染器
    const roleId = oldRoleId
    
    // 清理角色对象上的状态
    appState.currentUserRole.showDigitalHuman = false
    appState.currentUserRole.digitalHumanInstance = null
    appState.currentUserRole.isConnected = false
    
    // 销毁渲染器
    rendererManager.destroyRenderer(roleId)
    userDigitalHumanRenderer.value = null
  }

  // ... 后续创建逻辑
}
```

### 4.2 方案2：恢复连接状态

在重新创建渲染器后，如果角色已连接，恢复连接状态：

```typescript
// 如果角色是数字人类型，创建渲染器
if (role && role.type === 'digital_human') {
  // ... 创建渲染器
  
  // ✅ 如果角色之前已连接，恢复连接状态
  if (role.isConnected && role.showDigitalHuman) {
    // 恢复显示状态
    role.showDigitalHuman = true
    // 如果渲染器支持，可以尝试恢复连接
    // 注意：SDK连接状态可能需要重新连接
  }
}
```

### 4.3 方案3：避免不必要的调用

在 `handleRoleUpdated` 中添加检查，避免不必要的调用：

```typescript
const handleRoleUpdated = async () => {
  // ✅ 只有当角色真正变化时才调用
  // 注意：这里需要比较角色ID，而不是引用
  await setupPartnerDigitalHumanRenderer(appState.currentPartnerRole)
  await setupUserDigitalHumanRenderer(appState.currentUserRole)
}
```

## 五、推荐修复

**推荐使用方案1（添加角色比较）**，因为：

1. **最根本的修复**：从根源上避免不必要的销毁和重新创建
2. **性能优化**：避免不必要的渲染器销毁和创建
3. **状态保持**：保持现有的连接状态和显示状态
4. **符合"精确更新"原则**：只有当角色真正变化时才更新

## 六、需要同步修复的函数

同样的问题也存在于 `setupPartnerDigitalHumanRenderer` 函数中，需要同步修复。

## 七、测试验证

修复后需要验证：

1. ✅ 打开伙伴角色管理面板时，用户角色数字人不会消失
2. ✅ 打开用户角色管理面板时，伙伴角色数字人不会消失
3. ✅ 切换角色时，正确销毁旧角色并创建新角色
4. ✅ 角色相同时，不重新创建渲染器，保持现有状态

