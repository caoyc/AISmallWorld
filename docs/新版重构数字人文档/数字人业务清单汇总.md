# 数字人业务清单汇总

## 核心原则

**完全照抄立绘的业务逻辑，数字人只需要在容器显示时连接SDK，其他逻辑与立绘完全一致。**

---

# 一、入口1：APIKey登录后获取当前角色

## 1.1 入口函数

**位置：** `ConfigPanel.vue` - `handleApiKeyLogin()` 函数（约第2845行）

**完整代码流程：**
```typescript
async function handleApiKeyLogin() {
  // 1. 验证输入
  if (!loginApiKeyInput.value || !loginApiKeyInput.value.trim()) {
    showToastMessage('请输入 API Key', 'error')
    return
  }
  
  try {
    // 2. 设置全局APIKey
    globalApiKey.value = loginApiKeyInput.value.trim()
    appState.llm.apiKey = globalApiKey.value
    
    // 3. 加载用户角色列表
    await loadUserRoles()
    // loadUserRoles() 内部会：
    //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
    //   - 查找 isCurrent === true 的角色
    //   - 设置 appState.currentUserRole = currentRole
    //   - 应用用户角色的大模型配置到 appState.llm
    
    // 4. 检查是否有当前用户角色
    if (!appState.currentUserRole) {
      // 4.1 没有当前用户角色：弹出角色创建面板
      showApiKeyLoginModal.value = false
      showUserRoleManagementModal.value = true
      showUserRoleEditForm.value = true
      // 初始化表单...
      showToastMessage('请先创建用户角色', 'info')
    } else {
      // 4.2 有当前用户角色：加载数据
      // 4.2.1 加载伙伴角色列表
      await loadRoles()
      // loadRoles() 内部会：
      //   - 调用 getRoles(globalApiKey.value) 获取角色列表
      //   - 设置 roles.value = roleList
      
      // 4.2.2 获取并设置当前伙伴角色
      await getAndSetCurrentPartnerRole()
      // getAndSetCurrentPartnerRole() 内部会：
      //   - 从 localStorage 恢复 appState.llm.user（如果存在且对应的角色存在）
      //   - 设置 appState.llm.user = config.llm.user
      
      // 4.2.3 加载对话历史
      await loadHistory()
      
      // 4.2.4 触发角色更新事件
      const event = new CustomEvent('roleUpdated')
      window.dispatchEvent(event)
      // 这个事件会被 AvatarRender.vue 的 handleRoleUpdated 监听
      
      showApiKeyLoginModal.value = false
      showToastMessage('登录成功', 'success')
    }
    
    loginApiKeyInput.value = ''
  } catch (error) {
    globalApiKey.value = ''
    appState.llm.apiKey = ''
  }
}
```

## 1.2 立绘的业务逻辑（参考）

**立绘在登录后做什么：**
- ✅ **什么都不做**：立绘通过 `v-if` 和计算属性自动响应 `appState.currentPartnerRole` 和 `appState.currentUserRole` 的变化
- ✅ **自动显示**：当 `appState.currentPartnerRole` 或 `appState.currentUserRole` 有值时，立绘自动显示（如果 `showPartnerIllustration` 或 `showUserIllustration` 为 true）

## 1.3 数字人的业务清单（照抄立绘）

### ✅ 清单1：什么都不做（与立绘一致）

**原因：**
- 数字人容器在模板中定义，使用 `v-if` 控制显示
- 当 `appState.currentPartnerRole` 或 `appState.currentUserRole` 变化时，容器自动创建/销毁
- SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

**代码位置：** 不需要在 `handleApiKeyLogin()` 中添加任何数字人相关代码

### ✅ 清单2：确保 `appState.currentPartnerRole` 和 `appState.currentUserRole` 正确设置

**当前实现：**
- ✅ `loadUserRoles()` 已设置 `appState.currentUserRole`
- ❌ `getAndSetCurrentPartnerRole()` 只设置了 `appState.llm.user`，未设置 `appState.currentPartnerRole`

**需要修改：**
- ⚠️ `getAndSetCurrentPartnerRole()` 中需要根据 `appState.llm.user` 查找对应的角色并设置 `appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user)`

### ✅ 清单3：触发 `roleUpdated` 事件（已实现）

**当前实现：**
```typescript
const event = new CustomEvent('roleUpdated')
window.dispatchEvent(event)
```

**作用：**
- 通知 `AvatarRender.vue` 角色已更新
- `AvatarRender.vue` 的 `handleRoleUpdated` 会调用 `setupPartnerDigitalHumanRenderer` 和 `setupUserDigitalHumanRenderer`

**重构后：**
- ✅ 保留 `roleUpdated` 事件
- ✅ `handleRoleUpdated` 中只需要确保容器显示状态正确（通过 `v-if` 自动处理）
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

---

# 二、入口2：切换角色时

## 2.1 切换用户角色

**位置：** `ConfigPanel.vue` - `handleSetCurrentUserRole()` 函数（约第3157行）

**完整代码流程：**
```typescript
async function handleSetCurrentUserRole(role: UserRole) {
  try {
    // 【需要删除】切换时清理之前的数字人连接和容器
    // 这部分代码应该删除，因为：
    // 1. 容器在模板中定义，通过 v-if 自动销毁
    // 2. SDK连接逻辑在 watch 中处理，容器销毁时自动断开
    if (appState.currentUserRole) {
      const oldUserRoleId = `user:${appState.currentUserRole.id}`
      const oldRenderer = rendererManager.getRenderer(oldUserRoleId)
      if (oldRenderer) {
        // 断开连接
        if (oldRenderer.disconnect) {
          await oldRenderer.disconnect()
        }
        // 隐藏数字人
        oldRenderer.hide()
        appState.avatar.showUserDigitalHuman = false
        // 清理状态
        appState.avatar.instances.delete(oldUserRoleId)
        appState.avatar.connectedRoles.delete(oldUserRoleId)
        // 销毁渲染器和容器
        rendererManager.destroyRenderer(oldUserRoleId)
      }
    }
    
    // 1. 设置当前用户角色（调用API）
    await setCurrentUserRole(role.id, globalApiKey.value)
    
    // 2. 重新加载用户角色列表
    await loadUserRoles()
    // loadUserRoles() 内部会：
    //   - 调用 getUserRoles(globalApiKey.value) 获取角色列表
    //   - 查找 isCurrent === true 的角色
    //   - 设置 appState.currentUserRole = currentRole
    
    // 3. 记录当前角色（确保同步）
    appState.currentUserRole = role
    
    // 4. 应用用户角色的大模型配置到全局状态
    if (role.baseURL) {
      appState.llm.baseURL = role.baseURL
    }
    if (role.model) {
      appState.llm.model = role.model
    }
    appState.llm.apiKey = globalApiKey.value
    
    // 5. 保存配置
    handleSaveConfig()
    
    // 6. 触发角色更新事件
    const event = new CustomEvent('roleUpdated')
    window.dispatchEvent(event)
    
    showToastMessage(`已切换到用户角色"${role.name || '(未命名)'}"`, 'success')
  } catch (error) {
    showToastMessage((error as Error).message, 'error')
  }
}
```

## 2.2 切换伙伴角色

**位置：** `ConfigPanel.vue` - `handleSetCurrentRole()` 函数（约第3719行）

**完整代码流程：**
```typescript
async function handleSetCurrentRole(role: Role) {
  // 【需要删除】切换时清理之前的数字人连接和容器
  // 这部分代码应该删除，原因同 handleSetCurrentUserRole
  if (appState.llm.user) {
    const oldPartnerRoleId = `partner:${appState.llm.user}`
    const oldRenderer = rendererManager.getRenderer(oldPartnerRoleId)
    if (oldRenderer) {
      // 断开连接
      if (oldRenderer.disconnect) {
        await oldRenderer.disconnect()
      }
      // 隐藏数字人
      oldRenderer.hide()
      appState.avatar.showPartnerDigitalHuman = false
      // 清理状态
      appState.avatar.instances.delete(oldPartnerRoleId)
      appState.avatar.connectedRoles.delete(oldPartnerRoleId)
      // 销毁渲染器和容器
      rendererManager.destroyRenderer(oldPartnerRoleId)
    }
  }
  
  // 1. 记录当前角色
  appState.llm.user = role.user
  // 【需要添加】同时设置 appState.currentPartnerRole = role
  
  // 2. 应用角色的大模型配置
  if (role.baseURL !== undefined && role.baseURL !== null && role.baseURL.trim()) {
    appState.llm.baseURL = role.baseURL
  }
  if (role.model !== undefined && role.model !== null && role.model.trim()) {
    appState.llm.model = role.model
  }
  if (role.apiKey !== undefined && role.apiKey !== null && role.apiKey.trim()) {
    appState.llm.apiKey = role.apiKey
  }
  
  // 3. 保存配置
  handleSaveConfig()
  
  // 4. 重新加载角色列表
  await loadRoles()
  
  // 5. 切换当前伙伴角色时，同时切换历史记录
  await loadHistory()
  
  // 6. 触发角色更新事件
  const event = new CustomEvent('roleUpdated')
  window.dispatchEvent(event)
  
  showToastMessage(`已切换到角色"${role.name || role.user}"`, 'success')
}
```

## 2.3 立绘的业务逻辑（参考）

**立绘在切换角色时做什么：**
- ✅ **什么都不做**：立绘通过 `v-if` 和计算属性自动响应 `appState.currentPartnerRole` 和 `appState.currentUserRole` 的变化
- ✅ **自动切换**：当 `appState.currentPartnerRole` 或 `appState.currentUserRole` 变化时，立绘自动切换显示

## 2.4 数字人的业务清单（照抄立绘）

### ✅ 清单1：什么都不做（与立绘一致）

**原因：**
- 数字人容器在模板中定义，使用 `v-if` 控制显示
- 当 `appState.currentPartnerRole` 或 `appState.currentUserRole` 变化时，容器自动销毁/创建
- SDK连接逻辑在 `watch` 中处理，容器销毁时自动断开，容器创建时自动连接

**代码位置：** 不需要在 `handleSetCurrentUserRole()` 和 `handleSetCurrentRole()` 中添加任何数字人相关代码

### ✅ 清单2：确保 `appState.currentPartnerRole` 和 `appState.currentUserRole` 正确设置

**当前实现：**
- ✅ `handleSetCurrentUserRole()` 已设置 `appState.currentUserRole = role`
- ❌ `handleSetCurrentRole()` 未设置 `appState.currentPartnerRole`，只设置了 `appState.llm.user = role.user`

**需要修改：**
```typescript
// handleSetCurrentRole() 中需要添加：
appState.currentPartnerRole = role
```

### ✅ 清单3：触发 `roleUpdated` 事件（已实现）

**当前实现：**
```typescript
const event = new CustomEvent('roleUpdated')
window.dispatchEvent(event)
```

**作用：**
- 通知 `AvatarRender.vue` 角色已更新
- `AvatarRender.vue` 的 `handleRoleUpdated` 会调用 `setupPartnerDigitalHumanRenderer` 和 `setupUserDigitalHumanRenderer`

**重构后：**
- ✅ 保留 `roleUpdated` 事件
- ✅ `handleRoleUpdated` 中只需要确保容器显示状态正确（通过 `v-if` 自动处理）
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

### ✅ 清单4：删除清理代码（重要）

**需要删除的代码：**

**在 `handleSetCurrentUserRole()` 中（约第3159-3177行）：**
```typescript
// 删除以下代码
if (appState.currentUserRole) {
  const oldUserRoleId = `user:${appState.currentUserRole.id}`
  const oldRenderer = rendererManager.getRenderer(oldUserRoleId)
  if (oldRenderer) {
    // 断开连接
    if (oldRenderer.disconnect) {
      await oldRenderer.disconnect()
    }
    // 隐藏数字人
    oldRenderer.hide()
    appState.avatar.showUserDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(oldUserRoleId)
    appState.avatar.connectedRoles.delete(oldUserRoleId)
    // 销毁渲染器和容器
    rendererManager.destroyRenderer(oldUserRoleId)
  }
}
```

**在 `handleSetCurrentRole()` 中（约第3720-3738行）：**
```typescript
// 删除以下代码
if (appState.llm.user) {
  const oldPartnerRoleId = `partner:${appState.llm.user}`
  const oldRenderer = rendererManager.getRenderer(oldPartnerRoleId)
  if (oldRenderer) {
    // 断开连接
    if (oldRenderer.disconnect) {
      await oldRenderer.disconnect()
    }
    // 隐藏数字人
    oldRenderer.hide()
    appState.avatar.showPartnerDigitalHuman = false
    // 清理状态
    appState.avatar.instances.delete(oldPartnerRoleId)
    appState.avatar.connectedRoles.delete(oldPartnerRoleId)
    // 销毁渲染器和容器
    rendererManager.destroyRenderer(oldPartnerRoleId)
  }
}
```

**删除原因：**
- ❌ 容器在模板中定义，通过 `v-if` 自动销毁，不需要手动清理
- ❌ SDK连接逻辑在 `watch` 中处理，容器销毁时自动断开，不需要手动断开
- ❌ 手动清理会导致与 `v-if` 冲突，引发联动问题
- ❌ 这是导致数字人联动问题的根源之一

---

# 三、连接按钮点击事件

## 3.1 两个连接函数

### 1. `handleConnectRoleFromList` - 伙伴角色列表连接按钮

**位置：** `ConfigPanel.vue` - 约第1812行

**调用位置：** 伙伴角色列表中的"连接"按钮（约第684行）

### 2. `handleConnectUserRoleFromList` - 用户角色列表连接按钮

**位置：** `ConfigPanel.vue` - 约第2036行

**调用位置：** 用户角色列表中的"连接"按钮（约第1072行）

## 3.2 应有且只应有的业务清单

### ✅ 清单1：基础验证

**应该做的：**
1. ✅ 检查是否正在连接（防止重复点击）
2. ✅ 检查SDK是否已加载（`window.XmovAvatar`）
3. ✅ 检查角色是否配置了 `avatarAppId` 和 `avatarAppSecret`
4. ✅ 检查该角色是否已连接（`appState.avatar.connectedRoles.has(roleId)`）
5. ✅ 检查该角色是否为当前角色（只有当前角色可以连接）
6. ✅ 检查当前角色类型是否为数字人

**代码示例：**
```typescript
// 1. 检查是否正在连接
if (isConnecting.value) return

// 2. 检查SDK是否已加载
if (!window.XmovAvatar) {
  showToastMessage('SDK未加载，请刷新页面重试', 'error')
  return
}

// 3. 检查角色是否配置了 appId 和 appSecret
if (!role.avatarAppId || !role.avatarAppSecret) {
  showToastMessage('请先配置数字人的 App ID 和 App Secret', 'error')
  return
}

// 4. 检查该角色是否已连接
const roleId = `partner:${role.user}` // 或 `user:${role.id}`
if (appState.avatar.connectedRoles.has(roleId)) {
  showToastMessage('该角色已连接', 'info')
  return
}

// 5. 检查该角色是否为当前角色
if (!appState.currentPartnerRole || appState.currentPartnerRole.user !== role.user) {
  showToastMessage('只有当前角色可以连接', 'error')
  return
}

// 6. 检查当前角色类型是否为数字人
if (appState.currentPartnerRole.type !== 'digital_human') {
  showToastMessage('当前角色类型不是数字人', 'error')
  return
}
```

### ✅ 清单2：获取或创建渲染器

**应该做的：**
1. ✅ 获取渲染器（如果已存在）
2. ✅ 如果不存在，创建渲染器（使用角色的配置）

**代码示例：**
```typescript
const roleId = `partner:${role.user}` // 或 `user:${role.id}`

// 获取或创建渲染器
let renderer = rendererManager.getRenderer(roleId)
if (!renderer) {
  // 创建渲染器
  renderer = await rendererManager.createRenderer(roleId, {
    roleId,
    roleType: 'digital_human',
    positionX: role.positionX !== undefined ? role.positionX : 50,
    positionY: role.positionY !== undefined ? role.positionY : 50,
    scale: role.scale !== undefined ? role.scale : 1.0,
    avatarAppId: role.avatarAppId,
    avatarAppSecret: role.avatarAppSecret
  })
}
```

**不应该做的：**
- ❌ 不应该更新渲染器配置（如果配置已更改，应该在切换角色时处理，而不是在连接时）

### ✅ 清单3：检查容器是否存在

**应该做的：**
1. ✅ 使用固定容器ID查找容器
   - 伙伴数字人：`digital-human-partner`
   - 用户数字人：`digital-human-user`
2. ✅ 如果容器不存在，直接报错（错误直接暴露）

**代码示例：**
```typescript
// 使用固定容器ID
const containerId = 'digital-human-partner' // 或 'digital-human-user'

// 检查容器是否存在
const containerElement = document.getElementById(containerId)
if (!containerElement) {
  showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
  isConnecting.value = false
  return
}
```

**不应该做的：**
- ❌ 不应该动态创建容器（容器在模板中定义，通过 `v-if` 控制显示）
- ❌ 不应该使用MD5哈希生成容器ID（使用固定ID）

### ✅ 清单4：设置回调函数

**应该做的：**
1. ✅ 设置回调函数（字幕显示、状态变化等）

**代码示例：**
```typescript
if (renderer instanceof DigitalHumanRenderer) {
  renderer.setCallbacks({
    onSubtitleOn: (text: string) => {
      appState.ui.subTitleText = text
    },
    onSubtitleOff: () => {
      appState.ui.subTitleText = ''
    },
    onStateChange: (state: string) => {
      avatarState.value = state
    }
  })
}
```

### ✅ 清单5：连接SDK

**应该做的：**
1. ✅ 调用 `renderer.connect()` 连接SDK
2. ✅ 调用 `renderer.render(containerElement)` 渲染到容器
3. ✅ 保存实例到 `appState.avatar.instances`
4. ✅ 记录连接状态到 `appState.avatar.connectedRoles`

**代码示例：**
```typescript
if (renderer.connect) {
  // 连接SDK
  await renderer.connect()
  
  // 渲染到容器
  await renderer.render(containerElement)
  
  // 保存实例和连接状态
  if (renderer instanceof DigitalHumanRenderer) {
    const instance = renderer.getInstance()
    if (instance) {
      appState.avatar.instances.set(roleId, instance)
    }
  }
  appState.avatar.connectedRoles.add(roleId)
  
  showToastMessage('连接成功', 'success')
} else {
  showToastMessage('渲染器不支持连接操作', 'error')
}
```

**不应该做的：**
- ❌ 不应该设置显示状态（`appState.avatar.showPartnerDigitalHuman = true`）
  - 显示状态由 `v-if` 控制，容器显示时自动连接，不需要手动设置
  - 手动设置显示状态会导致与 `v-if` 冲突，引发联动问题

## 3.3 不应该做的事情（需要删除的代码）

### ❌ 不应该做1：动态创建容器

**当前代码（需要删除）：**
```typescript
// 删除：动态创建容器的所有代码
const roleIdHash = toMd5(partnerRoleId)
const containerId = `digital-human-${roleIdHash}`

// 检查容器是否已存在
let containerElement = document.getElementById(containerId)
if (!containerElement) {
  // 实时创建容器
  containerElement = document.createElement('div')
  containerElement.id = containerId
  containerElement.className = 'sdk-container'
  // ... 所有样式设置
  avatarRender.appendChild(containerElement)
}
```

**删除原因：**
- ❌ 容器在模板中定义，不应该动态创建
- ❌ 动态创建导致无法使用Vue的响应式系统
- ❌ 这是导致数字人联动问题的根源之一

**重构后：**
- ✅ 使用固定容器ID：`digital-human-partner` 或 `digital-human-user`
- ✅ 容器在模板中定义，通过 `v-if` 控制显示
- ✅ 如果容器不存在，直接报错（错误直接暴露）

### ❌ 不应该做2：设置显示状态

**当前代码（需要删除）：**
```typescript
// 删除：设置显示状态
appState.avatar.showPartnerDigitalHuman = true
// 或
appState.avatar.showUserDigitalHuman = true
```

**删除原因：**
- ❌ 显示状态由 `v-if` 控制，不应该手动设置
- ❌ 手动设置显示状态会导致与 `v-if` 冲突，引发联动问题
- ❌ 这是导致数字人联动问题的根源之一

**重构后：**
- ✅ 显示状态由 `v-if` 控制：`v-if="appState.avatar.showPartnerDigitalHuman && currentPartnerRoleType === 'digital_human' && appState.currentPartnerRole"`
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接

### ❌ 不应该做3：更新渲染器配置

**当前代码（需要删除）：**
```typescript
// 删除：更新渲染器配置
if (config.avatarAppId !== role.avatarAppId || config.avatarAppSecret !== role.avatarAppSecret) {
  await renderer.updateConfig({
    avatarAppId: role.avatarAppId,
    avatarAppSecret: role.avatarAppSecret,
    // ...
  })
}
```

**删除原因：**
- ❌ 如果配置已更改，应该在切换角色时处理，而不是在连接时
- ❌ 连接时更新配置会导致逻辑混乱

**重构后：**
- ✅ 如果渲染器已存在，直接使用（配置应该在切换角色时已更新）

### ❌ 不应该做4：切换角色

**当前代码（不存在，但需要确保）：**
- ✅ 连接函数中不应该调用 `handleSetCurrentRole` 或 `handleSetCurrentUserRole`
- ✅ 连接是独立行为，不应该有切换角色的逻辑

**确保：**
- ✅ 连接按钮的 `disabled` 状态已确保只有当前角色可以连接
- ✅ 连接函数中不需要切换角色的代码

## 3.4 重构后的完整代码示例

### 伙伴角色连接函数

```typescript
async function handleConnectRoleFromList(role: Role) {
  // 1. 基础验证
  if (isConnecting.value) return
  
  if (!window.XmovAvatar) {
    showToastMessage('SDK未加载，请刷新页面重试', 'error')
    return
  }
  
  if (!role.avatarAppId || !role.avatarAppSecret) {
    showToastMessage('请先配置数字人的 App ID 和 App Secret', 'error')
    return
  }
  
  const partnerRoleId = `partner:${role.user}`
  if (appState.avatar.connectedRoles.has(partnerRoleId)) {
    showToastMessage('该角色已连接', 'info')
    return
  }
  
  if (!appState.currentPartnerRole || appState.currentPartnerRole.user !== role.user) {
    showToastMessage('只有当前角色可以连接', 'error')
    return
  }
  
  if (appState.currentPartnerRole.type !== 'digital_human') {
    showToastMessage('当前角色类型不是数字人', 'error')
    return
  }
  
  // 2. 获取或创建渲染器
  isConnecting.value = true
  try {
    let renderer = rendererManager.getRenderer(partnerRoleId)
    if (!renderer) {
      renderer = await rendererManager.createRenderer(partnerRoleId, {
        roleId: partnerRoleId,
        roleType: 'digital_human',
        positionX: role.positionX !== undefined ? role.positionX : 50,
        positionY: role.positionY !== undefined ? role.positionY : 50,
        scale: role.scale !== undefined ? role.scale : 1.0,
        avatarAppId: role.avatarAppId,
        avatarAppSecret: role.avatarAppSecret
      })
    }
    
    // 3. 检查容器是否存在（使用固定ID）
    const containerId = 'digital-human-partner'
    const containerElement = document.getElementById(containerId)
    if (!containerElement) {
      showToastMessage('数字人容器不存在，请确保当前角色是数字人类型', 'error')
      isConnecting.value = false
      return
    }
    
    // 4. 设置回调函数
    if (renderer instanceof DigitalHumanRenderer) {
      renderer.setCallbacks({
        onSubtitleOn: (text: string) => {
          appState.ui.subTitleText = text
        },
        onSubtitleOff: () => {
          appState.ui.subTitleText = ''
        },
        onStateChange: (state: string) => {
          avatarState.value = state
        }
      })
    }
    
    // 5. 连接SDK
    if (renderer.connect) {
      await renderer.connect()
      await renderer.render(containerElement)
      
      if (renderer instanceof DigitalHumanRenderer) {
        const instance = renderer.getInstance()
        if (instance) {
          appState.avatar.instances.set(partnerRoleId, instance)
        }
      }
      appState.avatar.connectedRoles.add(partnerRoleId)
      
      showToastMessage('连接成功', 'success')
    } else {
      showToastMessage('渲染器不支持连接操作', 'error')
    }
  } catch (error) {
    console.error('连接失败:', error)
    const errorMessage = error instanceof Error ? error.message : String(error)
    showToastMessage(`连接失败: ${errorMessage}`, 'error')
  } finally {
    isConnecting.value = false
  }
}
```

### 用户角色连接函数

**与伙伴角色连接函数完全一致，只是：**
- `roleId` 改为 `user:${role.id}`
- `containerId` 改为 `digital-human-user`
- 验证逻辑改为检查 `appState.currentUserRole`

---

# 四、历史面板头像点击

## 4.1 入口位置

**位置：** `ConfigPanel.vue` - 历史面板中的头像点击

**模板代码：**
```vue
<div 
  v-if="message.role !== 'system' && getRoleAvatar(message.role as 'user' | 'assistant')" 
  class="history-role-avatar"
  @click.stop="toggleIllustration(message.role as 'user' | 'assistant')"
  :title="getToggleIllustrationTitle(message.role as 'user' | 'assistant')"
>
  <img 
    :src="getRoleAvatarUrl(message.role as 'user' | 'assistant')" 
    :alt="getRoleName(message.role as 'user' | 'assistant')"
    class="role-avatar-thumbnail"
  />
</div>
```

**调用函数：** `toggleIllustration(role: 'user' | 'assistant')`（约第3312行）

## 4.2 立绘的业务逻辑（参考）

**立绘点击头像做什么：**
```typescript
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    // 用户角色：立绘直接切换显示/隐藏
    showUserIllustration.value = !showUserIllustration.value
  } else {
    // 伙伴角色：立绘直接切换显示/隐藏
    showPartnerIllustration.value = !showPartnerIllustration.value
  }
}
```

**关键特点：**
- ✅ **简单直接**：直接切换 `showUserIllustration` 或 `showPartnerIllustration`
- ✅ **自动响应**：立绘容器通过 `v-if` 自动响应状态变化
- ✅ **无需检查**：不需要检查是否已连接、是否已渲染等

## 4.3 数字人的业务清单（照抄立绘）

### ✅ 清单1：判断角色类型

**应该做的：**
1. ✅ 根据 `role` 参数判断是用户角色还是伙伴角色
2. ✅ 获取当前角色信息（`currentUserRoleInfo` 或 `currentPartnerRoleInfo`）
3. ✅ 判断角色类型是 `digital_human` 还是 `illustration`

**代码示例：**
```typescript
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 数字人处理逻辑
    } else {
      // 立绘处理逻辑（不修改立绘代码）
      showUserIllustration.value = !showUserIllustration.value
    }
  } else {
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      // 数字人处理逻辑
    } else {
      // 立绘处理逻辑（不修改立绘代码）
      showPartnerIllustration.value = !showPartnerIllustration.value
    }
  }
}
```

### ✅ 清单2：检查数字人是否已连接

**应该做的：**
1. ✅ 检查渲染器是否存在（通过 `rendererManager.getRenderer(roleId)`）
2. ✅ 如果不存在，提示用户先在角色列表面板中连接

**代码示例：**
```typescript
if (role === 'user') {
  const currentUserRole = currentUserRoleInfo.value
  if (currentUserRole?.type === 'digital_human') {
    const roleId = `user:${currentUserRole.id}`
    const renderer = rendererManager.getRenderer(roleId)
    if (!renderer) {
      // 未连接：提示在角色面板连接
      showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
      return
    }
    // 已连接：切换显示/隐藏
    appState.avatar.showUserDigitalHuman = !appState.avatar.showUserDigitalHuman
  }
}
```

**不应该做的：**
- ❌ 不应该在未连接时自动连接（连接是独立行为，需要在角色列表面板中操作）
- ❌ 不应该检查容器是否存在（容器在模板中定义，通过 `v-if` 控制）

### ✅ 清单3：切换显示状态

**应该做的：**
1. ✅ 直接切换 `appState.avatar.showUserDigitalHuman` 或 `appState.avatar.showPartnerDigitalHuman`
2. ✅ 容器通过 `v-if` 自动响应状态变化

**代码示例：**
```typescript
// 用户数字人
appState.avatar.showUserDigitalHuman = !appState.avatar.showUserDigitalHuman

// 伙伴数字人
appState.avatar.showPartnerDigitalHuman = !appState.avatar.showPartnerDigitalHuman
```

**不应该做的：**
- ❌ 不应该调用 `renderer.show()` 或 `renderer.hide()`（显示/隐藏由 `v-if` 控制）
- ❌ 不应该手动设置容器的 `display` 样式（显示/隐藏由 `v-if` 控制）
- ❌ 不应该通过 `watch` 监听器手动控制 `display`（重构后删除这些 `watch`）

## 4.4 重构后的完整代码

### 重构后的 `toggleIllustration` 函数

```typescript
// Toggle 立绘/数字人显示/隐藏
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    // 用户角色：根据角色类型判断
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 数字人：检查是否已连接
      const roleId = `user:${currentUserRole.id}`
      const renderer = rendererManager.getRenderer(roleId)
      if (!renderer) {
        // 未连接：提示在角色面板连接
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      // 已连接：切换显示/隐藏（通过 v-if 自动响应）
      appState.avatar.showUserDigitalHuman = !appState.avatar.showUserDigitalHuman
    } else {
      // 立绘：显示/隐藏（不修改立绘代码）
      showUserIllustration.value = !showUserIllustration.value
    }
  } else {
    // 伙伴角色：根据角色类型判断
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      // 数字人：检查是否已连接
      const roleId = `partner:${partnerRole.user}`
      const renderer = rendererManager.getRenderer(roleId)
      if (!renderer) {
        // 未连接：提示在角色面板连接
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      // 已连接：切换显示/隐藏（通过 v-if 自动响应）
      appState.avatar.showPartnerDigitalHuman = !appState.avatar.showPartnerDigitalHuman
    } else {
      // 立绘：显示/隐藏（不修改立绘代码）
      showPartnerIllustration.value = !showPartnerIllustration.value
    }
  }
}
```

### 重构后的 `getToggleIllustrationTitle` 函数

**用于显示提示文本（鼠标悬停时）：**

```typescript
// 获取 toggle 提示文本
function getToggleIllustrationTitle(role: 'user' | 'assistant'): string {
  if (role === 'user') {
    // 用户角色：根据角色类型判断
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 【注意】roleId 应该是 `user:${currentUserRole.id}`，不是 `'user'`
      const roleId = `user:${currentUserRole.id}`
      if (!appState.avatar.connectedRoles.has(roleId)) {
        return '显示数字人（未连接）'
      }
      return appState.avatar.showUserDigitalHuman ? '隐藏数字人' : '显示数字人'
    } else {
      return showUserIllustration.value ? '隐藏用户立绘' : '显示用户立绘'
    }
  } else {
    // 伙伴角色：根据角色类型判断
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      const roleId = `partner:${partnerRole.user}`
      if (!appState.avatar.connectedRoles.has(roleId)) {
        return '显示数字人（未连接）'
      }
      return appState.avatar.showPartnerDigitalHuman ? '隐藏数字人' : '显示数字人'
    } else {
      return showPartnerIllustration.value ? '隐藏伙伴立绘' : '显示伙伴立绘'
    }
  }
}
```

**关键点：**
- ✅ 检查 `appState.avatar.connectedRoles.has(roleId)` 判断是否已连接
- ✅ 根据 `appState.avatar.showUserDigitalHuman` 或 `appState.avatar.showPartnerDigitalHuman` 判断当前显示状态
- ✅ 返回相应的提示文本

## 4.5 不应该做的事情

### ❌ 不应该做1：在未连接时自动连接

**不应该这样做：**
```typescript
if (!renderer) {
  // 不应该这样做：
  // await handleConnectUserRoleFromList(currentUserRole)
  // 应该提示用户：
  showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
  return
}
```

**原因：**
- ❌ 连接是独立行为，需要在角色列表面板中操作
- ❌ 点击头像是显示/隐藏，不是连接/断开

### ❌ 不应该做2：调用 renderer.show() 或 renderer.hide()

**不应该这样做：**
- ✅ 不应该调用 `renderer.show()` 或 `renderer.hide()`
- ✅ 显示/隐藏由 `v-if` 控制，不需要手动调用

**原因：**
- ❌ 显示/隐藏由 `v-if` 控制，容器显示时自动连接，容器隐藏时不断开（保持连接状态）
- ❌ 手动调用会导致与 `v-if` 冲突

### ❌ 不应该做3：手动设置容器的 display 样式

**不应该这样做（重构后删除）：**
```typescript
// 不应该这样做（重构后删除）：
watch(() => appState.avatar.showPartnerDigitalHuman, (visible) => {
  const containerElement = document.getElementById(containerId)
  if (containerElement) {
    containerElement.style.display = visible ? 'flex' : 'none'
  }
})
```

**原因：**
- ❌ 显示/隐藏由 `v-if` 控制，不需要手动设置 `display`
- ❌ 手动设置会导致与 `v-if` 冲突，引发联动问题

---

# 五、总结

## 5.1 所有入口的业务清单汇总

### 入口1：APIKey登录后
1. ✅ **什么都不做**：与立绘一致，通过 `v-if` 自动响应
2. ✅ **确保 `appState.currentPartnerRole` 和 `appState.currentUserRole` 正确设置**
3. ✅ **触发 `roleUpdated` 事件**（已实现）

### 入口2：切换角色时
1. ✅ **什么都不做**：与立绘一致，通过 `v-if` 自动响应
2. ✅ **确保 `appState.currentPartnerRole` 和 `appState.currentUserRole` 正确设置**
3. ✅ **触发 `roleUpdated` 事件**（已实现）
4. ✅ **删除清理代码**：删除所有手动清理数字人连接和容器的代码

### 连接按钮点击
1. ✅ **基础验证**（6项检查）
2. ✅ **获取或创建渲染器**
3. ✅ **检查容器是否存在**（使用固定ID）
4. ✅ **设置回调函数**
5. ✅ **连接SDK**（连接、渲染、保存状态）

**不应该做的：**
- ❌ 动态创建容器
- ❌ 设置显示状态
- ❌ 更新渲染器配置
- ❌ 切换角色

### 历史面板头像点击
1. ✅ **判断角色类型**（数字人/立绘）
2. ✅ **检查数字人是否已连接**（数字人特有）
3. ✅ **切换显示状态**（与立绘一致）

**不应该做的：**
- ❌ 在未连接时自动连接
- ❌ 调用 `renderer.show()` 或 `renderer.hide()`
- ❌ 手动设置容器的 `display` 样式

## 5.2 关键原则

**数字人的业务逻辑与立绘完全一致：**
- ✅ 容器在模板中定义，使用 `v-if` 控制显示
- ✅ 当角色变化时，容器自动创建/销毁
- ✅ SDK连接逻辑在 `watch` 中处理，容器显示时自动连接，容器销毁时自动断开
- ✅ **所有入口不需要任何数字人特殊处理代码**（除了连接按钮）

**连接是独立行为：**
- ✅ 只负责连接SDK
- ✅ 不涉及角色切换
- ✅ 不涉及容器创建（容器在模板中定义）
- ✅ 不涉及显示状态设置（显示状态由 `v-if` 控制）

**点击头像是显示/隐藏：**
- ✅ 只负责切换显示状态
- ✅ 不涉及连接/断开（连接是独立行为）
- ✅ 不涉及容器创建（容器在模板中定义）
- ✅ 不涉及手动控制样式（显示/隐藏由 `v-if` 控制）

## 5.3 需要修改的地方汇总

1. **`handleSetCurrentRole()` 中：**
   - 添加：`appState.currentPartnerRole = role`

2. **`handleSetCurrentUserRole()` 中：**
   - 删除：所有手动清理数字人连接和容器的代码（约第3159-3177行）

3. **`handleSetCurrentRole()` 中：**
   - 删除：所有手动清理数字人连接和容器的代码（约第3720-3738行）

4. **`getAndSetCurrentPartnerRole()` 中：**
   - 当前实现：只设置了 `appState.llm.user`，未设置 `appState.currentPartnerRole`
   - 需要修改：在设置 `appState.llm.user` 后，查找对应的角色并设置 `appState.currentPartnerRole = roles.value.find(r => r.user === config.llm.user)`

5. **`getToggleIllustrationTitle()` 中：**
   - 当前实现：用户角色的 `roleId` 写成了 `'user'`，应该是 `user:${currentUserRole.id}`
   - 需要修改：`const roleId = \`user:${currentUserRole.id}\``

6. **`handleConnectRoleFromList()` 和 `handleConnectUserRoleFromList()` 中：**
   - 删除：所有动态创建容器的代码
   - 删除：所有设置显示状态的代码
   - 删除：所有更新渲染器配置的代码
   - 修改：使用固定容器ID（`digital-human-partner` 和 `digital-human-user`）

