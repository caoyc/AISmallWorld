# 数字人代码审查报告

## 审查原则

### 原则1：业务逻辑一致性

**数字人的业务逻辑跟立绘一样，只是把立绘换成了数字人的细节差别。**

此原则要求：
- 数字人和立绘在业务逻辑上保持一致，仅在实现细节上有差异
- 所有立绘的功能（位置、缩放、显示/隐藏、拖拽等）都应同样适用于数字人
- 设计新功能时，应首先考虑立绘的实现方式，然后将其适配到数字人
- 避免为数字人设计特殊的业务逻辑，除非是数字人特有的技术细节（如SDK连接、截图等）

### 原则2：松耦合可插拔架构

**除集成性质的代码外，数字人的代码使用单独的目录存放，目标是实现可插拔式的松耦合。**

此原则要求：
- **代码隔离**：数字人相关代码（除集成点外）应存放在独立目录中，与立绘代码分离
- **可插拔设计**：数字人功能应设计为可插拔模块，可以独立启用/禁用，不影响立绘功能
- **禁止修改立绘代码**：代码实现中严禁改动立绘的现有代码，适当时机将对立绘也进行类似重构
- **统一抽象模式**：抽象统一模式，以备后续按此模式扩张更多其他类型（如3D模型、视频等）

**架构目标**：
- 立绘、数字人、未来其他类型都作为独立的"角色渲染器"（Renderer）插件
- 通过统一的接口（Interface）与主应用集成
- 每个渲染器独立管理自己的生命周期、状态、事件处理
- 主应用只负责协调和集成，不关心具体渲染器的实现细节

**当前状态评估**：
- ❌ **不符合**：数字人代码与立绘代码混在一起，没有独立目录
- ❌ **不符合**：数字人功能直接修改了 `AvatarRender.vue` 和 `ConfigPanel.vue`，与立绘代码耦合
- ❌ **不符合**：没有统一的抽象接口，无法支持未来扩展
- ⚠️ **部分符合**：业务逻辑保持一致，但代码结构不符合松耦合原则

## 一、代码结构对比

### 1.1 渲染结构对比

#### 立绘渲染（AvatarRender.vue）
```vue
<!-- 伙伴立绘图片显示 -->
<div 
  v-if="showPartnerIllustration && currentPartnerRoleType === 'illustration' && currentPartnerRoleAvatar"
  class="illustration-container"
  :class="{ dragging: isDraggingPartner }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartner($event)"
>
  <img 
    :src="partnerIllustrationImageUrl" 
    :alt="currentPartnerRoleName || '伙伴立绘'"
    class="illustration-image"
  />
</div>
```

#### 数字人渲染（AvatarRender.vue）
```vue
<!-- 数字人 SDK 渲染容器（伙伴角色） -->
<div 
  v-if="currentPartnerRoleType === 'digital_human'"
  :id="containerId" 
  class="sdk-container" 
  :class="{ 
    visible: isPartnerDigitalHumanConnected && appState.avatar.showPartnerDigitalHuman,
    dragging: isDraggingPartnerDigitalHuman
  }"
  :style="partnerAvatarPositionStyle"
  @mousedown="startDragPartnerDigitalHuman($event)"
/>
```

**对比分析**：
- ✅ **位置样式**：两者都使用 `partnerAvatarPositionStyle`，一致
- ✅ **拖拽功能**：两者都有独立的拖拽状态和函数，一致
- ✅ **条件渲染**：立绘使用 `showPartnerIllustration`，数字人使用 `isPartnerDigitalHumanConnected && appState.avatar.showPartnerDigitalHuman`，逻辑一致但实现方式不同
- ⚠️ **容器ID**：数字人使用 `containerId`（来自 `avatarService.getContainerId()`），这是全局单例，不符合"每个数字人独立"的原则

### 1.2 位置和样式计算

#### 立绘位置样式
```typescript
const partnerAvatarPositionStyle = computed(() => {
  const isDragging = isDraggingPartner.value || isDraggingPartnerDigitalHuman.value
  const positionX = isDragging && draggingPartnerPositionX.value !== null 
    ? draggingPartnerPositionX.value 
    : (currentPartnerRole.value?.positionX !== undefined ? currentPartnerRole.value.positionX : 50)
  const positionY = isDragging && draggingPartnerPositionY.value !== null 
    ? draggingPartnerPositionY.value 
    : (currentPartnerRole.value?.positionY !== undefined ? currentPartnerRole.value.positionY : 50)
  const scale = currentPartnerRole.value?.scale !== undefined ? currentPartnerRole.value.scale : 1.0
  
  const baseWidth = 600
  const baseHeight = 800
  const width = baseWidth * scale
  const height = baseHeight * scale
  
  return {
    left: `${positionX}%`,
    top: `${positionY}%`,
    transform: 'translate(-50%, -50%)',
    width: `${width}px`,
    height: `${height}px`
  }
})
```

#### 数字人位置样式
数字人使用相同的 `partnerAvatarPositionStyle` 计算函数，**完全一致** ✅

## 二、显示/隐藏逻辑对比

### 2.1 立绘显示/隐藏

**实现方式**：
- 使用 `showPartnerIllustration` 和 `showUserIllustration` 两个独立的 ref 变量
- 通过 `toggleIllustration` 函数切换显示/隐藏状态
- 直接控制 DOM 元素的 `v-if` 条件

**代码位置**：`ConfigPanel.vue` 的 `toggleIllustration` 函数

```typescript
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    showUserIllustration.value = !showUserIllustration.value
  } else {
    showPartnerIllustration.value = !showPartnerIllustration.value
  }
}
```

### 2.2 数字人显示/隐藏

**当前实现**：
- 使用 `appState.avatar.showPartnerDigitalHuman` 和 `appState.avatar.showUserDigitalHuman` 控制显示
- 通过 `toggleIllustration` 函数中的特殊判断处理数字人
- 需要检查连接状态：如果未连接，提示用户先连接

**代码位置**：`ConfigPanel.vue` 的 `toggleIllustration` 函数

```typescript
function toggleIllustration(role: 'user' | 'assistant') {
  if (role === 'user') {
    const currentUserRole = currentUserRoleInfo.value
    if (currentUserRole?.type === 'digital_human') {
      // 数字人：显示/隐藏容器（保持连接状态，仅控制容器显示/隐藏）
      const roleId = 'user'
      if (!appState.avatar.connectedRoles.has(roleId)) {
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      appState.avatar.showUserDigitalHuman = !appState.avatar.showUserDigitalHuman
    } else {
      showUserIllustration.value = !showUserIllustration.value
    }
  } else {
    const partnerRole = currentPartnerRoleInfo.value
    if (partnerRole?.type === 'digital_human') {
      const roleId = `partner:${partnerRole.user}`
      if (!appState.avatar.connectedRoles.has(roleId)) {
        showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
        return
      }
      appState.avatar.showPartnerDigitalHuman = !appState.avatar.showPartnerDigitalHuman
    } else {
      showPartnerIllustration.value = !showPartnerIllustration.value
    }
  }
}
```

**对比分析**：
- ✅ **逻辑一致**：都是通过 toggle 函数切换显示/隐藏状态
- ⚠️ **实现差异**：数字人需要额外的连接状态检查，这是合理的（技术细节差异）
- ⚠️ **状态管理**：立绘使用独立的 ref 变量，数字人使用 `appState.avatar` 中的状态，管理方式不一致

## 三、拖拽功能对比

### 3.1 立绘拖拽

**实现方式**：
- 独立的拖拽状态：`isDraggingPartner`、`isDraggingUser`
- 独立的拖拽函数：`startDragPartner`、`startDragUser`
- 全局鼠标事件监听，支持从外部触发拖拽（隐藏面板后触发）

**代码位置**：`AvatarRender.vue`

### 3.2 数字人拖拽

**实现方式**：
- 独立的拖拽状态：`isDraggingPartnerDigitalHuman`、`isDraggingUserDigitalHuman`
- 独立的拖拽函数：`startDragPartnerDigitalHuman`、`startDragUserDigitalHuman`
- 使用相同的全局鼠标事件监听机制

**对比分析**：
- ✅ **完全一致**：数字人和立绘的拖拽实现方式完全相同
- ✅ **独立实现**：每个类型都有独立的拖拽状态和函数，互不干扰

## 四、连接管理对比

### 4.1 立绘连接管理

**实现方式**：
- 立绘不需要连接，直接显示图片
- 通过 `currentPartnerRoleAvatar` 和 `currentUserRoleAvatar` 获取头像URL
- 图片加载失败时自然不显示

### 4.2 数字人连接管理

**当前实现**：
- 需要 SDK 连接：`avatarService.connect()`
- 连接状态管理：`appState.avatar.instances` (Map) 和 `appState.avatar.connectedRoles` (Set)
- 每个数字人角色有独立的连接状态

**代码位置**：`ConfigPanel.vue` 的 `handleConnectRoleFromList` 和 `handleConnectUserRoleFromList`

**对比分析**：
- ✅ **技术细节差异**：数字人需要 SDK 连接，这是合理的（技术实现差异）
- ⚠️ **容器管理问题**：
  - **问题1**：`AvatarRender.vue` 中数字人容器使用 `containerId = computed(() => avatarService.getContainerId())`，这是全局单例，不符合"每个数字人独立"的原则
  - **问题2**：从角色列表连接时，动态创建容器（`partner-digital-human-${role.user}`），但 `AvatarRender.vue` 中的容器ID是固定的全局ID，导致不匹配
  - **问题3**：用户数字人容器使用固定ID `user-digital-human-container`，但连接时使用 `user-digital-human-${role.id}`，ID不一致

## 五、问题汇总

### 5.1 严重问题

#### 问题1：容器ID不一致
**位置**：
- `AvatarRender.vue` 第108行：`const containerId = computed(() => avatarService.getContainerId())`
- `AvatarRender.vue` 第111-114行：`const userContainerId = computed(() => 'user-digital-human-container')`
- `ConfigPanel.vue` 第1814行：连接时使用 `partner-digital-human-${role.user}`
- `ConfigPanel.vue` 第1916行：连接时使用 `user-digital-human-${role.id}`

**问题描述**：
- `AvatarRender.vue` 中的容器ID是固定的全局ID
- 连接时创建的容器ID是基于角色ID的动态ID
- 两者不匹配，导致数字人无法正确渲染到对应容器

**影响**：
- 数字人可能渲染到错误的容器
- 多个数字人可能共享同一个容器
- 不符合"每个数字人独立"的原则

**修复建议**：
- 移除 `AvatarRender.vue` 中的固定容器
- 连接时动态创建容器，容器ID与连接时使用的ID一致
- 或者：`AvatarRender.vue` 中根据当前角色动态生成容器ID

#### 问题2：连接时自动切换角色
**位置**：`ConfigPanel.vue` 第1805行（已修复，但需确认）

**问题描述**：
- 从角色列表连接数字人时，不应该自动切换角色
- 连接数字人和切换角色是两个独立操作

**修复状态**：✅ 已修复（已移除 `handleSetCurrentRole` 调用）

### 5.2 中等问题

#### 问题3：显示/隐藏状态管理不一致
**位置**：
- 立绘：使用独立的 ref 变量（`showPartnerIllustration`、`showUserIllustration`）
- 数字人：使用 `appState.avatar.showPartnerDigitalHuman`、`appState.avatar.showUserDigitalHuman`

**问题描述**：
- 状态管理方式不一致，可能导致维护困难
- 立绘的状态是组件级别的，数字人的状态是全局的

**修复建议**：
- 统一状态管理方式，或者保持现状但明确说明原因（数字人需要全局状态以便在多个组件间共享）

#### 问题4：全局鼠标事件监听未包含数字人容器
**位置**：`AvatarRender.vue` 第223-293行

**问题描述**：
- 全局鼠标事件监听只检测 `.illustration-container`，未检测数字人容器（`.sdk-container`）
- 数字人拖拽时，如果从外部点击，可能无法正确触发拖拽

**修复建议**：
- 在全局鼠标事件监听中添加对 `.sdk-container` 的检测
- 或者：数字人容器也应该支持从外部触发拖拽

### 5.3 轻微问题

#### 问题5：默认角色类型不一致
**位置**：
- `AvatarRender.vue` 第118行：`currentPartnerRoleType` 默认值为 `'digital_human'`
- `AvatarRender.vue` 第123行：`currentUserRoleType` 默认值为 `'illustration'`

**问题描述**：
- 默认值不一致，可能导致显示逻辑混乱

**修复建议**：
- 统一默认值，或者明确说明为什么不同

## 六、符合原则的部分

### 6.1 位置和缩放
- ✅ 数字人和立绘使用相同的位置样式计算函数
- ✅ 都支持位置（positionX、positionY）和缩放（scale）配置
- ✅ 都支持拖拽调整位置

### 6.2 拖拽功能
- ✅ 数字人和立绘都有独立的拖拽状态和函数
- ✅ 拖拽逻辑完全一致
- ✅ 都支持拖动时隐藏面板

### 6.3 显示/隐藏逻辑
- ✅ 都通过 `toggleIllustration` 函数统一管理
- ✅ 都支持点击头像显示/隐藏
- ✅ 逻辑结构一致，只是实现细节不同（数字人需要检查连接状态）

## 七、修复优先级

### 高优先级（必须修复）
1. **容器ID不一致问题**（问题1）
   - 影响：数字人无法正确渲染
   - 修复难度：中等
   - 预计工作量：2-4小时

### 中优先级（建议修复）
2. **全局鼠标事件监听未包含数字人容器**（问题4）
   - 影响：数字人拖拽体验不一致
   - 修复难度：低
   - 预计工作量：1-2小时

3. **显示/隐藏状态管理不一致**（问题3）
   - 影响：代码维护性
   - 修复难度：中等
   - 预计工作量：2-3小时

### 低优先级（可选修复）
4. **默认角色类型不一致**（问题5）
   - 影响：代码一致性
   - 修复难度：低
   - 预计工作量：0.5小时

## 八、总结

### 8.1 整体评价

数字人的业务逻辑实现**基本符合**"数字人的业务逻辑跟立绘一样"的原则，主要体现在：
- ✅ 位置、缩放、拖拽等核心功能与立绘完全一致
- ✅ 显示/隐藏逻辑结构一致
- ⚠️ 但在容器管理和状态管理上存在不一致

### 8.2 主要问题

1. **容器ID不一致**：这是最严重的问题，导致数字人无法正确渲染到对应容器
2. **状态管理方式不一致**：立绘使用组件级状态，数字人使用全局状态，虽然可以理解，但需要明确说明原因

### 8.3 建议

1. **立即修复容器ID问题**：确保每个数字人都有独立的容器，容器ID与连接时使用的ID一致
2. **统一状态管理方式**：或者保持现状但明确文档说明为什么数字人需要全局状态
3. **完善全局鼠标事件监听**：确保数字人容器也能从外部触发拖拽

### 8.4 后续开发建议

1. **新功能开发时**：先考虑立绘的实现方式，然后适配到数字人
2. **代码审查时**：对比立绘和数字人的实现，确保逻辑一致
3. **文档更新**：及时更新文档，记录数字人特有的技术细节（如SDK连接、截图等）

## 九、连接状态计算逻辑分析

### 9.1 问题：连接状态计算属性缺失

**位置**：`AvatarRender.vue` 第14行、第27行

**问题描述**：
- 模板中使用了 `isPartnerDigitalHumanConnected` 和 `isUserDigitalHumanConnected`
- 但在整个 `AvatarRender.vue` 文件中**未找到这两个计算属性的定义**
- 这会导致运行时错误：`ReferenceError: isPartnerDigitalHumanConnected is not defined`

**当前代码**：
```vue
<!-- 数字人 SDK 渲染容器（伙伴角色） -->
<div 
  v-if="currentPartnerRoleType === 'digital_human'"
  :id="containerId" 
  class="sdk-container" 
  :class="{ 
    visible: isPartnerDigitalHumanConnected && appState.avatar.showPartnerDigitalHuman,
    dragging: isDraggingPartnerDigitalHuman
  }"
/>
```

**修复建议**：
```typescript
// 伙伴数字人连接状态
const isPartnerDigitalHumanConnected = computed(() => {
  if (!currentPartnerRole.value) return false
  const roleId = `partner:${currentPartnerRole.value.user}`
  return appState.avatar.connectedRoles.has(roleId)
})

// 用户数字人连接状态
const isUserDigitalHumanConnected = computed(() => {
  if (!currentUserRole.value) return false
  const roleId = `user:${currentUserRole.value.id}`
  return appState.avatar.connectedRoles.has(roleId)
})
```

**影响**：⚠️ **严重** - 会导致数字人无法正确显示

### 9.2 连接状态检查逻辑不一致

**位置**：`ConfigPanel.vue` 第3043行、第3060行

**问题描述**：
- `toggleIllustration` 函数中，用户角色使用 `roleId = 'user'`
- 但实际连接时使用 `roleId = 'user:${role.id}'`（第1968行）
- 导致连接状态检查失败

**当前代码**：
```typescript
// ConfigPanel.vue 第3043行
const roleId = 'user'  // ❌ 错误：应该是 `user:${currentUserRole.id}`
if (!appState.avatar.connectedRoles.has(roleId)) {
  showToastMessage('数字人未连接，请先在角色列表面板中连接', 'info')
  return
}
```

**修复建议**：
```typescript
// 用户角色
const roleId = `user:${currentUserRole.id}`  // ✅ 正确

// 伙伴角色（已正确）
const roleId = `partner:${partnerRole.user}`  // ✅ 正确
```

**影响**：⚠️ **严重** - 导致用户角色数字人无法通过点击头像显示/隐藏

## 十、容器管理详细分析

### 10.1 容器ID生成策略对比

#### 立绘容器
- **不需要容器ID**：立绘直接使用 `<img>` 标签，不需要特殊的容器ID
- **容器类名**：`.illustration-container`

#### 数字人容器
- **需要容器ID**：SDK需要绑定到特定的DOM元素
- **问题**：容器ID生成策略不一致

### 10.2 容器ID不一致问题详解

#### 问题1：AvatarRender.vue 中的固定容器ID

**位置**：`AvatarRender.vue` 第108行、第111-114行

```typescript
// 伙伴角色：使用全局单例
const containerId = computed(() => avatarService.getContainerId())
// 返回：固定的全局ID（例如：'avatar-container-xxx'）

// 用户角色：使用固定字符串
const userContainerId = computed(() => {
  return `user-digital-human-container`  // 固定ID
})
```

**问题**：
- 伙伴角色容器ID是全局单例，所有伙伴角色共享同一个容器
- 用户角色容器ID是固定字符串，所有用户角色共享同一个容器
- 不符合"每个数字人独立"的原则

#### 问题2：连接时动态创建的容器ID

**位置**：`ConfigPanel.vue` 第1814行、第1916行

```typescript
// 伙伴角色连接
const containerId = `partner-digital-human-${role.user}`  // 动态ID

// 用户角色连接
const containerId = `user-digital-human-${role.id}`  // 动态ID
```

**问题**：
- 连接时创建的容器ID与 `AvatarRender.vue` 中的容器ID不匹配
- 导致SDK无法找到正确的容器进行渲染

### 10.3 容器创建时机问题

**当前实现**：
- `AvatarRender.vue` 中预先定义了容器（通过 `v-if` 条件渲染）
- `ConfigPanel.vue` 连接时又动态创建容器
- 两个容器可能同时存在，导致混乱

**修复建议**：
1. **方案1（推荐）**：移除 `AvatarRender.vue` 中的固定容器，完全由连接时动态创建
2. **方案2**：`AvatarRender.vue` 中根据当前角色动态生成容器ID，与连接时使用的ID一致

## 十一、CSS样式对比

### 11.1 立绘容器样式

```css
.illustration-container {
  position: fixed;
  max-width: 90vw;
  max-height: 90vh;
  opacity: 1;  /* 默认可见 */
  pointer-events: auto;  /* 可交互 */
  z-index: 0;
  cursor: move;
}
```

### 11.2 数字人容器样式

```css
.sdk-container {
  position: fixed;
  max-width: 90vw;
  max-height: 90vh;
  opacity: 0;  /* 默认隐藏 */
  pointer-events: none;  /* 默认不可交互 */
  z-index: 2;
}

.sdk-container.visible {
  opacity: 1;
  pointer-events: auto;  /* 可见时可交互 */
}
```

**对比分析**：
- ✅ **样式结构一致**：都使用 `position: fixed`，都支持 `max-width` 和 `max-height`
- ⚠️ **默认状态不同**：立绘默认可见，数字人默认隐藏（需要通过 `.visible` 类控制）
- ✅ **符合设计**：数字人需要连接后才能显示，默认隐藏是合理的

## 十二、全局鼠标事件监听分析

### 12.1 立绘拖拽支持

**位置**：`AvatarRender.vue` 第223-293行

**实现方式**：
- 全局 `mousedown` 事件监听（捕获阶段）
- 检测点击位置是否在立绘区域内
- 如果在立绘区域，隐藏面板并触发立绘容器的 `mousedown` 事件

**代码片段**：
```typescript
// 1.2 检测是否在立绘区域
const illustrationContainers = document.querySelectorAll('.illustration-container')
let clickedIllustration: HTMLElement | null = null

for (const container of illustrationContainers) {
  const rect = container.getBoundingClientRect()
  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    clickedIllustration = container
    break
  }
}
```

### 12.2 数字人拖拽支持

**问题**：
- 全局鼠标事件监听**只检测 `.illustration-container`**
- **未检测 `.sdk-container`**（数字人容器）
- 导致数字人无法从外部触发拖拽

**修复建议**：
```typescript
// 1.2 检测是否在立绘或数字人区域
const illustrationContainers = document.querySelectorAll('.illustration-container')
const sdkContainers = document.querySelectorAll('.sdk-container')
let clickedElement: HTMLElement | null = null

// 检测立绘
for (const container of illustrationContainers) {
  const rect = container.getBoundingClientRect()
  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    clickedElement = container
    break
  }
}

// 检测数字人（如果立绘未命中）
if (!clickedElement) {
  for (const container of sdkContainers) {
    const rect = container.getBoundingClientRect()
    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
      clickedElement = container
      break
    }
  }
}
```

**影响**：⚠️ **中等** - 数字人拖拽体验不一致

## 十三、修复优先级更新

### 高优先级（必须立即修复）

1. **连接状态计算属性缺失**（问题6 - 新增）
   - 影响：数字人无法正确显示，运行时错误
   - 修复难度：低
   - 预计工作量：0.5小时

2. **容器ID不一致问题**（问题1）
   - 影响：数字人无法正确渲染
   - 修复难度：中等
   - 预计工作量：2-4小时

3. **连接状态检查逻辑不一致**（问题7 - 新增）
   - 影响：用户角色数字人无法通过点击头像显示/隐藏
   - 修复难度：低
   - 预计工作量：0.5小时

### 中优先级（建议修复）

4. **全局鼠标事件监听未包含数字人容器**（问题4）
   - 影响：数字人拖拽体验不一致
   - 修复难度：低
   - 预计工作量：1-2小时

5. **显示/隐藏状态管理不一致**（问题3）
   - 影响：代码维护性
   - 修复难度：中等
   - 预计工作量：2-3小时

### 低优先级（可选修复）

6. **默认角色类型不一致**（问题5）
   - 影响：代码一致性
   - 修复难度：低
   - 预计工作量：0.5小时

## 十四、总结更新

### 14.1 整体评价更新

数字人的业务逻辑实现**部分符合**"数字人的业务逻辑跟立绘一样"的原则，但存在**严重的技术实现问题**：

**符合原则的部分**：
- ✅ 位置、缩放、拖拽等核心功能与立绘完全一致
- ✅ 显示/隐藏逻辑结构一致
- ✅ CSS样式结构一致

**不符合原则的部分**：
- ❌ **容器管理**：容器ID不一致，导致数字人无法正确渲染
- ❌ **连接状态**：连接状态计算属性缺失，导致运行时错误
- ❌ **状态检查**：连接状态检查逻辑不一致，导致功能失效

### 14.2 主要问题（更新）

1. **连接状态计算属性缺失**：这是最严重的问题，会导致运行时错误
2. **容器ID不一致**：导致数字人无法正确渲染到对应容器
3. **连接状态检查逻辑不一致**：导致用户角色数字人功能失效

### 14.3 紧急修复建议

1. **立即修复连接状态计算属性**：添加 `isPartnerDigitalHumanConnected` 和 `isUserDigitalHumanConnected` 的定义
2. **立即修复连接状态检查逻辑**：统一 `roleId` 的生成规则
3. **尽快修复容器ID问题**：确保每个数字人都有独立的容器，容器ID与连接时使用的ID一致

### 14.4 后续开发建议（保持不变）

1. **新功能开发时**：先考虑立绘的实现方式，然后适配到数字人
2. **代码审查时**：对比立绘和数字人的实现，确保逻辑一致
3. **文档更新**：及时更新文档，记录数字人特有的技术细节（如SDK连接、截图等）
4. **测试覆盖**：确保数字人的所有功能都有对应的测试用例