# 角色渲染器重构设计文档

## 一、设计目标

### 1.1 核心目标

基于**松耦合可插拔架构**原则，将当前混在一起的立绘和数字人代码重构为独立的、可插拔的渲染器模块。

### 1.2 架构愿景

```
主应用（App）
  ├── 角色渲染器管理器（RendererManager）
  │   ├── 立绘渲染器（IllustrationRenderer）[插件]
  │   ├── 数字人渲染器（DigitalHumanRenderer）[插件]
  │   └── 未来其他渲染器（3DRenderer、VideoRenderer等）[插件]
  └── 统一接口（IRenderer）
```

## 二、当前架构问题分析

### 2.1 代码耦合问题

#### 问题1：代码混在一起
**位置**：
- `src/components/AvatarRender.vue`：立绘和数字人渲染逻辑混在一起
- `src/components/ConfigPanel.vue`：立绘和数字人配置逻辑混在一起

**问题描述**：
- 立绘和数字人的代码在同一个文件中，通过 `if-else` 判断类型
- 添加新类型需要修改现有文件，违反开闭原则
- 无法独立测试和维护

**示例代码**：
```vue
<!-- AvatarRender.vue -->
<div v-if="currentPartnerRoleType === 'illustration'">
  <!-- 立绘代码 -->
</div>
<div v-if="currentPartnerRoleType === 'digital_human'">
  <!-- 数字人代码 -->
</div>
```

#### 问题2：状态管理耦合
**位置**：
- `AvatarRender.vue`：立绘使用组件级 ref，数字人使用全局 `appState.avatar`
- `ConfigPanel.vue`：`toggleIllustration` 函数中通过 `if-else` 判断类型

**问题描述**：
- 不同渲染器的状态管理方式不一致
- 无法独立管理各自的生命周期

#### 问题3：事件处理耦合
**位置**：
- `AvatarRender.vue`：全局鼠标事件监听只处理立绘，未处理数字人
- 拖拽逻辑中通过 `dragType` 判断是立绘还是数字人

**问题描述**：
- 事件处理逻辑混在一起
- 添加新类型需要修改现有事件处理代码

### 2.2 违反设计原则

1. **违反单一职责原则**：`AvatarRender.vue` 同时负责立绘和数字人的渲染
2. **违反开闭原则**：添加新类型需要修改现有代码
3. **违反依赖倒置原则**：主应用直接依赖具体实现，而非抽象接口
4. **违反接口隔离原则**：没有统一的接口定义

## 三、目标架构设计

### 3.1 目录结构

```
src/
  ├── components/
  │   ├── AvatarRender.vue          # 主渲染容器（只负责协调）
  │   └── ConfigPanel.vue           # 主配置面板（只负责协调）
  ├── renderers/                    # 渲染器目录（新增）
  │   ├── base/                     # 基础抽象
  │   │   ├── IRenderer.ts          # 渲染器接口
  │   │   ├── BaseRenderer.ts       # 基础渲染器抽象类
  │   │   └── RendererManager.ts    # 渲染器管理器
  │   ├── illustration/             # 立绘渲染器（待重构）
  │   │   ├── IllustrationRenderer.vue
  │   │   ├── IllustrationRenderer.ts
  │   │   └── types.ts
  │   ├── digital-human/             # 数字人渲染器（新建）
  │   │   ├── DigitalHumanRenderer.vue
  │   │   ├── DigitalHumanRenderer.ts
  │   │   ├── DigitalHumanService.ts
  │   │   ├── DigitalHumanConfig.vue
  │   │   └── types.ts
  │   └── index.ts                  # 导出所有渲染器
  └── types/
      └── renderer.ts               # 渲染器相关类型定义
```

### 3.2 接口设计

#### IRenderer 接口

```typescript
// src/renderers/base/IRenderer.ts

export interface IRendererConfig {
  roleId: string
  roleType: 'illustration' | 'digital_human' | string
  positionX: number
  positionY: number
  scale: number
  [key: string]: any  // 允许扩展特定配置
}

export interface IRendererState {
  visible: boolean
  connected?: boolean  // 数字人等需要连接的类型
  [key: string]: any
}

export interface IRenderer {
  // 初始化
  init(config: IRendererConfig): Promise<void>
  
  // 渲染
  render(container: HTMLElement): Promise<void>
  
  // 更新配置
  updateConfig(config: Partial<IRendererConfig>): Promise<void>
  
  // 显示/隐藏
  show(): void
  hide(): void
  toggle(): void
  
  // 拖拽支持
  enableDrag(): void
  disableDrag(): void
  onDragStart(callback: (event: MouseEvent) => void): void
  onDragMove(callback: (event: MouseEvent) => void): void
  onDragEnd(callback: (event: MouseEvent) => void): void
  
  // 连接/断开（可选，仅适用于需要连接的类型）
  connect?(): Promise<void>
  disconnect?(): Promise<void>
  
  // 获取状态
  getState(): IRendererState
  
  // 清理
  destroy(): void
}
```

#### BaseRenderer 抽象类

```typescript
// src/renderers/base/BaseRenderer.ts

import type { IRenderer, IRendererConfig, IRendererState } from './IRenderer'

export abstract class BaseRenderer implements IRenderer {
  protected config: IRendererConfig
  protected state: IRendererState
  protected container: HTMLElement | null = null
  
  constructor(config: IRendererConfig) {
    this.config = config
    this.state = {
      visible: false
    }
  }
  
  // 抽象方法，子类必须实现
  abstract render(container: HTMLElement): Promise<void>
  abstract destroy(): void
  
  // 通用方法，子类可以覆盖
  async init(config: IRendererConfig): Promise<void> {
    this.config = { ...this.config, ...config }
  }
  
  async updateConfig(config: Partial<IRendererConfig>): Promise<void> {
    this.config = { ...this.config, ...config }
    // 通知子类配置已更新
    await this.onConfigUpdated()
  }
  
  show(): void {
    this.state.visible = true
    this.onVisibilityChanged(true)
  }
  
  hide(): void {
    this.state.visible = false
    this.onVisibilityChanged(false)
  }
  
  toggle(): void {
    if (this.state.visible) {
      this.hide()
    } else {
      this.show()
    }
  }
  
  getState(): IRendererState {
    return { ...this.state }
  }
  
  // 钩子方法，子类可以覆盖
  protected async onConfigUpdated(): Promise<void> {}
  protected onVisibilityChanged(visible: boolean): void {}
}
```

### 3.3 渲染器管理器

```typescript
// src/renderers/base/RendererManager.ts

import type { IRenderer, IRendererConfig } from './IRenderer'
import { IllustrationRenderer } from '../illustration/IllustrationRenderer'
import { DigitalHumanRenderer } from '../digital-human/DigitalHumanRenderer'

export class RendererManager {
  private renderers: Map<string, IRenderer> = new Map()
  
  // 注册渲染器工厂
  private factories: Map<string, (config: IRendererConfig) => IRenderer> = new Map([
    ['illustration', (config) => new IllustrationRenderer(config)],
    ['digital_human', (config) => new DigitalHumanRenderer(config)],
    // 未来可以注册更多类型
  ])
  
  // 创建渲染器
  async createRenderer(roleId: string, config: IRendererConfig): Promise<IRenderer> {
    const factory = this.factories.get(config.roleType)
    if (!factory) {
      throw new Error(`Unknown renderer type: ${config.roleType}`)
    }
    
    const renderer = factory(config)
    await renderer.init(config)
    this.renderers.set(roleId, renderer)
    return renderer
  }
  
  // 获取渲染器
  getRenderer(roleId: string): IRenderer | undefined {
    return this.renderers.get(roleId)
  }
  
  // 销毁渲染器
  destroyRenderer(roleId: string): void {
    const renderer = this.renderers.get(roleId)
    if (renderer) {
      renderer.destroy()
      this.renderers.delete(roleId)
    }
  }
  
  // 销毁所有渲染器
  destroyAll(): void {
    for (const [roleId, renderer] of this.renderers) {
      renderer.destroy()
    }
    this.renderers.clear()
  }
}
```

### 3.4 数字人渲染器实现示例

```typescript
// src/renderers/digital-human/DigitalHumanRenderer.ts

import { BaseRenderer } from '../base/BaseRenderer'
import type { IRendererConfig, IRendererState } from '../base/IRenderer'
import { DigitalHumanService } from './DigitalHumanService'

export class DigitalHumanRenderer extends BaseRenderer {
  private service: DigitalHumanService
  private containerId: string
  private connected: boolean = false
  
  constructor(config: IRendererConfig) {
    super(config)
    this.service = new DigitalHumanService()
    this.containerId = `digital-human-${config.roleId}`
  }
  
  async render(container: HTMLElement): Promise<void> {
    this.container = container
    
    // 创建数字人容器
    const digitalHumanContainer = document.createElement('div')
    digitalHumanContainer.id = this.containerId
    digitalHumanContainer.className = 'sdk-container'
    container.appendChild(digitalHumanContainer)
    
    // 如果已连接，直接显示
    if (this.connected) {
      this.show()
    }
  }
  
  async connect(): Promise<void> {
    if (this.connected) return
    
    const config = this.config as any  // 数字人特定配置
    await this.service.connect({
      appId: config.avatarAppId,
      appSecret: config.avatarAppSecret
    }, this.containerId)
    
    this.connected = true
    this.state.connected = true
  }
  
  async disconnect(): Promise<void> {
    if (!this.connected) return
    
    await this.service.disconnect()
    this.connected = false
    this.state.connected = false
  }
  
  protected onVisibilityChanged(visible: boolean): void {
    if (this.container) {
      const element = this.container.querySelector(`#${this.containerId}`)
      if (element) {
        if (visible) {
          element.classList.add('visible')
        } else {
          element.classList.remove('visible')
        }
      }
    }
  }
  
  destroy(): void {
    if (this.connected) {
      this.disconnect()
    }
    if (this.container) {
      const element = this.container.querySelector(`#${this.containerId}`)
      if (element) {
        element.remove()
      }
    }
  }
}
```

## 四、重构步骤

### 阶段1：创建基础架构（不修改现有代码）

1. **创建目录结构**
   - 创建 `src/renderers/` 目录
   - 创建 `src/renderers/base/` 目录
   - 创建 `src/renderers/digital-human/` 目录

2. **定义接口和抽象类**
   - 实现 `IRenderer` 接口
   - 实现 `BaseRenderer` 抽象类
   - 实现 `RendererManager` 管理器

3. **实现数字人渲染器（独立模块）**
   - 将数字人相关代码从 `AvatarRender.vue` 和 `ConfigPanel.vue` 中提取
   - 实现 `DigitalHumanRenderer` 类
   - 实现 `DigitalHumanService` 服务类
   - 实现 `DigitalHumanConfig.vue` 配置组件

### 阶段2：集成数字人渲染器（最小化修改）

1. **修改 AvatarRender.vue（最小化）**
   - 引入 `RendererManager`
   - 使用管理器创建和管理数字人渲染器
   - **不修改立绘相关代码**

2. **修改 ConfigPanel.vue（最小化）**
   - 引入数字人配置组件
   - 使用管理器管理数字人连接状态
   - **不修改立绘相关代码**

### 阶段3：重构立绘渲染器（未来）

1. **提取立绘代码**
   - 创建 `IllustrationRenderer` 类
   - 将立绘相关代码从 `AvatarRender.vue` 中提取

2. **统一接口**
   - 立绘和数字人都实现 `IRenderer` 接口
   - 通过 `RendererManager` 统一管理

### 阶段4：扩展新类型（未来）

1. **添加新渲染器**
   - 创建新的渲染器目录（如 `3d-model/`）
   - 实现 `IRenderer` 接口
   - 注册到 `RendererManager`

2. **无需修改现有代码**
   - 主应用代码无需修改
   - 其他渲染器代码无需修改

## 五、重构收益

### 5.1 代码质量提升

- ✅ **代码隔离**：每个渲染器独立目录，职责清晰
- ✅ **可测试性**：每个渲染器可以独立测试
- ✅ **可维护性**：修改一个渲染器不影响其他渲染器
- ✅ **可扩展性**：添加新类型无需修改现有代码

### 5.2 架构质量提升

- ✅ **符合开闭原则**：对扩展开放，对修改关闭
- ✅ **符合单一职责原则**：每个渲染器只负责一种类型的渲染
- ✅ **符合依赖倒置原则**：主应用依赖抽象接口，而非具体实现
- ✅ **符合接口隔离原则**：统一的接口定义，清晰的职责划分

### 5.3 开发效率提升

- ✅ **并行开发**：不同开发者可以同时开发不同渲染器
- ✅ **独立部署**：可以独立发布某个渲染器的更新
- ✅ **代码复用**：基础功能在 `BaseRenderer` 中复用

## 六、注意事项

### 6.1 重构原则

1. **严禁修改立绘代码**：重构过程中，立绘相关代码保持不变
2. **最小化修改**：主应用代码（`AvatarRender.vue`、`ConfigPanel.vue`）只做必要的集成修改
3. **向后兼容**：重构后的功能应与现有功能完全一致
4. **渐进式重构**：分阶段进行，每个阶段都可以独立测试和验证

### 6.2 风险控制

1. **充分测试**：每个阶段完成后进行完整测试
2. **功能对比**：确保重构后功能与重构前完全一致
3. **回滚方案**：每个阶段保留回滚能力

## 七、实施计划

### 7.1 短期计划（1-2周）

- [ ] 创建基础架构（接口、抽象类、管理器）
- [ ] 实现数字人渲染器（独立模块）
- [ ] 集成数字人渲染器到主应用（最小化修改）
- [ ] 测试验证

### 7.2 中期计划（1个月）

- [ ] 重构立绘渲染器
- [ ] 统一所有渲染器接口
- [ ] 完善文档和测试

### 7.3 长期计划（持续）

- [ ] 支持更多渲染器类型
- [ ] 优化渲染器性能
- [ ] 完善插件机制

## 八、参考文档

- [ROLE_DEVELOPMENT_TRACKING.md](./ROLE_DEVELOPMENT_TRACKING.md) - 角色管理功能开发进度追踪
- [数字人代码审查报告.md](./数字人代码审查报告.md) - 数字人代码审查报告
